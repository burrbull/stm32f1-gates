#[allow(unused_imports)]
use core::marker::PhantomData;
#[allow(unused_imports)]
use core::ops::Deref;
#[doc = r" Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 4;
#[cfg(feature = "rt")]
extern "C" {
    fn WWDG();
    fn PVD();
    fn TAMPER_STAMP();
    fn RTC_WKUP();
    fn FLASH();
    fn RCC();
    fn EXTI0();
    fn EXTI1();
    fn EXTI2();
    fn EXTI3();
    fn EXTI4();
    fn DMA1_CHANNEL1();
    fn DMA1_CHANNEL2();
    fn DMA1_CHANNEL3();
    fn DMA1_CHANNEL4();
    fn DMA1_CHANNEL5();
    fn DMA1_CHANNEL6();
    fn DMA1_CHANNEL7();
    fn ADC();
    fn EXTI9_5();
    fn TIM1_BRK_TIM15();
    fn TIM1_UP_TIM16();
    fn TIM1_TRG_COM_TIM17();
    fn TIM1_CC();
    fn TIM2();
    fn TIM3();
    fn TIM4();
    fn I2C1_EV();
    fn I2C1_ER();
    fn I2C2_EV();
    fn I2C2_ER();
    fn SPI1();
    fn SPI2();
    fn USART1();
    fn USART2();
    fn USART3();
    fn EXTI15_10();
    fn RTCALARM();
    fn CEC();
    fn TIM12();
    fn TIM13();
    fn TIM14();
    fn FSMC();
    fn TIM5();
    fn SPI3();
    fn UART4();
    fn UART5();
    fn TIM6_DAC();
    fn TIM7();
    fn DMA2_CHANNEL1();
    fn DMA2_CHANNEL2();
    fn DMA2_CHANNEL3();
    fn DMA2_CHANNEL4_5();
}
#[doc(hidden)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 60] = [
    Vector { _handler: WWDG },
    Vector { _handler: PVD },
    Vector {
        _handler: TAMPER_STAMP,
    },
    Vector { _handler: RTC_WKUP },
    Vector { _handler: FLASH },
    Vector { _handler: RCC },
    Vector { _handler: EXTI0 },
    Vector { _handler: EXTI1 },
    Vector { _handler: EXTI2 },
    Vector { _handler: EXTI3 },
    Vector { _handler: EXTI4 },
    Vector {
        _handler: DMA1_CHANNEL1,
    },
    Vector {
        _handler: DMA1_CHANNEL2,
    },
    Vector {
        _handler: DMA1_CHANNEL3,
    },
    Vector {
        _handler: DMA1_CHANNEL4,
    },
    Vector {
        _handler: DMA1_CHANNEL5,
    },
    Vector {
        _handler: DMA1_CHANNEL6,
    },
    Vector {
        _handler: DMA1_CHANNEL7,
    },
    Vector { _handler: ADC },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: EXTI9_5 },
    Vector {
        _handler: TIM1_BRK_TIM15,
    },
    Vector {
        _handler: TIM1_UP_TIM16,
    },
    Vector {
        _handler: TIM1_TRG_COM_TIM17,
    },
    Vector { _handler: TIM1_CC },
    Vector { _handler: TIM2 },
    Vector { _handler: TIM3 },
    Vector { _handler: TIM4 },
    Vector { _handler: I2C1_EV },
    Vector { _handler: I2C1_ER },
    Vector { _handler: I2C2_EV },
    Vector { _handler: I2C2_ER },
    Vector { _handler: SPI1 },
    Vector { _handler: SPI2 },
    Vector { _handler: USART1 },
    Vector { _handler: USART2 },
    Vector { _handler: USART3 },
    Vector {
        _handler: EXTI15_10,
    },
    Vector { _handler: RTCALARM },
    Vector { _handler: CEC },
    Vector { _handler: TIM12 },
    Vector { _handler: TIM13 },
    Vector { _handler: TIM14 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: FSMC },
    Vector { _reserved: 0 },
    Vector { _handler: TIM5 },
    Vector { _handler: SPI3 },
    Vector { _handler: UART4 },
    Vector { _handler: UART5 },
    Vector { _handler: TIM6_DAC },
    Vector { _handler: TIM7 },
    Vector {
        _handler: DMA2_CHANNEL1,
    },
    Vector {
        _handler: DMA2_CHANNEL2,
    },
    Vector {
        _handler: DMA2_CHANNEL3,
    },
    Vector {
        _handler: DMA2_CHANNEL4_5,
    },
];
#[doc = r" Macro to override a device specific interrupt handler"]
#[doc = r""]
#[doc = r" # Syntax"]
#[doc = r""]
#[doc = r" ``` ignore"]
#[doc = r" interrupt!("]
#[doc = r"     // Name of the interrupt"]
#[doc = r"     $Name:ident,"]
#[doc = r""]
#[doc = r"     // Path to the interrupt handler (a function)"]
#[doc = r"     $handler:path,"]
#[doc = r""]
#[doc = r"     // Optional, state preserved across invocations of the handler"]
#[doc = r"     state: $State:ty = $initial_state:expr,"]
#[doc = r" );"]
#[doc = r" ```"]
#[doc = r""]
#[doc = r" Where `$Name` must match the name of one of the variants of the `Interrupt`"]
#[doc = r" enum."]
#[doc = r""]
#[doc = r" The handler must have signature `fn()` is no state was associated to it;"]
#[doc = r" otherwise its signature must be `fn(&mut $State)`."]
#[cfg(feature = "rt")]
#[macro_export]
macro_rules! interrupt {
    ( $ Name : ident , $ handler : path , state : $ State : ty = $ initial_state : expr ) => {
        #[allow(unsafe_code)]
        #[deny(private_no_mangle_fns)]
        #[no_mangle]
        pub unsafe extern "C" fn $Name() {
            static mut STATE: $State = $initial_state;
            let _ = $crate::Interrupt::$Name;
            let f: fn(&mut $State) = $handler;
            f(&mut STATE)
        }
    };
    ( $ Name : ident , $ handler : path ) => {
        #[allow(unsafe_code)]
        #[deny(private_no_mangle_fns)]
        #[no_mangle]
        pub unsafe extern "C" fn $Name() {
            let _ = $crate::Interrupt::$Name;
            let f: fn() = $handler;
            f()
        }
    };
}
#[doc = r" Enumeration of all the interrupts"]
pub enum Interrupt {
    #[doc = "0 - Window Watchdog interrupt"]
    WWDG,
    #[doc = "1 - PVD through EXTI line detection interrupt"]
    PVD,
    #[doc = "2 - Tamper and TimeStamp through EXTI line interrupts"]
    TAMPER_STAMP,
    #[doc = "3 - RTC Wakeup through EXTI line interrupt"]
    RTC_WKUP,
    #[doc = "4 - Flash global interrupt"]
    FLASH,
    #[doc = "5 - RCC global interrupt"]
    RCC,
    #[doc = "6 - EXTI Line0 interrupt"]
    EXTI0,
    #[doc = "7 - EXTI Line1 interrupt"]
    EXTI1,
    #[doc = "8 - EXTI Line2 interrupt"]
    EXTI2,
    #[doc = "9 - EXTI Line3 interrupt"]
    EXTI3,
    #[doc = "10 - EXTI Line4 interrupt"]
    EXTI4,
    #[doc = "11 - DMA1 Channel1 global interrupt"]
    DMA1_CHANNEL1,
    #[doc = "12 - DMA1 Channel2 global interrupt"]
    DMA1_CHANNEL2,
    #[doc = "13 - DMA1 Channel3 global interrupt"]
    DMA1_CHANNEL3,
    #[doc = "14 - DMA1 Channel4 global interrupt"]
    DMA1_CHANNEL4,
    #[doc = "15 - DMA1 Channel5 global interrupt"]
    DMA1_CHANNEL5,
    #[doc = "16 - DMA1 Channel6 global interrupt"]
    DMA1_CHANNEL6,
    #[doc = "17 - DMA1 Channel7 global interrupt"]
    DMA1_CHANNEL7,
    #[doc = "18 - ADC1 global interrupt"]
    ADC,
    #[doc = "23 - EXTI Line\\[9:5\\] interrupts"]
    EXTI9_5,
    #[doc = "24 - TIM1 Break interrupt and TIM15 global interrupt"]
    TIM1_BRK_TIM15,
    #[doc = "25 - TIM1 Update interrupt and TIM16 global interrupt"]
    TIM1_UP_TIM16,
    #[doc = "26 - TIM1 Trigger and Commutation interrupts and TIM17 global interrupt"]
    TIM1_TRG_COM_TIM17,
    #[doc = "27 - TIM1 Capture Compare interrupt"]
    TIM1_CC,
    #[doc = "28 - TIM2 global interrupt"]
    TIM2,
    #[doc = "29 - TIM3 global interrupt"]
    TIM3,
    #[doc = "30 - TIM4 global interrupt"]
    TIM4,
    #[doc = "31 - I2C1 event interrupt"]
    I2C1_EV,
    #[doc = "32 - I2C1 error interrupt"]
    I2C1_ER,
    #[doc = "33 - I2C2 event interrupt"]
    I2C2_EV,
    #[doc = "34 - I2C2 error interrupt"]
    I2C2_ER,
    #[doc = "35 - SPI1 global interrupt"]
    SPI1,
    #[doc = "36 - SPI2 global interrupt"]
    SPI2,
    #[doc = "37 - USART1 global interrupt"]
    USART1,
    #[doc = "38 - USART2 global interrupt"]
    USART2,
    #[doc = "39 - USART3 global interrupt"]
    USART3,
    #[doc = "40 - EXTI Line\\[15:10\\] interrupts"]
    EXTI15_10,
    #[doc = "41 - RTC Alarms through EXTI line interrupt"]
    RTCALARM,
    #[doc = "42 - CEC global interrupt"]
    CEC,
    #[doc = "43 - TIM12 global interrupt"]
    TIM12,
    #[doc = "44 - TIM13 global interrupt"]
    TIM13,
    #[doc = "45 - TIM14 global interrupt"]
    TIM14,
    #[doc = "48 - FSMC global interrupt"]
    FSMC,
    #[doc = "50 - TIM5 global interrupt"]
    TIM5,
    #[doc = "51 - SPI3 global interrupt"]
    SPI3,
    #[doc = "52 - UART4 global interrupt"]
    UART4,
    #[doc = "53 - UART5 global interrupt"]
    UART5,
    #[doc = "54 - TIM6 global and DAC underrun interrupts"]
    TIM6_DAC,
    #[doc = "55 - TIM7 global interrupt"]
    TIM7,
    #[doc = "56 - DMA2 Channel1 global interrupt"]
    DMA2_CHANNEL1,
    #[doc = "57 - DMA2 Channel2 global interrupt"]
    DMA2_CHANNEL2,
    #[doc = "58 - DMA2 Channel3 global interrupt"]
    DMA2_CHANNEL3,
    #[doc = "59 - DMA2 Channel4 and DMA2 Channel5 global interrupt"]
    DMA2_CHANNEL4_5,
}
unsafe impl ::bare_metal::Nr for Interrupt {
    #[inline]
    fn nr(&self) -> u8 {
        match *self {
            Interrupt::WWDG => 0,
            Interrupt::PVD => 1,
            Interrupt::TAMPER_STAMP => 2,
            Interrupt::RTC_WKUP => 3,
            Interrupt::FLASH => 4,
            Interrupt::RCC => 5,
            Interrupt::EXTI0 => 6,
            Interrupt::EXTI1 => 7,
            Interrupt::EXTI2 => 8,
            Interrupt::EXTI3 => 9,
            Interrupt::EXTI4 => 10,
            Interrupt::DMA1_CHANNEL1 => 11,
            Interrupt::DMA1_CHANNEL2 => 12,
            Interrupt::DMA1_CHANNEL3 => 13,
            Interrupt::DMA1_CHANNEL4 => 14,
            Interrupt::DMA1_CHANNEL5 => 15,
            Interrupt::DMA1_CHANNEL6 => 16,
            Interrupt::DMA1_CHANNEL7 => 17,
            Interrupt::ADC => 18,
            Interrupt::EXTI9_5 => 23,
            Interrupt::TIM1_BRK_TIM15 => 24,
            Interrupt::TIM1_UP_TIM16 => 25,
            Interrupt::TIM1_TRG_COM_TIM17 => 26,
            Interrupt::TIM1_CC => 27,
            Interrupt::TIM2 => 28,
            Interrupt::TIM3 => 29,
            Interrupt::TIM4 => 30,
            Interrupt::I2C1_EV => 31,
            Interrupt::I2C1_ER => 32,
            Interrupt::I2C2_EV => 33,
            Interrupt::I2C2_ER => 34,
            Interrupt::SPI1 => 35,
            Interrupt::SPI2 => 36,
            Interrupt::USART1 => 37,
            Interrupt::USART2 => 38,
            Interrupt::USART3 => 39,
            Interrupt::EXTI15_10 => 40,
            Interrupt::RTCALARM => 41,
            Interrupt::CEC => 42,
            Interrupt::TIM12 => 43,
            Interrupt::TIM13 => 44,
            Interrupt::TIM14 => 45,
            Interrupt::FSMC => 48,
            Interrupt::TIM5 => 50,
            Interrupt::SPI3 => 51,
            Interrupt::UART4 => 52,
            Interrupt::UART5 => 53,
            Interrupt::TIM6_DAC => 54,
            Interrupt::TIM7 => 55,
            Interrupt::DMA2_CHANNEL1 => 56,
            Interrupt::DMA2_CHANNEL2 => 57,
            Interrupt::DMA2_CHANNEL3 => 58,
            Interrupt::DMA2_CHANNEL4_5 => 59,
        }
    }
}
#[doc(hidden)]
pub mod interrupt {}
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::{CBP, CPUID, DCB, DWT, FPB, ITM, MPU, NVIC, SCB, SYST, TPIU};
#[doc = "Flexible static memory controller"]
#[cfg(feature = "fsmc")]
pub struct FSMC {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "fsmc")]
unsafe impl Send for FSMC {}
#[cfg(feature = "fsmc")]
impl FSMC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const fsmc::RegisterBlock {
        0xa000_0000 as *const _
    }
}
#[cfg(feature = "fsmc")]
impl Deref for FSMC {
    type Target = fsmc::RegisterBlock;
    fn deref(&self) -> &fsmc::RegisterBlock {
        unsafe { &*FSMC::ptr() }
    }
}
#[doc = "Flexible static memory controller"]
#[cfg(feature = "fsmc")]
pub mod fsmc {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - SRAM/NOR-Flash chip-select control register 1"]
        pub bcr1: BCR,
        #[doc = "0x04 - SRAM/NOR-Flash chip-select timing register 1"]
        pub btr1: BTR,
        #[doc = "0x08 - SRAM/NOR-Flash chip-select control register 1"]
        pub bcr2: BCR,
        #[doc = "0x0c - SRAM/NOR-Flash chip-select timing register 1"]
        pub btr2: BTR,
        #[doc = "0x10 - SRAM/NOR-Flash chip-select control register 1"]
        pub bcr3: BCR,
        #[doc = "0x14 - SRAM/NOR-Flash chip-select timing register 1"]
        pub btr3: BTR,
        #[doc = "0x18 - SRAM/NOR-Flash chip-select control register 1"]
        pub bcr4: BCR,
        #[doc = "0x1c - SRAM/NOR-Flash chip-select timing register 1"]
        pub btr4: BTR,
        _reserved0: [u8; 228usize],
        #[doc = "0x104 - SRAM/NOR-Flash write timing registers 1"]
        pub bwtr1: BWTR,
        _reserved1: [u8; 4usize],
        #[doc = "0x10c - SRAM/NOR-Flash write timing registers 1"]
        pub bwtr2: BWTR,
        _reserved2: [u8; 4usize],
        #[doc = "0x114 - SRAM/NOR-Flash write timing registers 1"]
        pub bwtr3: BWTR,
        _reserved3: [u8; 4usize],
        #[doc = "0x11c - SRAM/NOR-Flash write timing registers 1"]
        pub bwtr4: BWTR,
    }
    #[doc = "SRAM/NOR-Flash chip-select control register 1"]
    pub struct BCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SRAM/NOR-Flash chip-select control register 1"]
    pub mod bcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CBURSTRWR {
            bits: bool,
        }
        impl CBURSTRWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ASYNCWAITR {
            bits: bool,
        }
        impl ASYNCWAITR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTMODR {
            bits: bool,
        }
        impl EXTMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAITENR {
            bits: bool,
        }
        impl WAITENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WRENR {
            bits: bool,
        }
        impl WRENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAITCFGR {
            bits: bool,
        }
        impl WAITCFGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAITPOLR {
            bits: bool,
        }
        impl WAITPOLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BURSTENR {
            bits: bool,
        }
        impl BURSTENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FACCENR {
            bits: bool,
        }
        impl FACCENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MWIDR {
            bits: u8,
        }
        impl MWIDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MTYPR {
            bits: u8,
        }
        impl MTYPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MUXENR {
            bits: bool,
        }
        impl MUXENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MBKENR {
            bits: bool,
        }
        impl MBKENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WRAPMODR {
            bits: bool,
        }
        impl WRAPMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CBURSTRWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CBURSTRWW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ASYNCWAITW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ASYNCWAITW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTMODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTMODW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAITENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAITENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAITCFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAITCFGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAITPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAITPOLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BURSTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BURSTENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FACCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FACCENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MWIDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MWIDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MTYPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MTYPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MUXENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MUXENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MBKENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MBKENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRAPMODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRAPMODW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 19 - CBURSTRW"]
            #[inline]
            pub fn cburstrw(&self) -> CBURSTRWR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CBURSTRWR { bits }
            }
            #[doc = "Bit 15 - ASYNCWAIT"]
            #[inline]
            pub fn asyncwait(&self) -> ASYNCWAITR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ASYNCWAITR { bits }
            }
            #[doc = "Bit 14 - EXTMOD"]
            #[inline]
            pub fn extmod(&self) -> EXTMODR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTMODR { bits }
            }
            #[doc = "Bit 13 - WAITEN"]
            #[inline]
            pub fn waiten(&self) -> WAITENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAITENR { bits }
            }
            #[doc = "Bit 12 - WREN"]
            #[inline]
            pub fn wren(&self) -> WRENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WRENR { bits }
            }
            #[doc = "Bit 11 - WAITCFG"]
            #[inline]
            pub fn waitcfg(&self) -> WAITCFGR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAITCFGR { bits }
            }
            #[doc = "Bit 9 - WAITPOL"]
            #[inline]
            pub fn waitpol(&self) -> WAITPOLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAITPOLR { bits }
            }
            #[doc = "Bit 8 - BURSTEN"]
            #[inline]
            pub fn bursten(&self) -> BURSTENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BURSTENR { bits }
            }
            #[doc = "Bit 6 - FACCEN"]
            #[inline]
            pub fn faccen(&self) -> FACCENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FACCENR { bits }
            }
            #[doc = "Bits 4:5 - MWID"]
            #[inline]
            pub fn mwid(&self) -> MWIDR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MWIDR { bits }
            }
            #[doc = "Bits 2:3 - MTYP"]
            #[inline]
            pub fn mtyp(&self) -> MTYPR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MTYPR { bits }
            }
            #[doc = "Bit 1 - MUXEN"]
            #[inline]
            pub fn muxen(&self) -> MUXENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MUXENR { bits }
            }
            #[doc = "Bit 0 - MBKEN"]
            #[inline]
            pub fn mbken(&self) -> MBKENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MBKENR { bits }
            }
            #[doc = "Bit 10 - WRAPMOD"]
            #[inline]
            pub fn wrapmod(&self) -> WRAPMODR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WRAPMODR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x30d0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 19 - CBURSTRW"]
            #[inline]
            pub fn cburstrw(&mut self) -> _CBURSTRWW {
                _CBURSTRWW { w: self }
            }
            #[doc = "Bit 15 - ASYNCWAIT"]
            #[inline]
            pub fn asyncwait(&mut self) -> _ASYNCWAITW {
                _ASYNCWAITW { w: self }
            }
            #[doc = "Bit 14 - EXTMOD"]
            #[inline]
            pub fn extmod(&mut self) -> _EXTMODW {
                _EXTMODW { w: self }
            }
            #[doc = "Bit 13 - WAITEN"]
            #[inline]
            pub fn waiten(&mut self) -> _WAITENW {
                _WAITENW { w: self }
            }
            #[doc = "Bit 12 - WREN"]
            #[inline]
            pub fn wren(&mut self) -> _WRENW {
                _WRENW { w: self }
            }
            #[doc = "Bit 11 - WAITCFG"]
            #[inline]
            pub fn waitcfg(&mut self) -> _WAITCFGW {
                _WAITCFGW { w: self }
            }
            #[doc = "Bit 9 - WAITPOL"]
            #[inline]
            pub fn waitpol(&mut self) -> _WAITPOLW {
                _WAITPOLW { w: self }
            }
            #[doc = "Bit 8 - BURSTEN"]
            #[inline]
            pub fn bursten(&mut self) -> _BURSTENW {
                _BURSTENW { w: self }
            }
            #[doc = "Bit 6 - FACCEN"]
            #[inline]
            pub fn faccen(&mut self) -> _FACCENW {
                _FACCENW { w: self }
            }
            #[doc = "Bits 4:5 - MWID"]
            #[inline]
            pub fn mwid(&mut self) -> _MWIDW {
                _MWIDW { w: self }
            }
            #[doc = "Bits 2:3 - MTYP"]
            #[inline]
            pub fn mtyp(&mut self) -> _MTYPW {
                _MTYPW { w: self }
            }
            #[doc = "Bit 1 - MUXEN"]
            #[inline]
            pub fn muxen(&mut self) -> _MUXENW {
                _MUXENW { w: self }
            }
            #[doc = "Bit 0 - MBKEN"]
            #[inline]
            pub fn mbken(&mut self) -> _MBKENW {
                _MBKENW { w: self }
            }
            #[doc = "Bit 10 - WRAPMOD"]
            #[inline]
            pub fn wrapmod(&mut self) -> _WRAPMODW {
                _WRAPMODW { w: self }
            }
        }
    }
    #[doc = "SRAM/NOR-Flash chip-select timing register 1"]
    pub struct BTR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SRAM/NOR-Flash chip-select timing register 1"]
    pub mod btr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACCMODR {
            bits: u8,
        }
        impl ACCMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATLATR {
            bits: u8,
        }
        impl DATLATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKDIVR {
            bits: u8,
        }
        impl CLKDIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSTURNR {
            bits: u8,
        }
        impl BUSTURNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATASTR {
            bits: u8,
        }
        impl DATASTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDHLDR {
            bits: u8,
        }
        impl ADDHLDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDSETR {
            bits: u8,
        }
        impl ADDSETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACCMODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACCMODW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATLATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATLATW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKDIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKDIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BUSTURNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BUSTURNW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATASTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATASTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDHLDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDHLDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDSETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDSETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 28:29 - ACCMOD"]
            #[inline]
            pub fn accmod(&self) -> ACCMODR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ACCMODR { bits }
            }
            #[doc = "Bits 24:27 - DATLAT"]
            #[inline]
            pub fn datlat(&self) -> DATLATR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATLATR { bits }
            }
            #[doc = "Bits 20:23 - CLKDIV"]
            #[inline]
            pub fn clkdiv(&self) -> CLKDIVR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLKDIVR { bits }
            }
            #[doc = "Bits 16:19 - BUSTURN"]
            #[inline]
            pub fn busturn(&self) -> BUSTURNR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BUSTURNR { bits }
            }
            #[doc = "Bits 8:15 - DATAST"]
            #[inline]
            pub fn datast(&self) -> DATASTR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATASTR { bits }
            }
            #[doc = "Bits 4:7 - ADDHLD"]
            #[inline]
            pub fn addhld(&self) -> ADDHLDR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADDHLDR { bits }
            }
            #[doc = "Bits 0:3 - ADDSET"]
            #[inline]
            pub fn addset(&self) -> ADDSETR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADDSETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 28:29 - ACCMOD"]
            #[inline]
            pub fn accmod(&mut self) -> _ACCMODW {
                _ACCMODW { w: self }
            }
            #[doc = "Bits 24:27 - DATLAT"]
            #[inline]
            pub fn datlat(&mut self) -> _DATLATW {
                _DATLATW { w: self }
            }
            #[doc = "Bits 20:23 - CLKDIV"]
            #[inline]
            pub fn clkdiv(&mut self) -> _CLKDIVW {
                _CLKDIVW { w: self }
            }
            #[doc = "Bits 16:19 - BUSTURN"]
            #[inline]
            pub fn busturn(&mut self) -> _BUSTURNW {
                _BUSTURNW { w: self }
            }
            #[doc = "Bits 8:15 - DATAST"]
            #[inline]
            pub fn datast(&mut self) -> _DATASTW {
                _DATASTW { w: self }
            }
            #[doc = "Bits 4:7 - ADDHLD"]
            #[inline]
            pub fn addhld(&mut self) -> _ADDHLDW {
                _ADDHLDW { w: self }
            }
            #[doc = "Bits 0:3 - ADDSET"]
            #[inline]
            pub fn addset(&mut self) -> _ADDSETW {
                _ADDSETW { w: self }
            }
        }
    }
    #[doc = "SRAM/NOR-Flash write timing registers 1"]
    pub struct BWTR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SRAM/NOR-Flash write timing registers 1"]
    pub mod bwtr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BWTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACCMODR {
            bits: u8,
        }
        impl ACCMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATLATR {
            bits: u8,
        }
        impl DATLATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKDIVR {
            bits: u8,
        }
        impl CLKDIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATASTR {
            bits: u8,
        }
        impl DATASTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDHLDR {
            bits: u8,
        }
        impl ADDHLDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDSETR {
            bits: u8,
        }
        impl ADDSETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACCMODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACCMODW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATLATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATLATW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKDIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKDIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATASTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATASTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDHLDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDHLDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDSETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDSETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 28:29 - ACCMOD"]
            #[inline]
            pub fn accmod(&self) -> ACCMODR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ACCMODR { bits }
            }
            #[doc = "Bits 24:27 - DATLAT"]
            #[inline]
            pub fn datlat(&self) -> DATLATR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATLATR { bits }
            }
            #[doc = "Bits 20:23 - CLKDIV"]
            #[inline]
            pub fn clkdiv(&self) -> CLKDIVR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLKDIVR { bits }
            }
            #[doc = "Bits 8:15 - DATAST"]
            #[inline]
            pub fn datast(&self) -> DATASTR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATASTR { bits }
            }
            #[doc = "Bits 4:7 - ADDHLD"]
            #[inline]
            pub fn addhld(&self) -> ADDHLDR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADDHLDR { bits }
            }
            #[doc = "Bits 0:3 - ADDSET"]
            #[inline]
            pub fn addset(&self) -> ADDSETR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADDSETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0fff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 28:29 - ACCMOD"]
            #[inline]
            pub fn accmod(&mut self) -> _ACCMODW {
                _ACCMODW { w: self }
            }
            #[doc = "Bits 24:27 - DATLAT"]
            #[inline]
            pub fn datlat(&mut self) -> _DATLATW {
                _DATLATW { w: self }
            }
            #[doc = "Bits 20:23 - CLKDIV"]
            #[inline]
            pub fn clkdiv(&mut self) -> _CLKDIVW {
                _CLKDIVW { w: self }
            }
            #[doc = "Bits 8:15 - DATAST"]
            #[inline]
            pub fn datast(&mut self) -> _DATASTW {
                _DATASTW { w: self }
            }
            #[doc = "Bits 4:7 - ADDHLD"]
            #[inline]
            pub fn addhld(&mut self) -> _ADDHLDW {
                _ADDHLDW { w: self }
            }
            #[doc = "Bits 0:3 - ADDSET"]
            #[inline]
            pub fn addset(&mut self) -> _ADDSETW {
                _ADDSETW { w: self }
            }
        }
    }
}
#[doc = "Power control"]
#[cfg(feature = "pwr")]
pub struct PWR {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "pwr")]
unsafe impl Send for PWR {}
#[cfg(feature = "pwr")]
impl PWR {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const pwr::RegisterBlock {
        0x4000_7000 as *const _
    }
}
#[cfg(feature = "pwr")]
impl Deref for PWR {
    type Target = pwr::RegisterBlock;
    fn deref(&self) -> &pwr::RegisterBlock {
        unsafe { &*PWR::ptr() }
    }
}
#[doc = "Power control"]
#[cfg(feature = "pwr")]
pub mod pwr {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Power control register (PWR_CR)"]
        pub cr: CR,
        #[doc = "0x04 - Power control register (PWR_CR)"]
        pub csr: CSR,
    }
    #[doc = "Power control register (PWR_CR)"]
    pub struct CR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Power control register (PWR_CR)"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LPDSR {
            bits: bool,
        }
        impl LPDSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `PDDS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PDDSR {
            #[doc = "Enter Stop mode when the CPU enters deepsleep"]
            STOP_MODE,
            #[doc = "Enter Standby mode when the CPU enters deepsleep"]
            STANDBY_MODE,
        }
        impl PDDSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PDDSR::STOP_MODE => false,
                    PDDSR::STANDBY_MODE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PDDSR {
                match value {
                    false => PDDSR::STOP_MODE,
                    true => PDDSR::STANDBY_MODE,
                }
            }
            #[doc = "Checks if the value of the field is `STOP_MODE`"]
            #[inline]
            pub fn is_stop_mode(&self) -> bool {
                *self == PDDSR::STOP_MODE
            }
            #[doc = "Checks if the value of the field is `STANDBY_MODE`"]
            #[inline]
            pub fn is_standby_mode(&self) -> bool {
                *self == PDDSR::STANDBY_MODE
            }
        }
        #[doc = r" Value of the field"]
        pub struct CWUFR {
            bits: bool,
        }
        impl CWUFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CSBFR {
            bits: bool,
        }
        impl CSBFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PVDER {
            bits: bool,
        }
        impl PVDER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PLSR {
            bits: u8,
        }
        impl PLSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBPR {
            bits: bool,
        }
        impl DBPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _LPDSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LPDSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PDDS`"]
        pub enum PDDSW {
            #[doc = "Enter Stop mode when the CPU enters deepsleep"]
            STOP_MODE,
            #[doc = "Enter Standby mode when the CPU enters deepsleep"]
            STANDBY_MODE,
        }
        impl PDDSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PDDSW::STOP_MODE => false,
                    PDDSW::STANDBY_MODE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PDDSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PDDSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PDDSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enter Stop mode when the CPU enters deepsleep"]
            #[inline]
            pub fn stop_mode(self) -> &'a mut W {
                self.variant(PDDSW::STOP_MODE)
            }
            #[doc = "Enter Standby mode when the CPU enters deepsleep"]
            #[inline]
            pub fn standby_mode(self) -> &'a mut W {
                self.variant(PDDSW::STANDBY_MODE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CWUFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CWUFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CSBFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CSBFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PVDEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PVDEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PLSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PLSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Low Power Deep Sleep"]
            #[inline]
            pub fn lpds(&self) -> LPDSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LPDSR { bits }
            }
            #[doc = "Bit 1 - Power Down Deep Sleep"]
            #[inline]
            pub fn pdds(&self) -> PDDSR {
                PDDSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Clear Wake-up Flag"]
            #[inline]
            pub fn cwuf(&self) -> CWUFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CWUFR { bits }
            }
            #[doc = "Bit 3 - Clear STANDBY Flag"]
            #[inline]
            pub fn csbf(&self) -> CSBFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CSBFR { bits }
            }
            #[doc = "Bit 4 - Power Voltage Detector Enable"]
            #[inline]
            pub fn pvde(&self) -> PVDER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PVDER { bits }
            }
            #[doc = "Bits 5:7 - PVD Level Selection"]
            #[inline]
            pub fn pls(&self) -> PLSR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PLSR { bits }
            }
            #[doc = "Bit 8 - Disable Backup Domain write protection"]
            #[inline]
            pub fn dbp(&self) -> DBPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Low Power Deep Sleep"]
            #[inline]
            pub fn lpds(&mut self) -> _LPDSW {
                _LPDSW { w: self }
            }
            #[doc = "Bit 1 - Power Down Deep Sleep"]
            #[inline]
            pub fn pdds(&mut self) -> _PDDSW {
                _PDDSW { w: self }
            }
            #[doc = "Bit 2 - Clear Wake-up Flag"]
            #[inline]
            pub fn cwuf(&mut self) -> _CWUFW {
                _CWUFW { w: self }
            }
            #[doc = "Bit 3 - Clear STANDBY Flag"]
            #[inline]
            pub fn csbf(&mut self) -> _CSBFW {
                _CSBFW { w: self }
            }
            #[doc = "Bit 4 - Power Voltage Detector Enable"]
            #[inline]
            pub fn pvde(&mut self) -> _PVDEW {
                _PVDEW { w: self }
            }
            #[doc = "Bits 5:7 - PVD Level Selection"]
            #[inline]
            pub fn pls(&mut self) -> _PLSW {
                _PLSW { w: self }
            }
            #[doc = "Bit 8 - Disable Backup Domain write protection"]
            #[inline]
            pub fn dbp(&mut self) -> _DBPW {
                _DBPW { w: self }
            }
        }
    }
    #[doc = "Power control register (PWR_CR)"]
    pub struct CSR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Power control register (PWR_CR)"]
    pub mod csr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CSR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WUFR {
            bits: bool,
        }
        impl WUFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SBFR {
            bits: bool,
        }
        impl SBFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PVDOR {
            bits: bool,
        }
        impl PVDOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EWUPR {
            bits: bool,
        }
        impl EWUPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EWUPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EWUPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Wake-Up Flag"]
            #[inline]
            pub fn wuf(&self) -> WUFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WUFR { bits }
            }
            #[doc = "Bit 1 - STANDBY Flag"]
            #[inline]
            pub fn sbf(&self) -> SBFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SBFR { bits }
            }
            #[doc = "Bit 2 - PVD Output"]
            #[inline]
            pub fn pvdo(&self) -> PVDOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PVDOR { bits }
            }
            #[doc = "Bit 8 - Enable WKUP pin"]
            #[inline]
            pub fn ewup(&self) -> EWUPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EWUPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 8 - Enable WKUP pin"]
            #[inline]
            pub fn ewup(&mut self) -> _EWUPW {
                _EWUPW { w: self }
            }
        }
    }
}
#[doc = "Reset and clock control"]
#[cfg(feature = "rcc")]
pub struct RCC {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "rcc")]
unsafe impl Send for RCC {}
#[cfg(feature = "rcc")]
impl RCC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const rcc::RegisterBlock {
        0x4002_1000 as *const _
    }
}
#[cfg(feature = "rcc")]
impl Deref for RCC {
    type Target = rcc::RegisterBlock;
    fn deref(&self) -> &rcc::RegisterBlock {
        unsafe { &*RCC::ptr() }
    }
}
#[doc = "Reset and clock control"]
#[cfg(feature = "rcc")]
pub mod rcc {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Clock control register"]
        pub cr: CR,
        #[doc = "0x04 - Clock configuration register (RCC_CFGR)"]
        pub cfgr: CFGR,
        #[doc = "0x08 - Clock interrupt register (RCC_CIR)"]
        pub cir: CIR,
        #[doc = "0x0c - APB2 peripheral reset register (RCC_APB2RSTR)"]
        pub apb2rstr: APB2RSTR,
        #[doc = "0x10 - APB1 peripheral reset register (RCC_APB1RSTR)"]
        pub apb1rstr: APB1RSTR,
        #[doc = "0x14 - AHB Peripheral Clock enable register (RCC_AHBENR)"]
        pub ahbenr: AHBENR,
        #[doc = "0x18 - APB2 peripheral clock enable register (RCC_APB2ENR)"]
        pub apb2enr: APB2ENR,
        #[doc = "0x1c - APB1 peripheral clock enable register (RCC_APB1ENR)"]
        pub apb1enr: APB1ENR,
        #[doc = "0x20 - Backup domain control register (RCC_BDCR)"]
        pub bdcr: BDCR,
        #[doc = "0x24 - Control/status register (RCC_CSR)"]
        pub csr: CSR,
        _reserved0: [u8; 4usize],
        #[doc = "0x2c - Clock configuration register 2"]
        pub cfgr2: CFGR2,
    }
    #[doc = "Clock control register"]
    pub struct CR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock control register"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `HSION`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HSIONR {
            #[doc = "Clock Off"]
            OFF,
            #[doc = "Clock On"]
            ON,
        }
        impl HSIONR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HSIONR::OFF => false,
                    HSIONR::ON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HSIONR {
                match value {
                    false => HSIONR::OFF,
                    true => HSIONR::ON,
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline]
            pub fn is_off(&self) -> bool {
                *self == HSIONR::OFF
            }
            #[doc = "Checks if the value of the field is `ON`"]
            #[inline]
            pub fn is_on(&self) -> bool {
                *self == HSIONR::ON
            }
        }
        #[doc = "Possible values of the field `HSIRDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HSIRDYR {
            #[doc = "Clock not ready"]
            NOTREADY,
            #[doc = "Clock ready"]
            READY,
        }
        impl HSIRDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HSIRDYR::NOTREADY => false,
                    HSIRDYR::READY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HSIRDYR {
                match value {
                    false => HSIRDYR::NOTREADY,
                    true => HSIRDYR::READY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline]
            pub fn is_not_ready(&self) -> bool {
                *self == HSIRDYR::NOTREADY
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline]
            pub fn is_ready(&self) -> bool {
                *self == HSIRDYR::READY
            }
        }
        #[doc = r" Value of the field"]
        pub struct HSITRIMR {
            bits: u8,
        }
        impl HSITRIMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HSICALR {
            bits: u8,
        }
        impl HSICALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `HSEON`"]
        pub type HSEONR = HSIONR;
        #[doc = "Possible values of the field `HSERDY`"]
        pub type HSERDYR = HSIRDYR;
        #[doc = "Possible values of the field `HSEBYP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HSEBYPR {
            #[doc = "HSE crystal oscillator not bypassed"]
            NOTBYPASSED,
            #[doc = "HSE crystal oscillator bypassed with external clock"]
            BYPASSED,
        }
        impl HSEBYPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HSEBYPR::NOTBYPASSED => false,
                    HSEBYPR::BYPASSED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HSEBYPR {
                match value {
                    false => HSEBYPR::NOTBYPASSED,
                    true => HSEBYPR::BYPASSED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTBYPASSED`"]
            #[inline]
            pub fn is_not_bypassed(&self) -> bool {
                *self == HSEBYPR::NOTBYPASSED
            }
            #[doc = "Checks if the value of the field is `BYPASSED`"]
            #[inline]
            pub fn is_bypassed(&self) -> bool {
                *self == HSEBYPR::BYPASSED
            }
        }
        #[doc = "Possible values of the field `CSSON`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CSSONR {
            #[doc = "Clock security system disabled (clock detector OFF)"]
            OFF,
            #[doc = "Clock security system enable (clock detector ON if the HSE is ready, OFF if not)"]
            ON,
        }
        impl CSSONR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CSSONR::OFF => false,
                    CSSONR::ON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CSSONR {
                match value {
                    false => CSSONR::OFF,
                    true => CSSONR::ON,
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline]
            pub fn is_off(&self) -> bool {
                *self == CSSONR::OFF
            }
            #[doc = "Checks if the value of the field is `ON`"]
            #[inline]
            pub fn is_on(&self) -> bool {
                *self == CSSONR::ON
            }
        }
        #[doc = "Possible values of the field `PLLON`"]
        pub type PLLONR = HSIONR;
        #[doc = "Possible values of the field `PLLRDY`"]
        pub type PLLRDYR = HSIRDYR;
        #[doc = "Values that can be written to the field `HSION`"]
        pub enum HSIONW {
            #[doc = "Clock Off"]
            OFF,
            #[doc = "Clock On"]
            ON,
        }
        impl HSIONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HSIONW::OFF => false,
                    HSIONW::ON => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HSIONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HSIONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HSIONW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clock Off"]
            #[inline]
            pub fn off(self) -> &'a mut W {
                self.variant(HSIONW::OFF)
            }
            #[doc = "Clock On"]
            #[inline]
            pub fn on(self) -> &'a mut W {
                self.variant(HSIONW::ON)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HSITRIMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HSITRIMW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HSEON`"]
        pub type HSEONW = HSIONW;
        #[doc = r" Proxy"]
        pub struct _HSEONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HSEONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HSEONW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clock Off"]
            #[inline]
            pub fn off(self) -> &'a mut W {
                self.variant(HSIONW::OFF)
            }
            #[doc = "Clock On"]
            #[inline]
            pub fn on(self) -> &'a mut W {
                self.variant(HSIONW::ON)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HSEBYP`"]
        pub enum HSEBYPW {
            #[doc = "HSE crystal oscillator not bypassed"]
            NOTBYPASSED,
            #[doc = "HSE crystal oscillator bypassed with external clock"]
            BYPASSED,
        }
        impl HSEBYPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HSEBYPW::NOTBYPASSED => false,
                    HSEBYPW::BYPASSED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HSEBYPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HSEBYPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HSEBYPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "HSE crystal oscillator not bypassed"]
            #[inline]
            pub fn not_bypassed(self) -> &'a mut W {
                self.variant(HSEBYPW::NOTBYPASSED)
            }
            #[doc = "HSE crystal oscillator bypassed with external clock"]
            #[inline]
            pub fn bypassed(self) -> &'a mut W {
                self.variant(HSEBYPW::BYPASSED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CSSON`"]
        pub enum CSSONW {
            #[doc = "Clock security system disabled (clock detector OFF)"]
            OFF,
            #[doc = "Clock security system enable (clock detector ON if the HSE is ready, OFF if not)"]
            ON,
        }
        impl CSSONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CSSONW::OFF => false,
                    CSSONW::ON => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CSSONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CSSONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CSSONW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clock security system disabled (clock detector OFF)"]
            #[inline]
            pub fn off(self) -> &'a mut W {
                self.variant(CSSONW::OFF)
            }
            #[doc = "Clock security system enable (clock detector ON if the HSE is ready, OFF if not)"]
            #[inline]
            pub fn on(self) -> &'a mut W {
                self.variant(CSSONW::ON)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PLLON`"]
        pub type PLLONW = HSIONW;
        #[doc = r" Proxy"]
        pub struct _PLLONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PLLONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PLLONW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clock Off"]
            #[inline]
            pub fn off(self) -> &'a mut W {
                self.variant(HSIONW::OFF)
            }
            #[doc = "Clock On"]
            #[inline]
            pub fn on(self) -> &'a mut W {
                self.variant(HSIONW::ON)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Internal High Speed clock enable"]
            #[inline]
            pub fn hsion(&self) -> HSIONR {
                HSIONR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Internal High Speed clock ready flag"]
            #[inline]
            pub fn hsirdy(&self) -> HSIRDYR {
                HSIRDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 3:7 - Internal High Speed clock trimming"]
            #[inline]
            pub fn hsitrim(&self) -> HSITRIMR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HSITRIMR { bits }
            }
            #[doc = "Bits 8:15 - Internal High Speed clock Calibration"]
            #[inline]
            pub fn hsical(&self) -> HSICALR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HSICALR { bits }
            }
            #[doc = "Bit 16 - External High Speed clock enable"]
            #[inline]
            pub fn hseon(&self) -> HSEONR {
                HSEONR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - External High Speed clock ready flag"]
            #[inline]
            pub fn hserdy(&self) -> HSERDYR {
                HSERDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - External High Speed clock Bypass"]
            #[inline]
            pub fn hsebyp(&self) -> HSEBYPR {
                HSEBYPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Clock Security System enable"]
            #[inline]
            pub fn csson(&self) -> CSSONR {
                CSSONR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - PLL enable"]
            #[inline]
            pub fn pllon(&self) -> PLLONR {
                PLLONR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - PLL clock ready flag"]
            #[inline]
            pub fn pllrdy(&self) -> PLLRDYR {
                PLLRDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x83 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Internal High Speed clock enable"]
            #[inline]
            pub fn hsion(&mut self) -> _HSIONW {
                _HSIONW { w: self }
            }
            #[doc = "Bits 3:7 - Internal High Speed clock trimming"]
            #[inline]
            pub fn hsitrim(&mut self) -> _HSITRIMW {
                _HSITRIMW { w: self }
            }
            #[doc = "Bit 16 - External High Speed clock enable"]
            #[inline]
            pub fn hseon(&mut self) -> _HSEONW {
                _HSEONW { w: self }
            }
            #[doc = "Bit 18 - External High Speed clock Bypass"]
            #[inline]
            pub fn hsebyp(&mut self) -> _HSEBYPW {
                _HSEBYPW { w: self }
            }
            #[doc = "Bit 19 - Clock Security System enable"]
            #[inline]
            pub fn csson(&mut self) -> _CSSONW {
                _CSSONW { w: self }
            }
            #[doc = "Bit 24 - PLL enable"]
            #[inline]
            pub fn pllon(&mut self) -> _PLLONW {
                _PLLONW { w: self }
            }
        }
    }
    #[doc = "Clock configuration register (RCC_CFGR)"]
    pub struct CFGR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock configuration register (RCC_CFGR)"]
    pub mod cfgr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CFGR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SW`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWR {
            #[doc = "HSI selected as system clock"]
            HSI,
            #[doc = "HSE selected as system clock"]
            HSE,
            #[doc = "PLL selected as system clock"]
            PLL,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SWR::HSI => 0,
                    SWR::HSE => 0x01,
                    SWR::PLL => 0x02,
                    SWR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SWR {
                match value {
                    0 => SWR::HSI,
                    1 => SWR::HSE,
                    2 => SWR::PLL,
                    i => SWR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `HSI`"]
            #[inline]
            pub fn is_hsi(&self) -> bool {
                *self == SWR::HSI
            }
            #[doc = "Checks if the value of the field is `HSE`"]
            #[inline]
            pub fn is_hse(&self) -> bool {
                *self == SWR::HSE
            }
            #[doc = "Checks if the value of the field is `PLL`"]
            #[inline]
            pub fn is_pll(&self) -> bool {
                *self == SWR::PLL
            }
        }
        #[doc = "Possible values of the field `SWS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWSR {
            #[doc = "HSE oscillator used as system clock"]
            HSI,
            #[doc = "HSI oscillator used as system clock"]
            HSE,
            #[doc = "PLL used as system clock"]
            PLL,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SWSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SWSR::HSI => 0,
                    SWSR::HSE => 0x01,
                    SWSR::PLL => 0x02,
                    SWSR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SWSR {
                match value {
                    0 => SWSR::HSI,
                    1 => SWSR::HSE,
                    2 => SWSR::PLL,
                    i => SWSR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `HSI`"]
            #[inline]
            pub fn is_hsi(&self) -> bool {
                *self == SWSR::HSI
            }
            #[doc = "Checks if the value of the field is `HSE`"]
            #[inline]
            pub fn is_hse(&self) -> bool {
                *self == SWSR::HSE
            }
            #[doc = "Checks if the value of the field is `PLL`"]
            #[inline]
            pub fn is_pll(&self) -> bool {
                *self == SWSR::PLL
            }
        }
        #[doc = "Possible values of the field `HPRE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HPRER {
            #[doc = "SYSCLK not divided"]
            DIV1,
            #[doc = "SYSCLK divided by 2"]
            DIV2,
            #[doc = "SYSCLK divided by 4"]
            DIV4,
            #[doc = "SYSCLK divided by 8"]
            DIV8,
            #[doc = "SYSCLK divided by 16"]
            DIV16,
            #[doc = "SYSCLK divided by 64"]
            DIV64,
            #[doc = "SYSCLK divided by 128"]
            DIV128,
            #[doc = "SYSCLK divided by 256"]
            DIV256,
            #[doc = "SYSCLK divided by 512"]
            DIV512,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl HPRER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    HPRER::DIV1 => 0,
                    HPRER::DIV2 => 0x08,
                    HPRER::DIV4 => 0x09,
                    HPRER::DIV8 => 0x0a,
                    HPRER::DIV16 => 0x0b,
                    HPRER::DIV64 => 0x0c,
                    HPRER::DIV128 => 0x0d,
                    HPRER::DIV256 => 0x0e,
                    HPRER::DIV512 => 0x0f,
                    HPRER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> HPRER {
                match value {
                    0 => HPRER::DIV1,
                    8 => HPRER::DIV2,
                    9 => HPRER::DIV4,
                    10 => HPRER::DIV8,
                    11 => HPRER::DIV16,
                    12 => HPRER::DIV64,
                    13 => HPRER::DIV128,
                    14 => HPRER::DIV256,
                    15 => HPRER::DIV512,
                    i => HPRER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline]
            pub fn is_div1(&self) -> bool {
                *self == HPRER::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline]
            pub fn is_div2(&self) -> bool {
                *self == HPRER::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline]
            pub fn is_div4(&self) -> bool {
                *self == HPRER::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline]
            pub fn is_div8(&self) -> bool {
                *self == HPRER::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline]
            pub fn is_div16(&self) -> bool {
                *self == HPRER::DIV16
            }
            #[doc = "Checks if the value of the field is `DIV64`"]
            #[inline]
            pub fn is_div64(&self) -> bool {
                *self == HPRER::DIV64
            }
            #[doc = "Checks if the value of the field is `DIV128`"]
            #[inline]
            pub fn is_div128(&self) -> bool {
                *self == HPRER::DIV128
            }
            #[doc = "Checks if the value of the field is `DIV256`"]
            #[inline]
            pub fn is_div256(&self) -> bool {
                *self == HPRER::DIV256
            }
            #[doc = "Checks if the value of the field is `DIV512`"]
            #[inline]
            pub fn is_div512(&self) -> bool {
                *self == HPRER::DIV512
            }
        }
        #[doc = "Possible values of the field `PPRE1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PPRE1R {
            #[doc = "HCLK not divided"]
            DIV1,
            #[doc = "HCLK divided by 2"]
            DIV2,
            #[doc = "HCLK divided by 4"]
            DIV4,
            #[doc = "HCLK divided by 8"]
            DIV8,
            #[doc = "HCLK divided by 16"]
            DIV16,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PPRE1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PPRE1R::DIV1 => 0,
                    PPRE1R::DIV2 => 0x04,
                    PPRE1R::DIV4 => 0x05,
                    PPRE1R::DIV8 => 0x06,
                    PPRE1R::DIV16 => 0x07,
                    PPRE1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PPRE1R {
                match value {
                    0 => PPRE1R::DIV1,
                    4 => PPRE1R::DIV2,
                    5 => PPRE1R::DIV4,
                    6 => PPRE1R::DIV8,
                    7 => PPRE1R::DIV16,
                    i => PPRE1R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline]
            pub fn is_div1(&self) -> bool {
                *self == PPRE1R::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline]
            pub fn is_div2(&self) -> bool {
                *self == PPRE1R::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline]
            pub fn is_div4(&self) -> bool {
                *self == PPRE1R::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline]
            pub fn is_div8(&self) -> bool {
                *self == PPRE1R::DIV8
            }
            #[doc = "Checks if the value of the field is `DIV16`"]
            #[inline]
            pub fn is_div16(&self) -> bool {
                *self == PPRE1R::DIV16
            }
        }
        #[doc = "Possible values of the field `PPRE2`"]
        pub type PPRE2R = PPRE1R;
        #[doc = "Possible values of the field `ADCPRE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCPRER {
            #[doc = "PCLK2 divided by 2"]
            DIV2,
            #[doc = "PCLK2 divided by 4"]
            DIV4,
            #[doc = "PCLK2 divided by 8"]
            DIV6,
            #[doc = "PCLK2 divided by 16"]
            DIV8,
        }
        impl ADCPRER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ADCPRER::DIV2 => 0,
                    ADCPRER::DIV4 => 0x01,
                    ADCPRER::DIV6 => 0x02,
                    ADCPRER::DIV8 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ADCPRER {
                match value {
                    0 => ADCPRER::DIV2,
                    1 => ADCPRER::DIV4,
                    2 => ADCPRER::DIV6,
                    3 => ADCPRER::DIV8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline]
            pub fn is_div2(&self) -> bool {
                *self == ADCPRER::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline]
            pub fn is_div4(&self) -> bool {
                *self == ADCPRER::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV6`"]
            #[inline]
            pub fn is_div6(&self) -> bool {
                *self == ADCPRER::DIV6
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline]
            pub fn is_div8(&self) -> bool {
                *self == ADCPRER::DIV8
            }
        }
        #[doc = "Possible values of the field `PLLSRC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PLLSRCR {
            #[doc = "HSI divided by 2 selected as PLL input clock"]
            HSI_DIV2,
            #[doc = "HSE divided by PREDIV selected as PLL input clock"]
            HSE_DIV_PREDIV,
        }
        impl PLLSRCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PLLSRCR::HSI_DIV2 => false,
                    PLLSRCR::HSE_DIV_PREDIV => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PLLSRCR {
                match value {
                    false => PLLSRCR::HSI_DIV2,
                    true => PLLSRCR::HSE_DIV_PREDIV,
                }
            }
            #[doc = "Checks if the value of the field is `HSI_DIV2`"]
            #[inline]
            pub fn is_hsi_div2(&self) -> bool {
                *self == PLLSRCR::HSI_DIV2
            }
            #[doc = "Checks if the value of the field is `HSE_DIV_PREDIV`"]
            #[inline]
            pub fn is_hse_div_prediv(&self) -> bool {
                *self == PLLSRCR::HSE_DIV_PREDIV
            }
        }
        #[doc = "Possible values of the field `PLLXTPRE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PLLXTPRER {
            #[doc = "HSE clock not divided"]
            DIV1,
            #[doc = "HSE clock divided by 2"]
            DIV2,
        }
        impl PLLXTPRER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PLLXTPRER::DIV1 => false,
                    PLLXTPRER::DIV2 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PLLXTPRER {
                match value {
                    false => PLLXTPRER::DIV1,
                    true => PLLXTPRER::DIV2,
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline]
            pub fn is_div1(&self) -> bool {
                *self == PLLXTPRER::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline]
            pub fn is_div2(&self) -> bool {
                *self == PLLXTPRER::DIV2
            }
        }
        #[doc = "Possible values of the field `PLLMUL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PLLMULR {
            #[doc = "PLL input clock x2"]
            MUL2,
            #[doc = "PLL input clock x3"]
            MUL3,
            #[doc = "PLL input clock x4"]
            MUL4,
            #[doc = "PLL input clock x5"]
            MUL5,
            #[doc = "PLL input clock x6"]
            MUL6,
            #[doc = "PLL input clock x7"]
            MUL7,
            #[doc = "PLL input clock x8"]
            MUL8,
            #[doc = "PLL input clock x9"]
            MUL9,
            #[doc = "PLL input clock x10"]
            MUL10,
            #[doc = "PLL input clock x11"]
            MUL11,
            #[doc = "PLL input clock x12"]
            MUL12,
            #[doc = "PLL input clock x13"]
            MUL13,
            #[doc = "PLL input clock x14"]
            MUL14,
            #[doc = "PLL input clock x15"]
            MUL15,
            #[doc = "PLL input clock x16"]
            MUL16,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PLLMULR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PLLMULR::MUL2 => 0,
                    PLLMULR::MUL3 => 0x01,
                    PLLMULR::MUL4 => 0x02,
                    PLLMULR::MUL5 => 0x03,
                    PLLMULR::MUL6 => 0x04,
                    PLLMULR::MUL7 => 0x05,
                    PLLMULR::MUL8 => 0x06,
                    PLLMULR::MUL9 => 0x07,
                    PLLMULR::MUL10 => 0x08,
                    PLLMULR::MUL11 => 0x09,
                    PLLMULR::MUL12 => 0x0a,
                    PLLMULR::MUL13 => 0x0b,
                    PLLMULR::MUL14 => 0x0c,
                    PLLMULR::MUL15 => 0x0d,
                    PLLMULR::MUL16 => 0x0f,
                    PLLMULR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PLLMULR {
                match value {
                    0 => PLLMULR::MUL2,
                    1 => PLLMULR::MUL3,
                    2 => PLLMULR::MUL4,
                    3 => PLLMULR::MUL5,
                    4 => PLLMULR::MUL6,
                    5 => PLLMULR::MUL7,
                    6 => PLLMULR::MUL8,
                    7 => PLLMULR::MUL9,
                    8 => PLLMULR::MUL10,
                    9 => PLLMULR::MUL11,
                    10 => PLLMULR::MUL12,
                    11 => PLLMULR::MUL13,
                    12 => PLLMULR::MUL14,
                    13 => PLLMULR::MUL15,
                    15 => PLLMULR::MUL16,
                    i => PLLMULR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `MUL2`"]
            #[inline]
            pub fn is_mul2(&self) -> bool {
                *self == PLLMULR::MUL2
            }
            #[doc = "Checks if the value of the field is `MUL3`"]
            #[inline]
            pub fn is_mul3(&self) -> bool {
                *self == PLLMULR::MUL3
            }
            #[doc = "Checks if the value of the field is `MUL4`"]
            #[inline]
            pub fn is_mul4(&self) -> bool {
                *self == PLLMULR::MUL4
            }
            #[doc = "Checks if the value of the field is `MUL5`"]
            #[inline]
            pub fn is_mul5(&self) -> bool {
                *self == PLLMULR::MUL5
            }
            #[doc = "Checks if the value of the field is `MUL6`"]
            #[inline]
            pub fn is_mul6(&self) -> bool {
                *self == PLLMULR::MUL6
            }
            #[doc = "Checks if the value of the field is `MUL7`"]
            #[inline]
            pub fn is_mul7(&self) -> bool {
                *self == PLLMULR::MUL7
            }
            #[doc = "Checks if the value of the field is `MUL8`"]
            #[inline]
            pub fn is_mul8(&self) -> bool {
                *self == PLLMULR::MUL8
            }
            #[doc = "Checks if the value of the field is `MUL9`"]
            #[inline]
            pub fn is_mul9(&self) -> bool {
                *self == PLLMULR::MUL9
            }
            #[doc = "Checks if the value of the field is `MUL10`"]
            #[inline]
            pub fn is_mul10(&self) -> bool {
                *self == PLLMULR::MUL10
            }
            #[doc = "Checks if the value of the field is `MUL11`"]
            #[inline]
            pub fn is_mul11(&self) -> bool {
                *self == PLLMULR::MUL11
            }
            #[doc = "Checks if the value of the field is `MUL12`"]
            #[inline]
            pub fn is_mul12(&self) -> bool {
                *self == PLLMULR::MUL12
            }
            #[doc = "Checks if the value of the field is `MUL13`"]
            #[inline]
            pub fn is_mul13(&self) -> bool {
                *self == PLLMULR::MUL13
            }
            #[doc = "Checks if the value of the field is `MUL14`"]
            #[inline]
            pub fn is_mul14(&self) -> bool {
                *self == PLLMULR::MUL14
            }
            #[doc = "Checks if the value of the field is `MUL15`"]
            #[inline]
            pub fn is_mul15(&self) -> bool {
                *self == PLLMULR::MUL15
            }
            #[doc = "Checks if the value of the field is `MUL16`"]
            #[inline]
            pub fn is_mul16(&self) -> bool {
                *self == PLLMULR::MUL16
            }
        }
        #[doc = "Possible values of the field `MCO`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MCOR {
            #[doc = "MCO output disabled, no clock on MCO"]
            NOMCO,
            #[doc = "System clock selected"]
            SYSCLK,
            #[doc = "HSI oscillator clock selected"]
            HSI,
            #[doc = "HSE oscillator clock selected"]
            HSE,
            #[doc = "PLL clock selected (divided by 1 or 2, depending en PLLNODIV)"]
            PLL,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl MCOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MCOR::NOMCO => 0,
                    MCOR::SYSCLK => 0x04,
                    MCOR::HSI => 0x05,
                    MCOR::HSE => 0x06,
                    MCOR::PLL => 0x07,
                    MCOR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MCOR {
                match value {
                    0 => MCOR::NOMCO,
                    4 => MCOR::SYSCLK,
                    5 => MCOR::HSI,
                    6 => MCOR::HSE,
                    7 => MCOR::PLL,
                    i => MCOR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NOMCO`"]
            #[inline]
            pub fn is_no_mco(&self) -> bool {
                *self == MCOR::NOMCO
            }
            #[doc = "Checks if the value of the field is `SYSCLK`"]
            #[inline]
            pub fn is_sysclk(&self) -> bool {
                *self == MCOR::SYSCLK
            }
            #[doc = "Checks if the value of the field is `HSI`"]
            #[inline]
            pub fn is_hsi(&self) -> bool {
                *self == MCOR::HSI
            }
            #[doc = "Checks if the value of the field is `HSE`"]
            #[inline]
            pub fn is_hse(&self) -> bool {
                *self == MCOR::HSE
            }
            #[doc = "Checks if the value of the field is `PLL`"]
            #[inline]
            pub fn is_pll(&self) -> bool {
                *self == MCOR::PLL
            }
        }
        #[doc = "Values that can be written to the field `SW`"]
        pub enum SWW {
            #[doc = "HSI selected as system clock"]
            HSI,
            #[doc = "HSE selected as system clock"]
            HSE,
            #[doc = "PLL selected as system clock"]
            PLL,
        }
        impl SWW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SWW::HSI => 0,
                    SWW::HSE => 1,
                    SWW::PLL => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SWW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "HSI selected as system clock"]
            #[inline]
            pub fn hsi(self) -> &'a mut W {
                self.variant(SWW::HSI)
            }
            #[doc = "HSE selected as system clock"]
            #[inline]
            pub fn hse(self) -> &'a mut W {
                self.variant(SWW::HSE)
            }
            #[doc = "PLL selected as system clock"]
            #[inline]
            pub fn pll(self) -> &'a mut W {
                self.variant(SWW::PLL)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HPRE`"]
        pub enum HPREW {
            #[doc = "SYSCLK not divided"]
            DIV1,
            #[doc = "SYSCLK divided by 2"]
            DIV2,
            #[doc = "SYSCLK divided by 4"]
            DIV4,
            #[doc = "SYSCLK divided by 8"]
            DIV8,
            #[doc = "SYSCLK divided by 16"]
            DIV16,
            #[doc = "SYSCLK divided by 64"]
            DIV64,
            #[doc = "SYSCLK divided by 128"]
            DIV128,
            #[doc = "SYSCLK divided by 256"]
            DIV256,
            #[doc = "SYSCLK divided by 512"]
            DIV512,
        }
        impl HPREW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    HPREW::DIV1 => 0,
                    HPREW::DIV2 => 8,
                    HPREW::DIV4 => 9,
                    HPREW::DIV8 => 10,
                    HPREW::DIV16 => 11,
                    HPREW::DIV64 => 12,
                    HPREW::DIV128 => 13,
                    HPREW::DIV256 => 14,
                    HPREW::DIV512 => 15,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HPREW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HPREW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HPREW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "SYSCLK not divided"]
            #[inline]
            pub fn div1(self) -> &'a mut W {
                self.variant(HPREW::DIV1)
            }
            #[doc = "SYSCLK divided by 2"]
            #[inline]
            pub fn div2(self) -> &'a mut W {
                self.variant(HPREW::DIV2)
            }
            #[doc = "SYSCLK divided by 4"]
            #[inline]
            pub fn div4(self) -> &'a mut W {
                self.variant(HPREW::DIV4)
            }
            #[doc = "SYSCLK divided by 8"]
            #[inline]
            pub fn div8(self) -> &'a mut W {
                self.variant(HPREW::DIV8)
            }
            #[doc = "SYSCLK divided by 16"]
            #[inline]
            pub fn div16(self) -> &'a mut W {
                self.variant(HPREW::DIV16)
            }
            #[doc = "SYSCLK divided by 64"]
            #[inline]
            pub fn div64(self) -> &'a mut W {
                self.variant(HPREW::DIV64)
            }
            #[doc = "SYSCLK divided by 128"]
            #[inline]
            pub fn div128(self) -> &'a mut W {
                self.variant(HPREW::DIV128)
            }
            #[doc = "SYSCLK divided by 256"]
            #[inline]
            pub fn div256(self) -> &'a mut W {
                self.variant(HPREW::DIV256)
            }
            #[doc = "SYSCLK divided by 512"]
            #[inline]
            pub fn div512(self) -> &'a mut W {
                self.variant(HPREW::DIV512)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PPRE1`"]
        pub enum PPRE1W {
            #[doc = "HCLK not divided"]
            DIV1,
            #[doc = "HCLK divided by 2"]
            DIV2,
            #[doc = "HCLK divided by 4"]
            DIV4,
            #[doc = "HCLK divided by 8"]
            DIV8,
            #[doc = "HCLK divided by 16"]
            DIV16,
        }
        impl PPRE1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PPRE1W::DIV1 => 0,
                    PPRE1W::DIV2 => 4,
                    PPRE1W::DIV4 => 5,
                    PPRE1W::DIV8 => 6,
                    PPRE1W::DIV16 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PPRE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PPRE1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PPRE1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "HCLK not divided"]
            #[inline]
            pub fn div1(self) -> &'a mut W {
                self.variant(PPRE1W::DIV1)
            }
            #[doc = "HCLK divided by 2"]
            #[inline]
            pub fn div2(self) -> &'a mut W {
                self.variant(PPRE1W::DIV2)
            }
            #[doc = "HCLK divided by 4"]
            #[inline]
            pub fn div4(self) -> &'a mut W {
                self.variant(PPRE1W::DIV4)
            }
            #[doc = "HCLK divided by 8"]
            #[inline]
            pub fn div8(self) -> &'a mut W {
                self.variant(PPRE1W::DIV8)
            }
            #[doc = "HCLK divided by 16"]
            #[inline]
            pub fn div16(self) -> &'a mut W {
                self.variant(PPRE1W::DIV16)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PPRE2`"]
        pub type PPRE2W = PPRE1W;
        #[doc = r" Proxy"]
        pub struct _PPRE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PPRE2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PPRE2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "HCLK not divided"]
            #[inline]
            pub fn div1(self) -> &'a mut W {
                self.variant(PPRE1W::DIV1)
            }
            #[doc = "HCLK divided by 2"]
            #[inline]
            pub fn div2(self) -> &'a mut W {
                self.variant(PPRE1W::DIV2)
            }
            #[doc = "HCLK divided by 4"]
            #[inline]
            pub fn div4(self) -> &'a mut W {
                self.variant(PPRE1W::DIV4)
            }
            #[doc = "HCLK divided by 8"]
            #[inline]
            pub fn div8(self) -> &'a mut W {
                self.variant(PPRE1W::DIV8)
            }
            #[doc = "HCLK divided by 16"]
            #[inline]
            pub fn div16(self) -> &'a mut W {
                self.variant(PPRE1W::DIV16)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADCPRE`"]
        pub enum ADCPREW {
            #[doc = "PCLK2 divided by 2"]
            DIV2,
            #[doc = "PCLK2 divided by 4"]
            DIV4,
            #[doc = "PCLK2 divided by 8"]
            DIV6,
            #[doc = "PCLK2 divided by 16"]
            DIV8,
        }
        impl ADCPREW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ADCPREW::DIV2 => 0,
                    ADCPREW::DIV4 => 1,
                    ADCPREW::DIV6 => 2,
                    ADCPREW::DIV8 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCPREW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCPREW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADCPREW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "PCLK2 divided by 2"]
            #[inline]
            pub fn div2(self) -> &'a mut W {
                self.variant(ADCPREW::DIV2)
            }
            #[doc = "PCLK2 divided by 4"]
            #[inline]
            pub fn div4(self) -> &'a mut W {
                self.variant(ADCPREW::DIV4)
            }
            #[doc = "PCLK2 divided by 8"]
            #[inline]
            pub fn div6(self) -> &'a mut W {
                self.variant(ADCPREW::DIV6)
            }
            #[doc = "PCLK2 divided by 16"]
            #[inline]
            pub fn div8(self) -> &'a mut W {
                self.variant(ADCPREW::DIV8)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PLLSRC`"]
        pub enum PLLSRCW {
            #[doc = "HSI divided by 2 selected as PLL input clock"]
            HSI_DIV2,
            #[doc = "HSE divided by PREDIV selected as PLL input clock"]
            HSE_DIV_PREDIV,
        }
        impl PLLSRCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PLLSRCW::HSI_DIV2 => false,
                    PLLSRCW::HSE_DIV_PREDIV => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PLLSRCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PLLSRCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PLLSRCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "HSI divided by 2 selected as PLL input clock"]
            #[inline]
            pub fn hsi_div2(self) -> &'a mut W {
                self.variant(PLLSRCW::HSI_DIV2)
            }
            #[doc = "HSE divided by PREDIV selected as PLL input clock"]
            #[inline]
            pub fn hse_div_prediv(self) -> &'a mut W {
                self.variant(PLLSRCW::HSE_DIV_PREDIV)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PLLXTPRE`"]
        pub enum PLLXTPREW {
            #[doc = "HSE clock not divided"]
            DIV1,
            #[doc = "HSE clock divided by 2"]
            DIV2,
        }
        impl PLLXTPREW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PLLXTPREW::DIV1 => false,
                    PLLXTPREW::DIV2 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PLLXTPREW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PLLXTPREW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PLLXTPREW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "HSE clock not divided"]
            #[inline]
            pub fn div1(self) -> &'a mut W {
                self.variant(PLLXTPREW::DIV1)
            }
            #[doc = "HSE clock divided by 2"]
            #[inline]
            pub fn div2(self) -> &'a mut W {
                self.variant(PLLXTPREW::DIV2)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PLLMUL`"]
        pub enum PLLMULW {
            #[doc = "PLL input clock x2"]
            MUL2,
            #[doc = "PLL input clock x3"]
            MUL3,
            #[doc = "PLL input clock x4"]
            MUL4,
            #[doc = "PLL input clock x5"]
            MUL5,
            #[doc = "PLL input clock x6"]
            MUL6,
            #[doc = "PLL input clock x7"]
            MUL7,
            #[doc = "PLL input clock x8"]
            MUL8,
            #[doc = "PLL input clock x9"]
            MUL9,
            #[doc = "PLL input clock x10"]
            MUL10,
            #[doc = "PLL input clock x11"]
            MUL11,
            #[doc = "PLL input clock x12"]
            MUL12,
            #[doc = "PLL input clock x13"]
            MUL13,
            #[doc = "PLL input clock x14"]
            MUL14,
            #[doc = "PLL input clock x15"]
            MUL15,
            #[doc = "PLL input clock x16"]
            MUL16,
        }
        impl PLLMULW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PLLMULW::MUL2 => 0,
                    PLLMULW::MUL3 => 1,
                    PLLMULW::MUL4 => 2,
                    PLLMULW::MUL5 => 3,
                    PLLMULW::MUL6 => 4,
                    PLLMULW::MUL7 => 5,
                    PLLMULW::MUL8 => 6,
                    PLLMULW::MUL9 => 7,
                    PLLMULW::MUL10 => 8,
                    PLLMULW::MUL11 => 9,
                    PLLMULW::MUL12 => 10,
                    PLLMULW::MUL13 => 11,
                    PLLMULW::MUL14 => 12,
                    PLLMULW::MUL15 => 13,
                    PLLMULW::MUL16 => 15,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PLLMULW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PLLMULW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PLLMULW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "PLL input clock x2"]
            #[inline]
            pub fn mul2(self) -> &'a mut W {
                self.variant(PLLMULW::MUL2)
            }
            #[doc = "PLL input clock x3"]
            #[inline]
            pub fn mul3(self) -> &'a mut W {
                self.variant(PLLMULW::MUL3)
            }
            #[doc = "PLL input clock x4"]
            #[inline]
            pub fn mul4(self) -> &'a mut W {
                self.variant(PLLMULW::MUL4)
            }
            #[doc = "PLL input clock x5"]
            #[inline]
            pub fn mul5(self) -> &'a mut W {
                self.variant(PLLMULW::MUL5)
            }
            #[doc = "PLL input clock x6"]
            #[inline]
            pub fn mul6(self) -> &'a mut W {
                self.variant(PLLMULW::MUL6)
            }
            #[doc = "PLL input clock x7"]
            #[inline]
            pub fn mul7(self) -> &'a mut W {
                self.variant(PLLMULW::MUL7)
            }
            #[doc = "PLL input clock x8"]
            #[inline]
            pub fn mul8(self) -> &'a mut W {
                self.variant(PLLMULW::MUL8)
            }
            #[doc = "PLL input clock x9"]
            #[inline]
            pub fn mul9(self) -> &'a mut W {
                self.variant(PLLMULW::MUL9)
            }
            #[doc = "PLL input clock x10"]
            #[inline]
            pub fn mul10(self) -> &'a mut W {
                self.variant(PLLMULW::MUL10)
            }
            #[doc = "PLL input clock x11"]
            #[inline]
            pub fn mul11(self) -> &'a mut W {
                self.variant(PLLMULW::MUL11)
            }
            #[doc = "PLL input clock x12"]
            #[inline]
            pub fn mul12(self) -> &'a mut W {
                self.variant(PLLMULW::MUL12)
            }
            #[doc = "PLL input clock x13"]
            #[inline]
            pub fn mul13(self) -> &'a mut W {
                self.variant(PLLMULW::MUL13)
            }
            #[doc = "PLL input clock x14"]
            #[inline]
            pub fn mul14(self) -> &'a mut W {
                self.variant(PLLMULW::MUL14)
            }
            #[doc = "PLL input clock x15"]
            #[inline]
            pub fn mul15(self) -> &'a mut W {
                self.variant(PLLMULW::MUL15)
            }
            #[doc = "PLL input clock x16"]
            #[inline]
            pub fn mul16(self) -> &'a mut W {
                self.variant(PLLMULW::MUL16)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MCO`"]
        pub enum MCOW {
            #[doc = "MCO output disabled, no clock on MCO"]
            NOMCO,
            #[doc = "System clock selected"]
            SYSCLK,
            #[doc = "HSI oscillator clock selected"]
            HSI,
            #[doc = "HSE oscillator clock selected"]
            HSE,
            #[doc = "PLL clock selected (divided by 1 or 2, depending en PLLNODIV)"]
            PLL,
        }
        impl MCOW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MCOW::NOMCO => 0,
                    MCOW::SYSCLK => 4,
                    MCOW::HSI => 5,
                    MCOW::HSE => 6,
                    MCOW::PLL => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MCOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MCOW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MCOW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "MCO output disabled, no clock on MCO"]
            #[inline]
            pub fn no_mco(self) -> &'a mut W {
                self.variant(MCOW::NOMCO)
            }
            #[doc = "System clock selected"]
            #[inline]
            pub fn sysclk(self) -> &'a mut W {
                self.variant(MCOW::SYSCLK)
            }
            #[doc = "HSI oscillator clock selected"]
            #[inline]
            pub fn hsi(self) -> &'a mut W {
                self.variant(MCOW::HSI)
            }
            #[doc = "HSE oscillator clock selected"]
            #[inline]
            pub fn hse(self) -> &'a mut W {
                self.variant(MCOW::HSE)
            }
            #[doc = "PLL clock selected (divided by 1 or 2, depending en PLLNODIV)"]
            #[inline]
            pub fn pll(self) -> &'a mut W {
                self.variant(MCOW::PLL)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - System clock Switch"]
            #[inline]
            pub fn sw(&self) -> SWR {
                SWR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 2:3 - System Clock Switch Status"]
            #[inline]
            pub fn sws(&self) -> SWSR {
                SWSR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 4:7 - AHB prescaler"]
            #[inline]
            pub fn hpre(&self) -> HPRER {
                HPRER::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:10 - APB Low speed prescaler (APB1)"]
            #[inline]
            pub fn ppre1(&self) -> PPRE1R {
                PPRE1R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 11:13 - APB High speed prescaler (APB2)"]
            #[inline]
            pub fn ppre2(&self) -> PPRE2R {
                PPRE2R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 14:15 - ADC prescaler"]
            #[inline]
            pub fn adcpre(&self) -> ADCPRER {
                ADCPRER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 16 - PLL entry clock source"]
            #[inline]
            pub fn pllsrc(&self) -> PLLSRCR {
                PLLSRCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - HSE divider for PLL entry"]
            #[inline]
            pub fn pllxtpre(&self) -> PLLXTPRER {
                PLLXTPRER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 18:21 - PLL Multiplication Factor"]
            #[inline]
            pub fn pllmul(&self) -> PLLMULR {
                PLLMULR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 24:26 - Microcontroller clock output"]
            #[inline]
            pub fn mco(&self) -> MCOR {
                MCOR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - System clock Switch"]
            #[inline]
            pub fn sw(&mut self) -> _SWW {
                _SWW { w: self }
            }
            #[doc = "Bits 4:7 - AHB prescaler"]
            #[inline]
            pub fn hpre(&mut self) -> _HPREW {
                _HPREW { w: self }
            }
            #[doc = "Bits 8:10 - APB Low speed prescaler (APB1)"]
            #[inline]
            pub fn ppre1(&mut self) -> _PPRE1W {
                _PPRE1W { w: self }
            }
            #[doc = "Bits 11:13 - APB High speed prescaler (APB2)"]
            #[inline]
            pub fn ppre2(&mut self) -> _PPRE2W {
                _PPRE2W { w: self }
            }
            #[doc = "Bits 14:15 - ADC prescaler"]
            #[inline]
            pub fn adcpre(&mut self) -> _ADCPREW {
                _ADCPREW { w: self }
            }
            #[doc = "Bit 16 - PLL entry clock source"]
            #[inline]
            pub fn pllsrc(&mut self) -> _PLLSRCW {
                _PLLSRCW { w: self }
            }
            #[doc = "Bit 17 - HSE divider for PLL entry"]
            #[inline]
            pub fn pllxtpre(&mut self) -> _PLLXTPREW {
                _PLLXTPREW { w: self }
            }
            #[doc = "Bits 18:21 - PLL Multiplication Factor"]
            #[inline]
            pub fn pllmul(&mut self) -> _PLLMULW {
                _PLLMULW { w: self }
            }
            #[doc = "Bits 24:26 - Microcontroller clock output"]
            #[inline]
            pub fn mco(&mut self) -> _MCOW {
                _MCOW { w: self }
            }
        }
    }
    #[doc = "Clock interrupt register (RCC_CIR)"]
    pub struct CIR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock interrupt register (RCC_CIR)"]
    pub mod cir {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CIR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `LSIRDYF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSIRDYFR {
            #[doc = "No clock ready interrupt"]
            NOTINTERRUPTED,
            #[doc = "Clock ready interrupt"]
            INTERRUPTED,
        }
        impl LSIRDYFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LSIRDYFR::NOTINTERRUPTED => false,
                    LSIRDYFR::INTERRUPTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LSIRDYFR {
                match value {
                    false => LSIRDYFR::NOTINTERRUPTED,
                    true => LSIRDYFR::INTERRUPTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTINTERRUPTED`"]
            #[inline]
            pub fn is_not_interrupted(&self) -> bool {
                *self == LSIRDYFR::NOTINTERRUPTED
            }
            #[doc = "Checks if the value of the field is `INTERRUPTED`"]
            #[inline]
            pub fn is_interrupted(&self) -> bool {
                *self == LSIRDYFR::INTERRUPTED
            }
        }
        #[doc = "Possible values of the field `LSERDYF`"]
        pub type LSERDYFR = LSIRDYFR;
        #[doc = "Possible values of the field `HSIRDYF`"]
        pub type HSIRDYFR = LSIRDYFR;
        #[doc = "Possible values of the field `HSERDYF`"]
        pub type HSERDYFR = LSIRDYFR;
        #[doc = "Possible values of the field `PLLRDYF`"]
        pub type PLLRDYFR = LSIRDYFR;
        #[doc = "Possible values of the field `CSSF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CSSFR {
            #[doc = "No clock security interrupt caused by HSE clock failure"]
            NOTINTERRUPTED,
            #[doc = "Clock security interrupt caused by HSE clock failure"]
            INTERRUPTED,
        }
        impl CSSFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CSSFR::NOTINTERRUPTED => false,
                    CSSFR::INTERRUPTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CSSFR {
                match value {
                    false => CSSFR::NOTINTERRUPTED,
                    true => CSSFR::INTERRUPTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTINTERRUPTED`"]
            #[inline]
            pub fn is_not_interrupted(&self) -> bool {
                *self == CSSFR::NOTINTERRUPTED
            }
            #[doc = "Checks if the value of the field is `INTERRUPTED`"]
            #[inline]
            pub fn is_interrupted(&self) -> bool {
                *self == CSSFR::INTERRUPTED
            }
        }
        #[doc = "Possible values of the field `LSIRDYIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSIRDYIER {
            #[doc = "Interrupt disabled"]
            DISABLED,
            #[doc = "Interrupt enabled"]
            ENABLED,
        }
        impl LSIRDYIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LSIRDYIER::DISABLED => false,
                    LSIRDYIER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LSIRDYIER {
                match value {
                    false => LSIRDYIER::DISABLED,
                    true => LSIRDYIER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == LSIRDYIER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == LSIRDYIER::ENABLED
            }
        }
        #[doc = "Possible values of the field `LSERDYIE`"]
        pub type LSERDYIER = LSIRDYIER;
        #[doc = "Possible values of the field `HSIRDYIE`"]
        pub type HSIRDYIER = LSIRDYIER;
        #[doc = "Possible values of the field `HSERDYIE`"]
        pub type HSERDYIER = LSIRDYIER;
        #[doc = "Possible values of the field `PLLRDYIE`"]
        pub type PLLRDYIER = LSIRDYIER;
        #[doc = "Values that can be written to the field `LSIRDYIE`"]
        pub enum LSIRDYIEW {
            #[doc = "Interrupt disabled"]
            DISABLED,
            #[doc = "Interrupt enabled"]
            ENABLED,
        }
        impl LSIRDYIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LSIRDYIEW::DISABLED => false,
                    LSIRDYIEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LSIRDYIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LSIRDYIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LSIRDYIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LSIRDYIEW::DISABLED)
            }
            #[doc = "Interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LSIRDYIEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LSERDYIE`"]
        pub type LSERDYIEW = LSIRDYIEW;
        #[doc = r" Proxy"]
        pub struct _LSERDYIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LSERDYIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LSERDYIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LSIRDYIEW::DISABLED)
            }
            #[doc = "Interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LSIRDYIEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HSIRDYIE`"]
        pub type HSIRDYIEW = LSIRDYIEW;
        #[doc = r" Proxy"]
        pub struct _HSIRDYIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HSIRDYIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HSIRDYIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LSIRDYIEW::DISABLED)
            }
            #[doc = "Interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LSIRDYIEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HSERDYIE`"]
        pub type HSERDYIEW = LSIRDYIEW;
        #[doc = r" Proxy"]
        pub struct _HSERDYIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HSERDYIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HSERDYIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LSIRDYIEW::DISABLED)
            }
            #[doc = "Interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LSIRDYIEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PLLRDYIE`"]
        pub type PLLRDYIEW = LSIRDYIEW;
        #[doc = r" Proxy"]
        pub struct _PLLRDYIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PLLRDYIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PLLRDYIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LSIRDYIEW::DISABLED)
            }
            #[doc = "Interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LSIRDYIEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LSIRDYC`"]
        pub enum LSIRDYCW {
            #[doc = "Clear interrupt flag"]
            CLEAR,
        }
        impl LSIRDYCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LSIRDYCW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LSIRDYCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LSIRDYCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LSIRDYCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear interrupt flag"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(LSIRDYCW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LSERDYC`"]
        pub type LSERDYCW = LSIRDYCW;
        #[doc = r" Proxy"]
        pub struct _LSERDYCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LSERDYCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LSERDYCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear interrupt flag"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(LSIRDYCW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HSIRDYC`"]
        pub type HSIRDYCW = LSIRDYCW;
        #[doc = r" Proxy"]
        pub struct _HSIRDYCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HSIRDYCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HSIRDYCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear interrupt flag"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(LSIRDYCW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HSERDYC`"]
        pub type HSERDYCW = LSIRDYCW;
        #[doc = r" Proxy"]
        pub struct _HSERDYCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HSERDYCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HSERDYCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear interrupt flag"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(LSIRDYCW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PLLRDYC`"]
        pub type PLLRDYCW = LSIRDYCW;
        #[doc = r" Proxy"]
        pub struct _PLLRDYCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PLLRDYCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PLLRDYCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear interrupt flag"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(LSIRDYCW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CSSC`"]
        pub enum CSSCW {
            #[doc = "Clear CSSF flag"]
            CLEAR,
        }
        impl CSSCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CSSCW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CSSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CSSCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CSSCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear CSSF flag"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CSSCW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - LSI Ready Interrupt flag"]
            #[inline]
            pub fn lsirdyf(&self) -> LSIRDYFR {
                LSIRDYFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - LSE Ready Interrupt flag"]
            #[inline]
            pub fn lserdyf(&self) -> LSERDYFR {
                LSERDYFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - HSI Ready Interrupt flag"]
            #[inline]
            pub fn hsirdyf(&self) -> HSIRDYFR {
                HSIRDYFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - HSE Ready Interrupt flag"]
            #[inline]
            pub fn hserdyf(&self) -> HSERDYFR {
                HSERDYFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - PLL Ready Interrupt flag"]
            #[inline]
            pub fn pllrdyf(&self) -> PLLRDYFR {
                PLLRDYFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Clock Security System Interrupt flag"]
            #[inline]
            pub fn cssf(&self) -> CSSFR {
                CSSFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - LSI Ready Interrupt Enable"]
            #[inline]
            pub fn lsirdyie(&self) -> LSIRDYIER {
                LSIRDYIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - LSE Ready Interrupt Enable"]
            #[inline]
            pub fn lserdyie(&self) -> LSERDYIER {
                LSERDYIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - HSI Ready Interrupt Enable"]
            #[inline]
            pub fn hsirdyie(&self) -> HSIRDYIER {
                HSIRDYIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - HSE Ready Interrupt Enable"]
            #[inline]
            pub fn hserdyie(&self) -> HSERDYIER {
                HSERDYIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - PLL Ready Interrupt Enable"]
            #[inline]
            pub fn pllrdyie(&self) -> PLLRDYIER {
                PLLRDYIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 8 - LSI Ready Interrupt Enable"]
            #[inline]
            pub fn lsirdyie(&mut self) -> _LSIRDYIEW {
                _LSIRDYIEW { w: self }
            }
            #[doc = "Bit 9 - LSE Ready Interrupt Enable"]
            #[inline]
            pub fn lserdyie(&mut self) -> _LSERDYIEW {
                _LSERDYIEW { w: self }
            }
            #[doc = "Bit 10 - HSI Ready Interrupt Enable"]
            #[inline]
            pub fn hsirdyie(&mut self) -> _HSIRDYIEW {
                _HSIRDYIEW { w: self }
            }
            #[doc = "Bit 11 - HSE Ready Interrupt Enable"]
            #[inline]
            pub fn hserdyie(&mut self) -> _HSERDYIEW {
                _HSERDYIEW { w: self }
            }
            #[doc = "Bit 12 - PLL Ready Interrupt Enable"]
            #[inline]
            pub fn pllrdyie(&mut self) -> _PLLRDYIEW {
                _PLLRDYIEW { w: self }
            }
            #[doc = "Bit 16 - LSI Ready Interrupt Clear"]
            #[inline]
            pub fn lsirdyc(&mut self) -> _LSIRDYCW {
                _LSIRDYCW { w: self }
            }
            #[doc = "Bit 17 - LSE Ready Interrupt Clear"]
            #[inline]
            pub fn lserdyc(&mut self) -> _LSERDYCW {
                _LSERDYCW { w: self }
            }
            #[doc = "Bit 18 - HSI Ready Interrupt Clear"]
            #[inline]
            pub fn hsirdyc(&mut self) -> _HSIRDYCW {
                _HSIRDYCW { w: self }
            }
            #[doc = "Bit 19 - HSE Ready Interrupt Clear"]
            #[inline]
            pub fn hserdyc(&mut self) -> _HSERDYCW {
                _HSERDYCW { w: self }
            }
            #[doc = "Bit 20 - PLL Ready Interrupt Clear"]
            #[inline]
            pub fn pllrdyc(&mut self) -> _PLLRDYCW {
                _PLLRDYCW { w: self }
            }
            #[doc = "Bit 23 - Clock security system interrupt clear"]
            #[inline]
            pub fn cssc(&mut self) -> _CSSCW {
                _CSSCW { w: self }
            }
        }
    }
    #[doc = "APB2 peripheral reset register (RCC_APB2RSTR)"]
    pub struct APB2RSTR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "APB2 peripheral reset register (RCC_APB2RSTR)"]
    pub mod apb2rstr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::APB2RSTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `AFIORST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AFIORSTR {
            #[doc = "Reset the selected module"]
            RESET,
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl AFIORSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    AFIORSTR::RESET => true,
                    AFIORSTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> AFIORSTR {
                match value {
                    true => AFIORSTR::RESET,
                    i => AFIORSTR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline]
            pub fn is_reset(&self) -> bool {
                *self == AFIORSTR::RESET
            }
        }
        #[doc = "Possible values of the field `IOPARST`"]
        pub type IOPARSTR = AFIORSTR;
        #[doc = "Possible values of the field `IOPBRST`"]
        pub type IOPBRSTR = AFIORSTR;
        #[doc = "Possible values of the field `IOPCRST`"]
        pub type IOPCRSTR = AFIORSTR;
        #[doc = "Possible values of the field `IOPDRST`"]
        pub type IOPDRSTR = AFIORSTR;
        #[doc = "Possible values of the field `IOPERST`"]
        pub type IOPERSTR = AFIORSTR;
        #[doc = "Possible values of the field `IOPFRST`"]
        pub type IOPFRSTR = AFIORSTR;
        #[doc = "Possible values of the field `IOPGRST`"]
        pub type IOPGRSTR = AFIORSTR;
        #[doc = "Possible values of the field `ADC1RST`"]
        pub type ADC1RSTR = AFIORSTR;
        #[doc = "Possible values of the field `TIM1RST`"]
        pub type TIM1RSTR = AFIORSTR;
        #[doc = "Possible values of the field `SPI1RST`"]
        pub type SPI1RSTR = AFIORSTR;
        #[doc = "Possible values of the field `USART1RST`"]
        pub type USART1RSTR = AFIORSTR;
        #[doc = "Possible values of the field `TIM15RST`"]
        pub type TIM15RSTR = AFIORSTR;
        #[doc = "Possible values of the field `TIM16RST`"]
        pub type TIM16RSTR = AFIORSTR;
        #[doc = "Possible values of the field `TIM17RST`"]
        pub type TIM17RSTR = AFIORSTR;
        #[doc = "Values that can be written to the field `AFIORST`"]
        pub enum AFIORSTW {
            #[doc = "Reset the selected module"]
            RESET,
        }
        impl AFIORSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    AFIORSTW::RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _AFIORSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AFIORSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: AFIORSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPARST`"]
        pub type IOPARSTW = AFIORSTW;
        #[doc = r" Proxy"]
        pub struct _IOPARSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOPARSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOPARSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPBRST`"]
        pub type IOPBRSTW = AFIORSTW;
        #[doc = r" Proxy"]
        pub struct _IOPBRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOPBRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOPBRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPCRST`"]
        pub type IOPCRSTW = AFIORSTW;
        #[doc = r" Proxy"]
        pub struct _IOPCRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOPCRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOPCRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPDRST`"]
        pub type IOPDRSTW = AFIORSTW;
        #[doc = r" Proxy"]
        pub struct _IOPDRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOPDRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOPDRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPERST`"]
        pub type IOPERSTW = AFIORSTW;
        #[doc = r" Proxy"]
        pub struct _IOPERSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOPERSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOPERSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPFRST`"]
        pub type IOPFRSTW = AFIORSTW;
        #[doc = r" Proxy"]
        pub struct _IOPFRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOPFRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOPFRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPGRST`"]
        pub type IOPGRSTW = AFIORSTW;
        #[doc = r" Proxy"]
        pub struct _IOPGRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOPGRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOPGRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC1RST`"]
        pub type ADC1RSTW = AFIORSTW;
        #[doc = r" Proxy"]
        pub struct _ADC1RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC1RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC1RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM1RST`"]
        pub type TIM1RSTW = AFIORSTW;
        #[doc = r" Proxy"]
        pub struct _TIM1RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM1RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM1RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI1RST`"]
        pub type SPI1RSTW = AFIORSTW;
        #[doc = r" Proxy"]
        pub struct _SPI1RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPI1RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USART1RST`"]
        pub type USART1RSTW = AFIORSTW;
        #[doc = r" Proxy"]
        pub struct _USART1RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USART1RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: USART1RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM15RST`"]
        pub type TIM15RSTW = AFIORSTW;
        #[doc = r" Proxy"]
        pub struct _TIM15RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM15RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM15RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM16RST`"]
        pub type TIM16RSTW = AFIORSTW;
        #[doc = r" Proxy"]
        pub struct _TIM16RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM16RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM16RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM17RST`"]
        pub type TIM17RSTW = AFIORSTW;
        #[doc = r" Proxy"]
        pub struct _TIM17RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM17RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM17RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Alternate function I/O reset"]
            #[inline]
            pub fn afiorst(&self) -> AFIORSTR {
                AFIORSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - IO port A reset"]
            #[inline]
            pub fn ioparst(&self) -> IOPARSTR {
                IOPARSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - IO port B reset"]
            #[inline]
            pub fn iopbrst(&self) -> IOPBRSTR {
                IOPBRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - IO port C reset"]
            #[inline]
            pub fn iopcrst(&self) -> IOPCRSTR {
                IOPCRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - IO port D reset"]
            #[inline]
            pub fn iopdrst(&self) -> IOPDRSTR {
                IOPDRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - IO port E reset"]
            #[inline]
            pub fn ioperst(&self) -> IOPERSTR {
                IOPERSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - IO port F reset"]
            #[inline]
            pub fn iopfrst(&self) -> IOPFRSTR {
                IOPFRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - IO port G reset"]
            #[inline]
            pub fn iopgrst(&self) -> IOPGRSTR {
                IOPGRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - ADC 1 interface reset"]
            #[inline]
            pub fn adc1rst(&self) -> ADC1RSTR {
                ADC1RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - TIM1 timer reset"]
            #[inline]
            pub fn tim1rst(&self) -> TIM1RSTR {
                TIM1RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - SPI 1 reset"]
            #[inline]
            pub fn spi1rst(&self) -> SPI1RSTR {
                SPI1RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - USART1 reset"]
            #[inline]
            pub fn usart1rst(&self) -> USART1RSTR {
                USART1RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - TIM15 timer reset"]
            #[inline]
            pub fn tim15rst(&self) -> TIM15RSTR {
                TIM15RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - TIM16 timer reset"]
            #[inline]
            pub fn tim16rst(&self) -> TIM16RSTR {
                TIM16RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - TIM17 timer reset"]
            #[inline]
            pub fn tim17rst(&self) -> TIM17RSTR {
                TIM17RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Alternate function I/O reset"]
            #[inline]
            pub fn afiorst(&mut self) -> _AFIORSTW {
                _AFIORSTW { w: self }
            }
            #[doc = "Bit 2 - IO port A reset"]
            #[inline]
            pub fn ioparst(&mut self) -> _IOPARSTW {
                _IOPARSTW { w: self }
            }
            #[doc = "Bit 3 - IO port B reset"]
            #[inline]
            pub fn iopbrst(&mut self) -> _IOPBRSTW {
                _IOPBRSTW { w: self }
            }
            #[doc = "Bit 4 - IO port C reset"]
            #[inline]
            pub fn iopcrst(&mut self) -> _IOPCRSTW {
                _IOPCRSTW { w: self }
            }
            #[doc = "Bit 5 - IO port D reset"]
            #[inline]
            pub fn iopdrst(&mut self) -> _IOPDRSTW {
                _IOPDRSTW { w: self }
            }
            #[doc = "Bit 6 - IO port E reset"]
            #[inline]
            pub fn ioperst(&mut self) -> _IOPERSTW {
                _IOPERSTW { w: self }
            }
            #[doc = "Bit 7 - IO port F reset"]
            #[inline]
            pub fn iopfrst(&mut self) -> _IOPFRSTW {
                _IOPFRSTW { w: self }
            }
            #[doc = "Bit 8 - IO port G reset"]
            #[inline]
            pub fn iopgrst(&mut self) -> _IOPGRSTW {
                _IOPGRSTW { w: self }
            }
            #[doc = "Bit 9 - ADC 1 interface reset"]
            #[inline]
            pub fn adc1rst(&mut self) -> _ADC1RSTW {
                _ADC1RSTW { w: self }
            }
            #[doc = "Bit 11 - TIM1 timer reset"]
            #[inline]
            pub fn tim1rst(&mut self) -> _TIM1RSTW {
                _TIM1RSTW { w: self }
            }
            #[doc = "Bit 12 - SPI 1 reset"]
            #[inline]
            pub fn spi1rst(&mut self) -> _SPI1RSTW {
                _SPI1RSTW { w: self }
            }
            #[doc = "Bit 14 - USART1 reset"]
            #[inline]
            pub fn usart1rst(&mut self) -> _USART1RSTW {
                _USART1RSTW { w: self }
            }
            #[doc = "Bit 16 - TIM15 timer reset"]
            #[inline]
            pub fn tim15rst(&mut self) -> _TIM15RSTW {
                _TIM15RSTW { w: self }
            }
            #[doc = "Bit 17 - TIM16 timer reset"]
            #[inline]
            pub fn tim16rst(&mut self) -> _TIM16RSTW {
                _TIM16RSTW { w: self }
            }
            #[doc = "Bit 18 - TIM17 timer reset"]
            #[inline]
            pub fn tim17rst(&mut self) -> _TIM17RSTW {
                _TIM17RSTW { w: self }
            }
        }
    }
    #[doc = "APB1 peripheral reset register (RCC_APB1RSTR)"]
    pub struct APB1RSTR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "APB1 peripheral reset register (RCC_APB1RSTR)"]
    pub mod apb1rstr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::APB1RSTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `TIM2RST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIM2RSTR {
            #[doc = "Reset the selected module"]
            RESET,
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl TIM2RSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TIM2RSTR::RESET => true,
                    TIM2RSTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TIM2RSTR {
                match value {
                    true => TIM2RSTR::RESET,
                    i => TIM2RSTR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline]
            pub fn is_reset(&self) -> bool {
                *self == TIM2RSTR::RESET
            }
        }
        #[doc = "Possible values of the field `TIM3RST`"]
        pub type TIM3RSTR = TIM2RSTR;
        #[doc = "Possible values of the field `TIM4RST`"]
        pub type TIM4RSTR = TIM2RSTR;
        #[doc = "Possible values of the field `TIM5RST`"]
        pub type TIM5RSTR = TIM2RSTR;
        #[doc = "Possible values of the field `TIM6RST`"]
        pub type TIM6RSTR = TIM2RSTR;
        #[doc = "Possible values of the field `TIM7RST`"]
        pub type TIM7RSTR = TIM2RSTR;
        #[doc = "Possible values of the field `TIM12RST`"]
        pub type TIM12RSTR = TIM2RSTR;
        #[doc = "Possible values of the field `TIM13RST`"]
        pub type TIM13RSTR = TIM2RSTR;
        #[doc = "Possible values of the field `TIM14RST`"]
        pub type TIM14RSTR = TIM2RSTR;
        #[doc = "Possible values of the field `WWDGRST`"]
        pub type WWDGRSTR = TIM2RSTR;
        #[doc = "Possible values of the field `SPI2RST`"]
        pub type SPI2RSTR = TIM2RSTR;
        #[doc = "Possible values of the field `SPI3RST`"]
        pub type SPI3RSTR = TIM2RSTR;
        #[doc = "Possible values of the field `USART2RST`"]
        pub type USART2RSTR = TIM2RSTR;
        #[doc = "Possible values of the field `USART3RST`"]
        pub type USART3RSTR = TIM2RSTR;
        #[doc = "Possible values of the field `UART4RST`"]
        pub type UART4RSTR = TIM2RSTR;
        #[doc = "Possible values of the field `UART5RST`"]
        pub type UART5RSTR = TIM2RSTR;
        #[doc = "Possible values of the field `I2C1RST`"]
        pub type I2C1RSTR = TIM2RSTR;
        #[doc = "Possible values of the field `I2C2RST`"]
        pub type I2C2RSTR = TIM2RSTR;
        #[doc = "Possible values of the field `BKPRST`"]
        pub type BKPRSTR = TIM2RSTR;
        #[doc = "Possible values of the field `PWRRST`"]
        pub type PWRRSTR = TIM2RSTR;
        #[doc = "Possible values of the field `DACRST`"]
        pub type DACRSTR = TIM2RSTR;
        #[doc = "Possible values of the field `CECRST`"]
        pub type CECRSTR = TIM2RSTR;
        #[doc = "Values that can be written to the field `TIM2RST`"]
        pub enum TIM2RSTW {
            #[doc = "Reset the selected module"]
            RESET,
        }
        impl TIM2RSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TIM2RSTW::RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIM2RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM2RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM2RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM3RST`"]
        pub type TIM3RSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _TIM3RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM3RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM3RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM4RST`"]
        pub type TIM4RSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _TIM4RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM4RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM4RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM5RST`"]
        pub type TIM5RSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _TIM5RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM5RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM5RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM6RST`"]
        pub type TIM6RSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _TIM6RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM6RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM6RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM7RST`"]
        pub type TIM7RSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _TIM7RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM7RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM7RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM12RST`"]
        pub type TIM12RSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _TIM12RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM12RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM12RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM13RST`"]
        pub type TIM13RSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _TIM13RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM13RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM13RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM14RST`"]
        pub type TIM14RSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _TIM14RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM14RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM14RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WWDGRST`"]
        pub type WWDGRSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _WWDGRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WWDGRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WWDGRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI2RST`"]
        pub type SPI2RSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _SPI2RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI2RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPI2RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI3RST`"]
        pub type SPI3RSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _SPI3RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI3RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPI3RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USART2RST`"]
        pub type USART2RSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _USART2RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USART2RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: USART2RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USART3RST`"]
        pub type USART3RSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _USART3RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USART3RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: USART3RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UART4RST`"]
        pub type UART4RSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _UART4RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART4RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UART4RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UART5RST`"]
        pub type UART5RSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _UART5RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART5RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UART5RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C1RST`"]
        pub type I2C1RSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _I2C1RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C1RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C1RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C2RST`"]
        pub type I2C2RSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _I2C2RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C2RSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C2RSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BKPRST`"]
        pub type BKPRSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _BKPRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BKPRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BKPRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PWRRST`"]
        pub type PWRRSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _PWRRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PWRRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PWRRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DACRST`"]
        pub type DACRSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _DACRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DACRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DACRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CECRST`"]
        pub type CECRSTW = TIM2RSTW;
        #[doc = r" Proxy"]
        pub struct _CECRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CECRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CECRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the selected module"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Timer 2 reset"]
            #[inline]
            pub fn tim2rst(&self) -> TIM2RSTR {
                TIM2RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Timer 3 reset"]
            #[inline]
            pub fn tim3rst(&self) -> TIM3RSTR {
                TIM3RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Timer 4 reset"]
            #[inline]
            pub fn tim4rst(&self) -> TIM4RSTR {
                TIM4RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Timer 5 reset"]
            #[inline]
            pub fn tim5rst(&self) -> TIM5RSTR {
                TIM5RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Timer 6 reset"]
            #[inline]
            pub fn tim6rst(&self) -> TIM6RSTR {
                TIM6RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Timer 7 reset"]
            #[inline]
            pub fn tim7rst(&self) -> TIM7RSTR {
                TIM7RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Timer 12 reset"]
            #[inline]
            pub fn tim12rst(&self) -> TIM12RSTR {
                TIM12RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Timer 13 reset"]
            #[inline]
            pub fn tim13rst(&self) -> TIM13RSTR {
                TIM13RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Timer 14 reset"]
            #[inline]
            pub fn tim14rst(&self) -> TIM14RSTR {
                TIM14RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Window watchdog reset"]
            #[inline]
            pub fn wwdgrst(&self) -> WWDGRSTR {
                WWDGRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - SPI2 reset"]
            #[inline]
            pub fn spi2rst(&self) -> SPI2RSTR {
                SPI2RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - SPI3 reset"]
            #[inline]
            pub fn spi3rst(&self) -> SPI3RSTR {
                SPI3RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - USART 2 reset"]
            #[inline]
            pub fn usart2rst(&self) -> USART2RSTR {
                USART2RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - USART 3 reset"]
            #[inline]
            pub fn usart3rst(&self) -> USART3RSTR {
                USART3RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - USART 4 reset"]
            #[inline]
            pub fn uart4rst(&self) -> UART4RSTR {
                UART4RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - USART 5 reset"]
            #[inline]
            pub fn uart5rst(&self) -> UART5RSTR {
                UART5RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - I2C1 reset"]
            #[inline]
            pub fn i2c1rst(&self) -> I2C1RSTR {
                I2C1RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - I2C2 reset"]
            #[inline]
            pub fn i2c2rst(&self) -> I2C2RSTR {
                I2C2RSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 27 - Backup interface reset"]
            #[inline]
            pub fn bkprst(&self) -> BKPRSTR {
                BKPRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 28 - Power interface reset"]
            #[inline]
            pub fn pwrrst(&self) -> PWRRSTR {
                PWRRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - DAC interface reset"]
            #[inline]
            pub fn dacrst(&self) -> DACRSTR {
                DACRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 30 - CEC reset"]
            #[inline]
            pub fn cecrst(&self) -> CECRSTR {
                CECRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Timer 2 reset"]
            #[inline]
            pub fn tim2rst(&mut self) -> _TIM2RSTW {
                _TIM2RSTW { w: self }
            }
            #[doc = "Bit 1 - Timer 3 reset"]
            #[inline]
            pub fn tim3rst(&mut self) -> _TIM3RSTW {
                _TIM3RSTW { w: self }
            }
            #[doc = "Bit 2 - Timer 4 reset"]
            #[inline]
            pub fn tim4rst(&mut self) -> _TIM4RSTW {
                _TIM4RSTW { w: self }
            }
            #[doc = "Bit 3 - Timer 5 reset"]
            #[inline]
            pub fn tim5rst(&mut self) -> _TIM5RSTW {
                _TIM5RSTW { w: self }
            }
            #[doc = "Bit 4 - Timer 6 reset"]
            #[inline]
            pub fn tim6rst(&mut self) -> _TIM6RSTW {
                _TIM6RSTW { w: self }
            }
            #[doc = "Bit 5 - Timer 7 reset"]
            #[inline]
            pub fn tim7rst(&mut self) -> _TIM7RSTW {
                _TIM7RSTW { w: self }
            }
            #[doc = "Bit 6 - Timer 12 reset"]
            #[inline]
            pub fn tim12rst(&mut self) -> _TIM12RSTW {
                _TIM12RSTW { w: self }
            }
            #[doc = "Bit 7 - Timer 13 reset"]
            #[inline]
            pub fn tim13rst(&mut self) -> _TIM13RSTW {
                _TIM13RSTW { w: self }
            }
            #[doc = "Bit 8 - Timer 14 reset"]
            #[inline]
            pub fn tim14rst(&mut self) -> _TIM14RSTW {
                _TIM14RSTW { w: self }
            }
            #[doc = "Bit 11 - Window watchdog reset"]
            #[inline]
            pub fn wwdgrst(&mut self) -> _WWDGRSTW {
                _WWDGRSTW { w: self }
            }
            #[doc = "Bit 14 - SPI2 reset"]
            #[inline]
            pub fn spi2rst(&mut self) -> _SPI2RSTW {
                _SPI2RSTW { w: self }
            }
            #[doc = "Bit 15 - SPI3 reset"]
            #[inline]
            pub fn spi3rst(&mut self) -> _SPI3RSTW {
                _SPI3RSTW { w: self }
            }
            #[doc = "Bit 17 - USART 2 reset"]
            #[inline]
            pub fn usart2rst(&mut self) -> _USART2RSTW {
                _USART2RSTW { w: self }
            }
            #[doc = "Bit 18 - USART 3 reset"]
            #[inline]
            pub fn usart3rst(&mut self) -> _USART3RSTW {
                _USART3RSTW { w: self }
            }
            #[doc = "Bit 19 - USART 4 reset"]
            #[inline]
            pub fn uart4rst(&mut self) -> _UART4RSTW {
                _UART4RSTW { w: self }
            }
            #[doc = "Bit 20 - USART 5 reset"]
            #[inline]
            pub fn uart5rst(&mut self) -> _UART5RSTW {
                _UART5RSTW { w: self }
            }
            #[doc = "Bit 21 - I2C1 reset"]
            #[inline]
            pub fn i2c1rst(&mut self) -> _I2C1RSTW {
                _I2C1RSTW { w: self }
            }
            #[doc = "Bit 22 - I2C2 reset"]
            #[inline]
            pub fn i2c2rst(&mut self) -> _I2C2RSTW {
                _I2C2RSTW { w: self }
            }
            #[doc = "Bit 27 - Backup interface reset"]
            #[inline]
            pub fn bkprst(&mut self) -> _BKPRSTW {
                _BKPRSTW { w: self }
            }
            #[doc = "Bit 28 - Power interface reset"]
            #[inline]
            pub fn pwrrst(&mut self) -> _PWRRSTW {
                _PWRRSTW { w: self }
            }
            #[doc = "Bit 29 - DAC interface reset"]
            #[inline]
            pub fn dacrst(&mut self) -> _DACRSTW {
                _DACRSTW { w: self }
            }
            #[doc = "Bit 30 - CEC reset"]
            #[inline]
            pub fn cecrst(&mut self) -> _CECRSTW {
                _CECRSTW { w: self }
            }
        }
    }
    #[doc = "AHB Peripheral Clock enable register (RCC_AHBENR)"]
    pub struct AHBENR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "AHB Peripheral Clock enable register (RCC_AHBENR)"]
    pub mod ahbenr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::AHBENR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `DMA1EN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMA1ENR {
            #[doc = "The selected clock is disabled"]
            DISABLED,
            #[doc = "The selected clock is enabled"]
            ENABLED,
        }
        impl DMA1ENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DMA1ENR::DISABLED => false,
                    DMA1ENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DMA1ENR {
                match value {
                    false => DMA1ENR::DISABLED,
                    true => DMA1ENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DMA1ENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DMA1ENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `DMA2EN`"]
        pub type DMA2ENR = DMA1ENR;
        #[doc = "Possible values of the field `SRAMEN`"]
        pub type SRAMENR = DMA1ENR;
        #[doc = "Possible values of the field `FLITFEN`"]
        pub type FLITFENR = DMA1ENR;
        #[doc = "Possible values of the field `CRCEN`"]
        pub type CRCENR = DMA1ENR;
        #[doc = "Possible values of the field `FSMCEN`"]
        pub type FSMCENR = DMA1ENR;
        #[doc = "Values that can be written to the field `DMA1EN`"]
        pub enum DMA1ENW {
            #[doc = "The selected clock is disabled"]
            DISABLED,
            #[doc = "The selected clock is enabled"]
            ENABLED,
        }
        impl DMA1ENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DMA1ENW::DISABLED => false,
                    DMA1ENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMA1ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA1ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMA1ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA1ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA1ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DMA2EN`"]
        pub type DMA2ENW = DMA1ENW;
        #[doc = r" Proxy"]
        pub struct _DMA2ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA2ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMA2ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA1ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA1ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRAMEN`"]
        pub type SRAMENW = DMA1ENW;
        #[doc = r" Proxy"]
        pub struct _SRAMENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRAMENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SRAMENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA1ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA1ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLITFEN`"]
        pub type FLITFENW = DMA1ENW;
        #[doc = r" Proxy"]
        pub struct _FLITFENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLITFENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FLITFENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA1ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA1ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CRCEN`"]
        pub type CRCENW = DMA1ENW;
        #[doc = r" Proxy"]
        pub struct _CRCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CRCENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA1ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA1ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FSMCEN`"]
        pub type FSMCENW = DMA1ENW;
        #[doc = r" Proxy"]
        pub struct _FSMCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FSMCENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FSMCENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA1ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA1ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - DMA1 clock enable"]
            #[inline]
            pub fn dma1en(&self) -> DMA1ENR {
                DMA1ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - DMA2 clock enable"]
            #[inline]
            pub fn dma2en(&self) -> DMA2ENR {
                DMA2ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - SRAM interface clock enable"]
            #[inline]
            pub fn sramen(&self) -> SRAMENR {
                SRAMENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - FLITF clock enable"]
            #[inline]
            pub fn flitfen(&self) -> FLITFENR {
                FLITFENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - CRC clock enable"]
            #[inline]
            pub fn crcen(&self) -> CRCENR {
                CRCENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - FSMC clock enable"]
            #[inline]
            pub fn fsmcen(&self) -> FSMCENR {
                FSMCENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x14 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - DMA1 clock enable"]
            #[inline]
            pub fn dma1en(&mut self) -> _DMA1ENW {
                _DMA1ENW { w: self }
            }
            #[doc = "Bit 1 - DMA2 clock enable"]
            #[inline]
            pub fn dma2en(&mut self) -> _DMA2ENW {
                _DMA2ENW { w: self }
            }
            #[doc = "Bit 2 - SRAM interface clock enable"]
            #[inline]
            pub fn sramen(&mut self) -> _SRAMENW {
                _SRAMENW { w: self }
            }
            #[doc = "Bit 4 - FLITF clock enable"]
            #[inline]
            pub fn flitfen(&mut self) -> _FLITFENW {
                _FLITFENW { w: self }
            }
            #[doc = "Bit 6 - CRC clock enable"]
            #[inline]
            pub fn crcen(&mut self) -> _CRCENW {
                _CRCENW { w: self }
            }
            #[doc = "Bit 8 - FSMC clock enable"]
            #[inline]
            pub fn fsmcen(&mut self) -> _FSMCENW {
                _FSMCENW { w: self }
            }
        }
    }
    #[doc = "APB2 peripheral clock enable register (RCC_APB2ENR)"]
    pub struct APB2ENR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "APB2 peripheral clock enable register (RCC_APB2ENR)"]
    pub mod apb2enr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::APB2ENR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `AFIOEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AFIOENR {
            #[doc = "The selected clock is disabled"]
            DISABLED,
            #[doc = "The selected clock is enabled"]
            ENABLED,
        }
        impl AFIOENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    AFIOENR::DISABLED => false,
                    AFIOENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> AFIOENR {
                match value {
                    false => AFIOENR::DISABLED,
                    true => AFIOENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == AFIOENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == AFIOENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `IOPAEN`"]
        pub type IOPAENR = AFIOENR;
        #[doc = "Possible values of the field `IOPBEN`"]
        pub type IOPBENR = AFIOENR;
        #[doc = "Possible values of the field `IOPCEN`"]
        pub type IOPCENR = AFIOENR;
        #[doc = "Possible values of the field `IOPDEN`"]
        pub type IOPDENR = AFIOENR;
        #[doc = "Possible values of the field `IOPEEN`"]
        pub type IOPEENR = AFIOENR;
        #[doc = "Possible values of the field `IOPFEN`"]
        pub type IOPFENR = AFIOENR;
        #[doc = "Possible values of the field `IOPGEN`"]
        pub type IOPGENR = AFIOENR;
        #[doc = "Possible values of the field `ADC1EN`"]
        pub type ADC1ENR = AFIOENR;
        #[doc = "Possible values of the field `TIM1EN`"]
        pub type TIM1ENR = AFIOENR;
        #[doc = "Possible values of the field `SPI1EN`"]
        pub type SPI1ENR = AFIOENR;
        #[doc = "Possible values of the field `USART1EN`"]
        pub type USART1ENR = AFIOENR;
        #[doc = "Possible values of the field `TIM15EN`"]
        pub type TIM15ENR = AFIOENR;
        #[doc = "Possible values of the field `TIM16EN`"]
        pub type TIM16ENR = AFIOENR;
        #[doc = "Possible values of the field `TIM17EN`"]
        pub type TIM17ENR = AFIOENR;
        #[doc = "Values that can be written to the field `AFIOEN`"]
        pub enum AFIOENW {
            #[doc = "The selected clock is disabled"]
            DISABLED,
            #[doc = "The selected clock is enabled"]
            ENABLED,
        }
        impl AFIOENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    AFIOENW::DISABLED => false,
                    AFIOENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _AFIOENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AFIOENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: AFIOENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPAEN`"]
        pub type IOPAENW = AFIOENW;
        #[doc = r" Proxy"]
        pub struct _IOPAENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOPAENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOPAENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPBEN`"]
        pub type IOPBENW = AFIOENW;
        #[doc = r" Proxy"]
        pub struct _IOPBENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOPBENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOPBENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPCEN`"]
        pub type IOPCENW = AFIOENW;
        #[doc = r" Proxy"]
        pub struct _IOPCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOPCENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOPCENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPDEN`"]
        pub type IOPDENW = AFIOENW;
        #[doc = r" Proxy"]
        pub struct _IOPDENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOPDENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOPDENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPEEN`"]
        pub type IOPEENW = AFIOENW;
        #[doc = r" Proxy"]
        pub struct _IOPEENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOPEENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOPEENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPFEN`"]
        pub type IOPFENW = AFIOENW;
        #[doc = r" Proxy"]
        pub struct _IOPFENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOPFENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOPFENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPGEN`"]
        pub type IOPGENW = AFIOENW;
        #[doc = r" Proxy"]
        pub struct _IOPGENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOPGENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOPGENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC1EN`"]
        pub type ADC1ENW = AFIOENW;
        #[doc = r" Proxy"]
        pub struct _ADC1ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC1ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC1ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM1EN`"]
        pub type TIM1ENW = AFIOENW;
        #[doc = r" Proxy"]
        pub struct _TIM1ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM1ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM1ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI1EN`"]
        pub type SPI1ENW = AFIOENW;
        #[doc = r" Proxy"]
        pub struct _SPI1ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPI1ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USART1EN`"]
        pub type USART1ENW = AFIOENW;
        #[doc = r" Proxy"]
        pub struct _USART1ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USART1ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: USART1ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM15EN`"]
        pub type TIM15ENW = AFIOENW;
        #[doc = r" Proxy"]
        pub struct _TIM15ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM15ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM15ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM16EN`"]
        pub type TIM16ENW = AFIOENW;
        #[doc = r" Proxy"]
        pub struct _TIM16ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM16ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM16ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM17EN`"]
        pub type TIM17ENW = AFIOENW;
        #[doc = r" Proxy"]
        pub struct _TIM17ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM17ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM17ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Alternate function I/O clock enable"]
            #[inline]
            pub fn afioen(&self) -> AFIOENR {
                AFIOENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - I/O port A clock enable"]
            #[inline]
            pub fn iopaen(&self) -> IOPAENR {
                IOPAENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - I/O port B clock enable"]
            #[inline]
            pub fn iopben(&self) -> IOPBENR {
                IOPBENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - I/O port C clock enable"]
            #[inline]
            pub fn iopcen(&self) -> IOPCENR {
                IOPCENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - I/O port D clock enable"]
            #[inline]
            pub fn iopden(&self) -> IOPDENR {
                IOPDENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - I/O port E clock enable"]
            #[inline]
            pub fn iopeen(&self) -> IOPEENR {
                IOPEENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - I/O port F clock enable"]
            #[inline]
            pub fn iopfen(&self) -> IOPFENR {
                IOPFENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - I/O port G clock enable"]
            #[inline]
            pub fn iopgen(&self) -> IOPGENR {
                IOPGENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - ADC 1 interface clock enable"]
            #[inline]
            pub fn adc1en(&self) -> ADC1ENR {
                ADC1ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - TIM1 Timer clock enable"]
            #[inline]
            pub fn tim1en(&self) -> TIM1ENR {
                TIM1ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - SPI 1 clock enable"]
            #[inline]
            pub fn spi1en(&self) -> SPI1ENR {
                SPI1ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - USART1 clock enable"]
            #[inline]
            pub fn usart1en(&self) -> USART1ENR {
                USART1ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - TIM15 Timer clock enable"]
            #[inline]
            pub fn tim15en(&self) -> TIM15ENR {
                TIM15ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - TIM16 Timer clock enable"]
            #[inline]
            pub fn tim16en(&self) -> TIM16ENR {
                TIM16ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - TIM17 Timer clock enable"]
            #[inline]
            pub fn tim17en(&self) -> TIM17ENR {
                TIM17ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Alternate function I/O clock enable"]
            #[inline]
            pub fn afioen(&mut self) -> _AFIOENW {
                _AFIOENW { w: self }
            }
            #[doc = "Bit 2 - I/O port A clock enable"]
            #[inline]
            pub fn iopaen(&mut self) -> _IOPAENW {
                _IOPAENW { w: self }
            }
            #[doc = "Bit 3 - I/O port B clock enable"]
            #[inline]
            pub fn iopben(&mut self) -> _IOPBENW {
                _IOPBENW { w: self }
            }
            #[doc = "Bit 4 - I/O port C clock enable"]
            #[inline]
            pub fn iopcen(&mut self) -> _IOPCENW {
                _IOPCENW { w: self }
            }
            #[doc = "Bit 5 - I/O port D clock enable"]
            #[inline]
            pub fn iopden(&mut self) -> _IOPDENW {
                _IOPDENW { w: self }
            }
            #[doc = "Bit 6 - I/O port E clock enable"]
            #[inline]
            pub fn iopeen(&mut self) -> _IOPEENW {
                _IOPEENW { w: self }
            }
            #[doc = "Bit 7 - I/O port F clock enable"]
            #[inline]
            pub fn iopfen(&mut self) -> _IOPFENW {
                _IOPFENW { w: self }
            }
            #[doc = "Bit 8 - I/O port G clock enable"]
            #[inline]
            pub fn iopgen(&mut self) -> _IOPGENW {
                _IOPGENW { w: self }
            }
            #[doc = "Bit 9 - ADC 1 interface clock enable"]
            #[inline]
            pub fn adc1en(&mut self) -> _ADC1ENW {
                _ADC1ENW { w: self }
            }
            #[doc = "Bit 11 - TIM1 Timer clock enable"]
            #[inline]
            pub fn tim1en(&mut self) -> _TIM1ENW {
                _TIM1ENW { w: self }
            }
            #[doc = "Bit 12 - SPI 1 clock enable"]
            #[inline]
            pub fn spi1en(&mut self) -> _SPI1ENW {
                _SPI1ENW { w: self }
            }
            #[doc = "Bit 14 - USART1 clock enable"]
            #[inline]
            pub fn usart1en(&mut self) -> _USART1ENW {
                _USART1ENW { w: self }
            }
            #[doc = "Bit 16 - TIM15 Timer clock enable"]
            #[inline]
            pub fn tim15en(&mut self) -> _TIM15ENW {
                _TIM15ENW { w: self }
            }
            #[doc = "Bit 17 - TIM16 Timer clock enable"]
            #[inline]
            pub fn tim16en(&mut self) -> _TIM16ENW {
                _TIM16ENW { w: self }
            }
            #[doc = "Bit 18 - TIM17 Timer clock enable"]
            #[inline]
            pub fn tim17en(&mut self) -> _TIM17ENW {
                _TIM17ENW { w: self }
            }
        }
    }
    #[doc = "APB1 peripheral clock enable register (RCC_APB1ENR)"]
    pub struct APB1ENR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "APB1 peripheral clock enable register (RCC_APB1ENR)"]
    pub mod apb1enr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::APB1ENR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `TIM2EN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIM2ENR {
            #[doc = "The selected clock is disabled"]
            DISABLED,
            #[doc = "The selected clock is enabled"]
            ENABLED,
        }
        impl TIM2ENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TIM2ENR::DISABLED => false,
                    TIM2ENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TIM2ENR {
                match value {
                    false => TIM2ENR::DISABLED,
                    true => TIM2ENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TIM2ENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TIM2ENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `TIM3EN`"]
        pub type TIM3ENR = TIM2ENR;
        #[doc = "Possible values of the field `TIM4EN`"]
        pub type TIM4ENR = TIM2ENR;
        #[doc = "Possible values of the field `TIM5EN`"]
        pub type TIM5ENR = TIM2ENR;
        #[doc = "Possible values of the field `TIM6EN`"]
        pub type TIM6ENR = TIM2ENR;
        #[doc = "Possible values of the field `TIM7EN`"]
        pub type TIM7ENR = TIM2ENR;
        #[doc = "Possible values of the field `TIM12EN`"]
        pub type TIM12ENR = TIM2ENR;
        #[doc = "Possible values of the field `TIM13EN`"]
        pub type TIM13ENR = TIM2ENR;
        #[doc = "Possible values of the field `TIM14EN`"]
        pub type TIM14ENR = TIM2ENR;
        #[doc = "Possible values of the field `WWDGEN`"]
        pub type WWDGENR = TIM2ENR;
        #[doc = "Possible values of the field `SPI2EN`"]
        pub type SPI2ENR = TIM2ENR;
        #[doc = "Possible values of the field `SPI3EN`"]
        pub type SPI3ENR = TIM2ENR;
        #[doc = "Possible values of the field `USART2EN`"]
        pub type USART2ENR = TIM2ENR;
        #[doc = "Possible values of the field `USART3EN`"]
        pub type USART3ENR = TIM2ENR;
        #[doc = "Possible values of the field `UART4EN`"]
        pub type UART4ENR = TIM2ENR;
        #[doc = "Possible values of the field `UART5EN`"]
        pub type UART5ENR = TIM2ENR;
        #[doc = "Possible values of the field `I2C1EN`"]
        pub type I2C1ENR = TIM2ENR;
        #[doc = "Possible values of the field `I2C2EN`"]
        pub type I2C2ENR = TIM2ENR;
        #[doc = "Possible values of the field `BKPEN`"]
        pub type BKPENR = TIM2ENR;
        #[doc = "Possible values of the field `PWREN`"]
        pub type PWRENR = TIM2ENR;
        #[doc = "Possible values of the field `DACEN`"]
        pub type DACENR = TIM2ENR;
        #[doc = "Possible values of the field `CECEN`"]
        pub type CECENR = TIM2ENR;
        #[doc = "Values that can be written to the field `TIM2EN`"]
        pub enum TIM2ENW {
            #[doc = "The selected clock is disabled"]
            DISABLED,
            #[doc = "The selected clock is enabled"]
            ENABLED,
        }
        impl TIM2ENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TIM2ENW::DISABLED => false,
                    TIM2ENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIM2ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM2ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM2ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM3EN`"]
        pub type TIM3ENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _TIM3ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM3ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM3ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM4EN`"]
        pub type TIM4ENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _TIM4ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM4ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM4ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM5EN`"]
        pub type TIM5ENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _TIM5ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM5ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM5ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM6EN`"]
        pub type TIM6ENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _TIM6ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM6ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM6ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM7EN`"]
        pub type TIM7ENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _TIM7ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM7ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM7ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM12EN`"]
        pub type TIM12ENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _TIM12ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM12ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM12ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM13EN`"]
        pub type TIM13ENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _TIM13ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM13ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM13ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM14EN`"]
        pub type TIM14ENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _TIM14ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM14ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIM14ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WWDGEN`"]
        pub type WWDGENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _WWDGENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WWDGENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WWDGENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI2EN`"]
        pub type SPI2ENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _SPI2ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI2ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPI2ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI3EN`"]
        pub type SPI3ENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _SPI3ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI3ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPI3ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USART2EN`"]
        pub type USART2ENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _USART2ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USART2ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: USART2ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USART3EN`"]
        pub type USART3ENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _USART3ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USART3ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: USART3ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UART4EN`"]
        pub type UART4ENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _UART4ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART4ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UART4ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UART5EN`"]
        pub type UART5ENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _UART5ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART5ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UART5ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C1EN`"]
        pub type I2C1ENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _I2C1ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C1ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C1ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C2EN`"]
        pub type I2C2ENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _I2C2ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C2ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C2ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BKPEN`"]
        pub type BKPENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _BKPENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BKPENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BKPENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PWREN`"]
        pub type PWRENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _PWRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PWRENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PWRENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DACEN`"]
        pub type DACENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _DACENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DACENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DACENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CECEN`"]
        pub type CECENW = TIM2ENW;
        #[doc = r" Proxy"]
        pub struct _CECENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CECENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CECENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The selected clock is disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2ENW::DISABLED)
            }
            #[doc = "The selected clock is enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2ENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Timer 2 clock enable"]
            #[inline]
            pub fn tim2en(&self) -> TIM2ENR {
                TIM2ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Timer 3 clock enable"]
            #[inline]
            pub fn tim3en(&self) -> TIM3ENR {
                TIM3ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Timer 4 clock enable"]
            #[inline]
            pub fn tim4en(&self) -> TIM4ENR {
                TIM4ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Timer 5 clock enable"]
            #[inline]
            pub fn tim5en(&self) -> TIM5ENR {
                TIM5ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Timer 6 clock enable"]
            #[inline]
            pub fn tim6en(&self) -> TIM6ENR {
                TIM6ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Timer 7 clock enable"]
            #[inline]
            pub fn tim7en(&self) -> TIM7ENR {
                TIM7ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Timer 12 clock enable"]
            #[inline]
            pub fn tim12en(&self) -> TIM12ENR {
                TIM12ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Timer 13 clock enable"]
            #[inline]
            pub fn tim13en(&self) -> TIM13ENR {
                TIM13ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Timer 14 clock enable"]
            #[inline]
            pub fn tim14en(&self) -> TIM14ENR {
                TIM14ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Window watchdog clock enable"]
            #[inline]
            pub fn wwdgen(&self) -> WWDGENR {
                WWDGENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - SPI 2 clock enable"]
            #[inline]
            pub fn spi2en(&self) -> SPI2ENR {
                SPI2ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - SPI 3 clock enable"]
            #[inline]
            pub fn spi3en(&self) -> SPI3ENR {
                SPI3ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - USART 2 clock enable"]
            #[inline]
            pub fn usart2en(&self) -> USART2ENR {
                USART2ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - USART 3 clock enable"]
            #[inline]
            pub fn usart3en(&self) -> USART3ENR {
                USART3ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - UART 4 clock enable"]
            #[inline]
            pub fn uart4en(&self) -> UART4ENR {
                UART4ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - UART 5 clock enable"]
            #[inline]
            pub fn uart5en(&self) -> UART5ENR {
                UART5ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - I2C 1 clock enable"]
            #[inline]
            pub fn i2c1en(&self) -> I2C1ENR {
                I2C1ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - I2C 2 clock enable"]
            #[inline]
            pub fn i2c2en(&self) -> I2C2ENR {
                I2C2ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 27 - Backup interface clock enable"]
            #[inline]
            pub fn bkpen(&self) -> BKPENR {
                BKPENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 28 - Power interface clock enable"]
            #[inline]
            pub fn pwren(&self) -> PWRENR {
                PWRENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - DAC interface clock enable"]
            #[inline]
            pub fn dacen(&self) -> DACENR {
                DACENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 30 - CEC clock enable"]
            #[inline]
            pub fn cecen(&self) -> CECENR {
                CECENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Timer 2 clock enable"]
            #[inline]
            pub fn tim2en(&mut self) -> _TIM2ENW {
                _TIM2ENW { w: self }
            }
            #[doc = "Bit 1 - Timer 3 clock enable"]
            #[inline]
            pub fn tim3en(&mut self) -> _TIM3ENW {
                _TIM3ENW { w: self }
            }
            #[doc = "Bit 2 - Timer 4 clock enable"]
            #[inline]
            pub fn tim4en(&mut self) -> _TIM4ENW {
                _TIM4ENW { w: self }
            }
            #[doc = "Bit 3 - Timer 5 clock enable"]
            #[inline]
            pub fn tim5en(&mut self) -> _TIM5ENW {
                _TIM5ENW { w: self }
            }
            #[doc = "Bit 4 - Timer 6 clock enable"]
            #[inline]
            pub fn tim6en(&mut self) -> _TIM6ENW {
                _TIM6ENW { w: self }
            }
            #[doc = "Bit 5 - Timer 7 clock enable"]
            #[inline]
            pub fn tim7en(&mut self) -> _TIM7ENW {
                _TIM7ENW { w: self }
            }
            #[doc = "Bit 6 - Timer 12 clock enable"]
            #[inline]
            pub fn tim12en(&mut self) -> _TIM12ENW {
                _TIM12ENW { w: self }
            }
            #[doc = "Bit 7 - Timer 13 clock enable"]
            #[inline]
            pub fn tim13en(&mut self) -> _TIM13ENW {
                _TIM13ENW { w: self }
            }
            #[doc = "Bit 8 - Timer 14 clock enable"]
            #[inline]
            pub fn tim14en(&mut self) -> _TIM14ENW {
                _TIM14ENW { w: self }
            }
            #[doc = "Bit 11 - Window watchdog clock enable"]
            #[inline]
            pub fn wwdgen(&mut self) -> _WWDGENW {
                _WWDGENW { w: self }
            }
            #[doc = "Bit 14 - SPI 2 clock enable"]
            #[inline]
            pub fn spi2en(&mut self) -> _SPI2ENW {
                _SPI2ENW { w: self }
            }
            #[doc = "Bit 15 - SPI 3 clock enable"]
            #[inline]
            pub fn spi3en(&mut self) -> _SPI3ENW {
                _SPI3ENW { w: self }
            }
            #[doc = "Bit 17 - USART 2 clock enable"]
            #[inline]
            pub fn usart2en(&mut self) -> _USART2ENW {
                _USART2ENW { w: self }
            }
            #[doc = "Bit 18 - USART 3 clock enable"]
            #[inline]
            pub fn usart3en(&mut self) -> _USART3ENW {
                _USART3ENW { w: self }
            }
            #[doc = "Bit 19 - UART 4 clock enable"]
            #[inline]
            pub fn uart4en(&mut self) -> _UART4ENW {
                _UART4ENW { w: self }
            }
            #[doc = "Bit 20 - UART 5 clock enable"]
            #[inline]
            pub fn uart5en(&mut self) -> _UART5ENW {
                _UART5ENW { w: self }
            }
            #[doc = "Bit 21 - I2C 1 clock enable"]
            #[inline]
            pub fn i2c1en(&mut self) -> _I2C1ENW {
                _I2C1ENW { w: self }
            }
            #[doc = "Bit 22 - I2C 2 clock enable"]
            #[inline]
            pub fn i2c2en(&mut self) -> _I2C2ENW {
                _I2C2ENW { w: self }
            }
            #[doc = "Bit 27 - Backup interface clock enable"]
            #[inline]
            pub fn bkpen(&mut self) -> _BKPENW {
                _BKPENW { w: self }
            }
            #[doc = "Bit 28 - Power interface clock enable"]
            #[inline]
            pub fn pwren(&mut self) -> _PWRENW {
                _PWRENW { w: self }
            }
            #[doc = "Bit 29 - DAC interface clock enable"]
            #[inline]
            pub fn dacen(&mut self) -> _DACENW {
                _DACENW { w: self }
            }
            #[doc = "Bit 30 - CEC clock enable"]
            #[inline]
            pub fn cecen(&mut self) -> _CECENW {
                _CECENW { w: self }
            }
        }
    }
    #[doc = "Backup domain control register (RCC_BDCR)"]
    pub struct BDCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup domain control register (RCC_BDCR)"]
    pub mod bdcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BDCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `LSEON`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSEONR {
            #[doc = "LSE oscillator Off"]
            OFF,
            #[doc = "LSE oscillator On"]
            ON,
        }
        impl LSEONR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LSEONR::OFF => false,
                    LSEONR::ON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LSEONR {
                match value {
                    false => LSEONR::OFF,
                    true => LSEONR::ON,
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline]
            pub fn is_off(&self) -> bool {
                *self == LSEONR::OFF
            }
            #[doc = "Checks if the value of the field is `ON`"]
            #[inline]
            pub fn is_on(&self) -> bool {
                *self == LSEONR::ON
            }
        }
        #[doc = "Possible values of the field `LSERDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSERDYR {
            #[doc = "LSE oscillator not ready"]
            NOTREADY,
            #[doc = "LSE oscillator ready"]
            READY,
        }
        impl LSERDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LSERDYR::NOTREADY => false,
                    LSERDYR::READY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LSERDYR {
                match value {
                    false => LSERDYR::NOTREADY,
                    true => LSERDYR::READY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline]
            pub fn is_not_ready(&self) -> bool {
                *self == LSERDYR::NOTREADY
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline]
            pub fn is_ready(&self) -> bool {
                *self == LSERDYR::READY
            }
        }
        #[doc = "Possible values of the field `LSEBYP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSEBYPR {
            #[doc = "LSE crystal oscillator not bypassed"]
            NOTBYPASSED,
            #[doc = "LSE crystal oscillator bypassed with external clock"]
            BYPASSED,
        }
        impl LSEBYPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LSEBYPR::NOTBYPASSED => false,
                    LSEBYPR::BYPASSED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LSEBYPR {
                match value {
                    false => LSEBYPR::NOTBYPASSED,
                    true => LSEBYPR::BYPASSED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTBYPASSED`"]
            #[inline]
            pub fn is_not_bypassed(&self) -> bool {
                *self == LSEBYPR::NOTBYPASSED
            }
            #[doc = "Checks if the value of the field is `BYPASSED`"]
            #[inline]
            pub fn is_bypassed(&self) -> bool {
                *self == LSEBYPR::BYPASSED
            }
        }
        #[doc = "Possible values of the field `RTCSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RTCSELR {
            #[doc = "No clock"]
            NOCLOCK,
            #[doc = "LSE oscillator clock used as RTC clock"]
            LSE,
            #[doc = "LSI oscillator clock used as RTC clock"]
            LSI,
            #[doc = "HSE oscillator clock divided by a prescaler used as RTC clock"]
            HSE,
        }
        impl RTCSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    RTCSELR::NOCLOCK => 0,
                    RTCSELR::LSE => 0x01,
                    RTCSELR::LSI => 0x02,
                    RTCSELR::HSE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> RTCSELR {
                match value {
                    0 => RTCSELR::NOCLOCK,
                    1 => RTCSELR::LSE,
                    2 => RTCSELR::LSI,
                    3 => RTCSELR::HSE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOCLOCK`"]
            #[inline]
            pub fn is_no_clock(&self) -> bool {
                *self == RTCSELR::NOCLOCK
            }
            #[doc = "Checks if the value of the field is `LSE`"]
            #[inline]
            pub fn is_lse(&self) -> bool {
                *self == RTCSELR::LSE
            }
            #[doc = "Checks if the value of the field is `LSI`"]
            #[inline]
            pub fn is_lsi(&self) -> bool {
                *self == RTCSELR::LSI
            }
            #[doc = "Checks if the value of the field is `HSE`"]
            #[inline]
            pub fn is_hse(&self) -> bool {
                *self == RTCSELR::HSE
            }
        }
        #[doc = "Possible values of the field `RTCEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RTCENR {
            #[doc = "RTC clock disabled"]
            DISABLED,
            #[doc = "RTC clock enabled"]
            ENABLED,
        }
        impl RTCENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RTCENR::DISABLED => false,
                    RTCENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RTCENR {
                match value {
                    false => RTCENR::DISABLED,
                    true => RTCENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RTCENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RTCENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `BDRST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BDRSTR {
            #[doc = "Reset not activated"]
            DISABLED,
            #[doc = "Reset the entire RTC domain"]
            ENABLED,
        }
        impl BDRSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BDRSTR::DISABLED => false,
                    BDRSTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BDRSTR {
                match value {
                    false => BDRSTR::DISABLED,
                    true => BDRSTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == BDRSTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == BDRSTR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `LSEON`"]
        pub enum LSEONW {
            #[doc = "LSE oscillator Off"]
            OFF,
            #[doc = "LSE oscillator On"]
            ON,
        }
        impl LSEONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LSEONW::OFF => false,
                    LSEONW::ON => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LSEONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LSEONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LSEONW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "LSE oscillator Off"]
            #[inline]
            pub fn off(self) -> &'a mut W {
                self.variant(LSEONW::OFF)
            }
            #[doc = "LSE oscillator On"]
            #[inline]
            pub fn on(self) -> &'a mut W {
                self.variant(LSEONW::ON)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LSEBYP`"]
        pub enum LSEBYPW {
            #[doc = "LSE crystal oscillator not bypassed"]
            NOTBYPASSED,
            #[doc = "LSE crystal oscillator bypassed with external clock"]
            BYPASSED,
        }
        impl LSEBYPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LSEBYPW::NOTBYPASSED => false,
                    LSEBYPW::BYPASSED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LSEBYPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LSEBYPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LSEBYPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "LSE crystal oscillator not bypassed"]
            #[inline]
            pub fn not_bypassed(self) -> &'a mut W {
                self.variant(LSEBYPW::NOTBYPASSED)
            }
            #[doc = "LSE crystal oscillator bypassed with external clock"]
            #[inline]
            pub fn bypassed(self) -> &'a mut W {
                self.variant(LSEBYPW::BYPASSED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RTCSEL`"]
        pub enum RTCSELW {
            #[doc = "No clock"]
            NOCLOCK,
            #[doc = "LSE oscillator clock used as RTC clock"]
            LSE,
            #[doc = "LSI oscillator clock used as RTC clock"]
            LSI,
            #[doc = "HSE oscillator clock divided by a prescaler used as RTC clock"]
            HSE,
        }
        impl RTCSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RTCSELW::NOCLOCK => 0,
                    RTCSELW::LSE => 1,
                    RTCSELW::LSI => 2,
                    RTCSELW::HSE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RTCSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RTCSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RTCSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No clock"]
            #[inline]
            pub fn no_clock(self) -> &'a mut W {
                self.variant(RTCSELW::NOCLOCK)
            }
            #[doc = "LSE oscillator clock used as RTC clock"]
            #[inline]
            pub fn lse(self) -> &'a mut W {
                self.variant(RTCSELW::LSE)
            }
            #[doc = "LSI oscillator clock used as RTC clock"]
            #[inline]
            pub fn lsi(self) -> &'a mut W {
                self.variant(RTCSELW::LSI)
            }
            #[doc = "HSE oscillator clock divided by a prescaler used as RTC clock"]
            #[inline]
            pub fn hse(self) -> &'a mut W {
                self.variant(RTCSELW::HSE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RTCEN`"]
        pub enum RTCENW {
            #[doc = "RTC clock disabled"]
            DISABLED,
            #[doc = "RTC clock enabled"]
            ENABLED,
        }
        impl RTCENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RTCENW::DISABLED => false,
                    RTCENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RTCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RTCENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RTCENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RTC clock disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RTCENW::DISABLED)
            }
            #[doc = "RTC clock enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RTCENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BDRST`"]
        pub enum BDRSTW {
            #[doc = "Reset not activated"]
            DISABLED,
            #[doc = "Reset the entire RTC domain"]
            ENABLED,
        }
        impl BDRSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BDRSTW::DISABLED => false,
                    BDRSTW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BDRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BDRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BDRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset not activated"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BDRSTW::DISABLED)
            }
            #[doc = "Reset the entire RTC domain"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BDRSTW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - External Low Speed oscillator enable"]
            #[inline]
            pub fn lseon(&self) -> LSEONR {
                LSEONR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - External Low Speed oscillator ready"]
            #[inline]
            pub fn lserdy(&self) -> LSERDYR {
                LSERDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - External Low Speed oscillator bypass"]
            #[inline]
            pub fn lsebyp(&self) -> LSEBYPR {
                LSEBYPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 8:9 - RTC clock source selection"]
            #[inline]
            pub fn rtcsel(&self) -> RTCSELR {
                RTCSELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 15 - RTC clock enable"]
            #[inline]
            pub fn rtcen(&self) -> RTCENR {
                RTCENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Backup domain software reset"]
            #[inline]
            pub fn bdrst(&self) -> BDRSTR {
                BDRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External Low Speed oscillator enable"]
            #[inline]
            pub fn lseon(&mut self) -> _LSEONW {
                _LSEONW { w: self }
            }
            #[doc = "Bit 2 - External Low Speed oscillator bypass"]
            #[inline]
            pub fn lsebyp(&mut self) -> _LSEBYPW {
                _LSEBYPW { w: self }
            }
            #[doc = "Bits 8:9 - RTC clock source selection"]
            #[inline]
            pub fn rtcsel(&mut self) -> _RTCSELW {
                _RTCSELW { w: self }
            }
            #[doc = "Bit 15 - RTC clock enable"]
            #[inline]
            pub fn rtcen(&mut self) -> _RTCENW {
                _RTCENW { w: self }
            }
            #[doc = "Bit 16 - Backup domain software reset"]
            #[inline]
            pub fn bdrst(&mut self) -> _BDRSTW {
                _BDRSTW { w: self }
            }
        }
    }
    #[doc = "Control/status register (RCC_CSR)"]
    pub struct CSR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control/status register (RCC_CSR)"]
    pub mod csr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CSR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `LSION`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSIONR {
            #[doc = "LSI oscillator Off"]
            OFF,
            #[doc = "LSI oscillator On"]
            ON,
        }
        impl LSIONR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LSIONR::OFF => false,
                    LSIONR::ON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LSIONR {
                match value {
                    false => LSIONR::OFF,
                    true => LSIONR::ON,
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline]
            pub fn is_off(&self) -> bool {
                *self == LSIONR::OFF
            }
            #[doc = "Checks if the value of the field is `ON`"]
            #[inline]
            pub fn is_on(&self) -> bool {
                *self == LSIONR::ON
            }
        }
        #[doc = "Possible values of the field `LSIRDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSIRDYR {
            #[doc = "LSI oscillator not ready"]
            NOTREADY,
            #[doc = "LSI oscillator ready"]
            READY,
        }
        impl LSIRDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LSIRDYR::NOTREADY => false,
                    LSIRDYR::READY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LSIRDYR {
                match value {
                    false => LSIRDYR::NOTREADY,
                    true => LSIRDYR::READY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTREADY`"]
            #[inline]
            pub fn is_not_ready(&self) -> bool {
                *self == LSIRDYR::NOTREADY
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline]
            pub fn is_ready(&self) -> bool {
                *self == LSIRDYR::READY
            }
        }
        #[doc = "Possible values of the field `RMVF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RMVFR {
            #[doc = "Clears the reset flag"]
            CLEAR,
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl RMVFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RMVFR::CLEAR => true,
                    RMVFR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RMVFR {
                match value {
                    true => RMVFR::CLEAR,
                    i => RMVFR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline]
            pub fn is_clear(&self) -> bool {
                *self == RMVFR::CLEAR
            }
        }
        #[doc = "Possible values of the field `PINRSTF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINRSTFR {
            #[doc = "No reset has occured"]
            NORESET,
            #[doc = "A reset has occured"]
            RESET,
        }
        impl PINRSTFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PINRSTFR::NORESET => false,
                    PINRSTFR::RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PINRSTFR {
                match value {
                    false => PINRSTFR::NORESET,
                    true => PINRSTFR::RESET,
                }
            }
            #[doc = "Checks if the value of the field is `NORESET`"]
            #[inline]
            pub fn is_no_reset(&self) -> bool {
                *self == PINRSTFR::NORESET
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline]
            pub fn is_reset(&self) -> bool {
                *self == PINRSTFR::RESET
            }
        }
        #[doc = "Possible values of the field `PORRSTF`"]
        pub type PORRSTFR = PINRSTFR;
        #[doc = "Possible values of the field `SFTRSTF`"]
        pub type SFTRSTFR = PINRSTFR;
        #[doc = "Possible values of the field `IWDGRSTF`"]
        pub type IWDGRSTFR = PINRSTFR;
        #[doc = "Possible values of the field `WWDGRSTF`"]
        pub type WWDGRSTFR = PINRSTFR;
        #[doc = "Possible values of the field `LPWRRSTF`"]
        pub type LPWRRSTFR = PINRSTFR;
        #[doc = "Values that can be written to the field `LSION`"]
        pub enum LSIONW {
            #[doc = "LSI oscillator Off"]
            OFF,
            #[doc = "LSI oscillator On"]
            ON,
        }
        impl LSIONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LSIONW::OFF => false,
                    LSIONW::ON => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LSIONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LSIONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LSIONW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "LSI oscillator Off"]
            #[inline]
            pub fn off(self) -> &'a mut W {
                self.variant(LSIONW::OFF)
            }
            #[doc = "LSI oscillator On"]
            #[inline]
            pub fn on(self) -> &'a mut W {
                self.variant(LSIONW::ON)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RMVF`"]
        pub enum RMVFW {
            #[doc = "Clears the reset flag"]
            CLEAR,
        }
        impl RMVFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RMVFW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RMVFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RMVFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RMVFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the reset flag"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(RMVFW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PINRSTF`"]
        pub enum PINRSTFW {
            #[doc = "No reset has occured"]
            NORESET,
            #[doc = "A reset has occured"]
            RESET,
        }
        impl PINRSTFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINRSTFW::NORESET => false,
                    PINRSTFW::RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINRSTFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINRSTFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PINRSTFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No reset has occured"]
            #[inline]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(PINRSTFW::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(PINRSTFW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PORRSTF`"]
        pub type PORRSTFW = PINRSTFW;
        #[doc = r" Proxy"]
        pub struct _PORRSTFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PORRSTFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PORRSTFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No reset has occured"]
            #[inline]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(PINRSTFW::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(PINRSTFW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SFTRSTF`"]
        pub type SFTRSTFW = PINRSTFW;
        #[doc = r" Proxy"]
        pub struct _SFTRSTFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SFTRSTFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SFTRSTFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No reset has occured"]
            #[inline]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(PINRSTFW::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(PINRSTFW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IWDGRSTF`"]
        pub type IWDGRSTFW = PINRSTFW;
        #[doc = r" Proxy"]
        pub struct _IWDGRSTFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IWDGRSTFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IWDGRSTFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No reset has occured"]
            #[inline]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(PINRSTFW::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(PINRSTFW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WWDGRSTF`"]
        pub type WWDGRSTFW = PINRSTFW;
        #[doc = r" Proxy"]
        pub struct _WWDGRSTFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WWDGRSTFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WWDGRSTFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No reset has occured"]
            #[inline]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(PINRSTFW::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(PINRSTFW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LPWRRSTF`"]
        pub type LPWRRSTFW = PINRSTFW;
        #[doc = r" Proxy"]
        pub struct _LPWRRSTFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LPWRRSTFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LPWRRSTFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No reset has occured"]
            #[inline]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(PINRSTFW::NORESET)
            }
            #[doc = "A reset has occured"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(PINRSTFW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Internal low speed oscillator enable"]
            #[inline]
            pub fn lsion(&self) -> LSIONR {
                LSIONR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Internal low speed oscillator ready"]
            #[inline]
            pub fn lsirdy(&self) -> LSIRDYR {
                LSIRDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Remove reset flag"]
            #[inline]
            pub fn rmvf(&self) -> RMVFR {
                RMVFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - PIN reset flag"]
            #[inline]
            pub fn pinrstf(&self) -> PINRSTFR {
                PINRSTFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 27 - POR/PDR reset flag"]
            #[inline]
            pub fn porrstf(&self) -> PORRSTFR {
                PORRSTFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 28 - Software reset flag"]
            #[inline]
            pub fn sftrstf(&self) -> SFTRSTFR {
                SFTRSTFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - Independent watchdog reset flag"]
            #[inline]
            pub fn iwdgrstf(&self) -> IWDGRSTFR {
                IWDGRSTFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 30 - Window watchdog reset flag"]
            #[inline]
            pub fn wwdgrstf(&self) -> WWDGRSTFR {
                WWDGRSTFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 31 - Low-power reset flag"]
            #[inline]
            pub fn lpwrrstf(&self) -> LPWRRSTFR {
                LPWRRSTFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0c00_0000 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Internal low speed oscillator enable"]
            #[inline]
            pub fn lsion(&mut self) -> _LSIONW {
                _LSIONW { w: self }
            }
            #[doc = "Bit 24 - Remove reset flag"]
            #[inline]
            pub fn rmvf(&mut self) -> _RMVFW {
                _RMVFW { w: self }
            }
            #[doc = "Bit 26 - PIN reset flag"]
            #[inline]
            pub fn pinrstf(&mut self) -> _PINRSTFW {
                _PINRSTFW { w: self }
            }
            #[doc = "Bit 27 - POR/PDR reset flag"]
            #[inline]
            pub fn porrstf(&mut self) -> _PORRSTFW {
                _PORRSTFW { w: self }
            }
            #[doc = "Bit 28 - Software reset flag"]
            #[inline]
            pub fn sftrstf(&mut self) -> _SFTRSTFW {
                _SFTRSTFW { w: self }
            }
            #[doc = "Bit 29 - Independent watchdog reset flag"]
            #[inline]
            pub fn iwdgrstf(&mut self) -> _IWDGRSTFW {
                _IWDGRSTFW { w: self }
            }
            #[doc = "Bit 30 - Window watchdog reset flag"]
            #[inline]
            pub fn wwdgrstf(&mut self) -> _WWDGRSTFW {
                _WWDGRSTFW { w: self }
            }
            #[doc = "Bit 31 - Low-power reset flag"]
            #[inline]
            pub fn lpwrrstf(&mut self) -> _LPWRRSTFW {
                _LPWRRSTFW { w: self }
            }
        }
    }
    #[doc = "Clock configuration register 2"]
    pub struct CFGR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock configuration register 2"]
    pub mod cfgr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CFGR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PREDIV1R {
            bits: u8,
        }
        impl PREDIV1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PREDIV1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PREDIV1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - PREDIV1 division factor"]
            #[inline]
            pub fn prediv1(&self) -> PREDIV1R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PREDIV1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - PREDIV1 division factor"]
            #[inline]
            pub fn prediv1(&mut self) -> _PREDIV1W {
                _PREDIV1W { w: self }
            }
        }
    }
}
#[doc = "General purpose I/O"]
#[cfg(feature = "gpioa")]
pub struct GPIOA {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "gpioa")]
unsafe impl Send for GPIOA {}
#[cfg(feature = "gpioa")]
impl GPIOA {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const gpioa::RegisterBlock {
        0x4001_0800 as *const _
    }
}
#[cfg(feature = "gpioa")]
impl Deref for GPIOA {
    type Target = gpioa::RegisterBlock;
    fn deref(&self) -> &gpioa::RegisterBlock {
        unsafe { &*GPIOA::ptr() }
    }
}
#[doc = "General purpose I/O"]
#[cfg(feature = "gpioa")]
pub mod gpioa {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Port configuration register low (GPIOn_CRL)"]
        pub crl: CRL,
        #[doc = "0x04 - Port configuration register high (GPIOn_CRL)"]
        pub crh: CRH,
        #[doc = "0x08 - Port input data register (GPIOn_IDR)"]
        pub idr: IDR,
        #[doc = "0x0c - Port output data register (GPIOn_ODR)"]
        pub odr: ODR,
        #[doc = "0x10 - Port bit set/reset register (GPIOn_BSRR)"]
        pub bsrr: BSRR,
        #[doc = "0x14 - Port bit reset register (GPIOn_BRR)"]
        pub brr: BRR,
        #[doc = "0x18 - Port configuration lock register"]
        pub lckr: LCKR,
    }
    #[doc = "Port configuration register low (GPIOn_CRL)"]
    pub struct CRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Port configuration register low (GPIOn_CRL)"]
    pub mod crl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODE0R {
            bits: u8,
        }
        impl MODE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNF0R {
            bits: u8,
        }
        impl CNF0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODE1R {
            bits: u8,
        }
        impl MODE1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNF1R {
            bits: u8,
        }
        impl CNF1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODE2R {
            bits: u8,
        }
        impl MODE2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNF2R {
            bits: u8,
        }
        impl CNF2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODE3R {
            bits: u8,
        }
        impl MODE3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNF3R {
            bits: u8,
        }
        impl CNF3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODE4R {
            bits: u8,
        }
        impl MODE4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNF4R {
            bits: u8,
        }
        impl CNF4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODE5R {
            bits: u8,
        }
        impl MODE5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNF5R {
            bits: u8,
        }
        impl CNF5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODE6R {
            bits: u8,
        }
        impl MODE6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNF6R {
            bits: u8,
        }
        impl CNF6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODE7R {
            bits: u8,
        }
        impl MODE7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNF7R {
            bits: u8,
        }
        impl CNF7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODE0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNF0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNF0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODE1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNF1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNF1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODE2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNF2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNF2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODE3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODE3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNF3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNF3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODE4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODE4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNF4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNF4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODE5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODE5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNF5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNF5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODE6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODE6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNF6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNF6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODE7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODE7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNF7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNF7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Port n.0 mode bits"]
            #[inline]
            pub fn mode0(&self) -> MODE0R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MODE0R { bits }
            }
            #[doc = "Bits 2:3 - Port n.0 configuration bits"]
            #[inline]
            pub fn cnf0(&self) -> CNF0R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNF0R { bits }
            }
            #[doc = "Bits 4:5 - Port n.1 mode bits"]
            #[inline]
            pub fn mode1(&self) -> MODE1R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MODE1R { bits }
            }
            #[doc = "Bits 6:7 - Port n.1 configuration bits"]
            #[inline]
            pub fn cnf1(&self) -> CNF1R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNF1R { bits }
            }
            #[doc = "Bits 8:9 - Port n.2 mode bits"]
            #[inline]
            pub fn mode2(&self) -> MODE2R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MODE2R { bits }
            }
            #[doc = "Bits 10:11 - Port n.2 configuration bits"]
            #[inline]
            pub fn cnf2(&self) -> CNF2R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNF2R { bits }
            }
            #[doc = "Bits 12:13 - Port n.3 mode bits"]
            #[inline]
            pub fn mode3(&self) -> MODE3R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MODE3R { bits }
            }
            #[doc = "Bits 14:15 - Port n.3 configuration bits"]
            #[inline]
            pub fn cnf3(&self) -> CNF3R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNF3R { bits }
            }
            #[doc = "Bits 16:17 - Port n.4 mode bits"]
            #[inline]
            pub fn mode4(&self) -> MODE4R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MODE4R { bits }
            }
            #[doc = "Bits 18:19 - Port n.4 configuration bits"]
            #[inline]
            pub fn cnf4(&self) -> CNF4R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNF4R { bits }
            }
            #[doc = "Bits 20:21 - Port n.5 mode bits"]
            #[inline]
            pub fn mode5(&self) -> MODE5R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MODE5R { bits }
            }
            #[doc = "Bits 22:23 - Port n.5 configuration bits"]
            #[inline]
            pub fn cnf5(&self) -> CNF5R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNF5R { bits }
            }
            #[doc = "Bits 24:25 - Port n.6 mode bits"]
            #[inline]
            pub fn mode6(&self) -> MODE6R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MODE6R { bits }
            }
            #[doc = "Bits 26:27 - Port n.6 configuration bits"]
            #[inline]
            pub fn cnf6(&self) -> CNF6R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNF6R { bits }
            }
            #[doc = "Bits 28:29 - Port n.7 mode bits"]
            #[inline]
            pub fn mode7(&self) -> MODE7R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MODE7R { bits }
            }
            #[doc = "Bits 30:31 - Port n.7 configuration bits"]
            #[inline]
            pub fn cnf7(&self) -> CNF7R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNF7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x4444_4444 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Port n.0 mode bits"]
            #[inline]
            pub fn mode0(&mut self) -> _MODE0W {
                _MODE0W { w: self }
            }
            #[doc = "Bits 2:3 - Port n.0 configuration bits"]
            #[inline]
            pub fn cnf0(&mut self) -> _CNF0W {
                _CNF0W { w: self }
            }
            #[doc = "Bits 4:5 - Port n.1 mode bits"]
            #[inline]
            pub fn mode1(&mut self) -> _MODE1W {
                _MODE1W { w: self }
            }
            #[doc = "Bits 6:7 - Port n.1 configuration bits"]
            #[inline]
            pub fn cnf1(&mut self) -> _CNF1W {
                _CNF1W { w: self }
            }
            #[doc = "Bits 8:9 - Port n.2 mode bits"]
            #[inline]
            pub fn mode2(&mut self) -> _MODE2W {
                _MODE2W { w: self }
            }
            #[doc = "Bits 10:11 - Port n.2 configuration bits"]
            #[inline]
            pub fn cnf2(&mut self) -> _CNF2W {
                _CNF2W { w: self }
            }
            #[doc = "Bits 12:13 - Port n.3 mode bits"]
            #[inline]
            pub fn mode3(&mut self) -> _MODE3W {
                _MODE3W { w: self }
            }
            #[doc = "Bits 14:15 - Port n.3 configuration bits"]
            #[inline]
            pub fn cnf3(&mut self) -> _CNF3W {
                _CNF3W { w: self }
            }
            #[doc = "Bits 16:17 - Port n.4 mode bits"]
            #[inline]
            pub fn mode4(&mut self) -> _MODE4W {
                _MODE4W { w: self }
            }
            #[doc = "Bits 18:19 - Port n.4 configuration bits"]
            #[inline]
            pub fn cnf4(&mut self) -> _CNF4W {
                _CNF4W { w: self }
            }
            #[doc = "Bits 20:21 - Port n.5 mode bits"]
            #[inline]
            pub fn mode5(&mut self) -> _MODE5W {
                _MODE5W { w: self }
            }
            #[doc = "Bits 22:23 - Port n.5 configuration bits"]
            #[inline]
            pub fn cnf5(&mut self) -> _CNF5W {
                _CNF5W { w: self }
            }
            #[doc = "Bits 24:25 - Port n.6 mode bits"]
            #[inline]
            pub fn mode6(&mut self) -> _MODE6W {
                _MODE6W { w: self }
            }
            #[doc = "Bits 26:27 - Port n.6 configuration bits"]
            #[inline]
            pub fn cnf6(&mut self) -> _CNF6W {
                _CNF6W { w: self }
            }
            #[doc = "Bits 28:29 - Port n.7 mode bits"]
            #[inline]
            pub fn mode7(&mut self) -> _MODE7W {
                _MODE7W { w: self }
            }
            #[doc = "Bits 30:31 - Port n.7 configuration bits"]
            #[inline]
            pub fn cnf7(&mut self) -> _CNF7W {
                _CNF7W { w: self }
            }
        }
    }
    #[doc = "Port configuration register high (GPIOn_CRL)"]
    pub struct CRH {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Port configuration register high (GPIOn_CRL)"]
    pub mod crh {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CRH {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODE8R {
            bits: u8,
        }
        impl MODE8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNF8R {
            bits: u8,
        }
        impl CNF8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODE9R {
            bits: u8,
        }
        impl MODE9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNF9R {
            bits: u8,
        }
        impl CNF9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODE10R {
            bits: u8,
        }
        impl MODE10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNF10R {
            bits: u8,
        }
        impl CNF10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODE11R {
            bits: u8,
        }
        impl MODE11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNF11R {
            bits: u8,
        }
        impl CNF11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODE12R {
            bits: u8,
        }
        impl MODE12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNF12R {
            bits: u8,
        }
        impl CNF12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODE13R {
            bits: u8,
        }
        impl MODE13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNF13R {
            bits: u8,
        }
        impl CNF13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODE14R {
            bits: u8,
        }
        impl MODE14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNF14R {
            bits: u8,
        }
        impl CNF14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODE15R {
            bits: u8,
        }
        impl MODE15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNF15R {
            bits: u8,
        }
        impl CNF15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODE8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODE8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNF8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNF8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODE9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODE9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNF9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNF9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODE10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODE10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNF10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNF10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODE11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODE11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNF11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNF11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODE12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODE12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNF12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNF12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODE13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODE13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNF13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNF13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODE14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODE14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNF14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNF14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODE15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODE15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNF15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNF15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Port n.8 mode bits"]
            #[inline]
            pub fn mode8(&self) -> MODE8R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MODE8R { bits }
            }
            #[doc = "Bits 2:3 - Port n.8 configuration bits"]
            #[inline]
            pub fn cnf8(&self) -> CNF8R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNF8R { bits }
            }
            #[doc = "Bits 4:5 - Port n.9 mode bits"]
            #[inline]
            pub fn mode9(&self) -> MODE9R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MODE9R { bits }
            }
            #[doc = "Bits 6:7 - Port n.9 configuration bits"]
            #[inline]
            pub fn cnf9(&self) -> CNF9R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNF9R { bits }
            }
            #[doc = "Bits 8:9 - Port n.10 mode bits"]
            #[inline]
            pub fn mode10(&self) -> MODE10R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MODE10R { bits }
            }
            #[doc = "Bits 10:11 - Port n.10 configuration bits"]
            #[inline]
            pub fn cnf10(&self) -> CNF10R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNF10R { bits }
            }
            #[doc = "Bits 12:13 - Port n.11 mode bits"]
            #[inline]
            pub fn mode11(&self) -> MODE11R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MODE11R { bits }
            }
            #[doc = "Bits 14:15 - Port n.11 configuration bits"]
            #[inline]
            pub fn cnf11(&self) -> CNF11R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNF11R { bits }
            }
            #[doc = "Bits 16:17 - Port n.12 mode bits"]
            #[inline]
            pub fn mode12(&self) -> MODE12R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MODE12R { bits }
            }
            #[doc = "Bits 18:19 - Port n.12 configuration bits"]
            #[inline]
            pub fn cnf12(&self) -> CNF12R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNF12R { bits }
            }
            #[doc = "Bits 20:21 - Port n.13 mode bits"]
            #[inline]
            pub fn mode13(&self) -> MODE13R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MODE13R { bits }
            }
            #[doc = "Bits 22:23 - Port n.13 configuration bits"]
            #[inline]
            pub fn cnf13(&self) -> CNF13R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNF13R { bits }
            }
            #[doc = "Bits 24:25 - Port n.14 mode bits"]
            #[inline]
            pub fn mode14(&self) -> MODE14R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MODE14R { bits }
            }
            #[doc = "Bits 26:27 - Port n.14 configuration bits"]
            #[inline]
            pub fn cnf14(&self) -> CNF14R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNF14R { bits }
            }
            #[doc = "Bits 28:29 - Port n.15 mode bits"]
            #[inline]
            pub fn mode15(&self) -> MODE15R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MODE15R { bits }
            }
            #[doc = "Bits 30:31 - Port n.15 configuration bits"]
            #[inline]
            pub fn cnf15(&self) -> CNF15R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNF15R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x4444_4444 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Port n.8 mode bits"]
            #[inline]
            pub fn mode8(&mut self) -> _MODE8W {
                _MODE8W { w: self }
            }
            #[doc = "Bits 2:3 - Port n.8 configuration bits"]
            #[inline]
            pub fn cnf8(&mut self) -> _CNF8W {
                _CNF8W { w: self }
            }
            #[doc = "Bits 4:5 - Port n.9 mode bits"]
            #[inline]
            pub fn mode9(&mut self) -> _MODE9W {
                _MODE9W { w: self }
            }
            #[doc = "Bits 6:7 - Port n.9 configuration bits"]
            #[inline]
            pub fn cnf9(&mut self) -> _CNF9W {
                _CNF9W { w: self }
            }
            #[doc = "Bits 8:9 - Port n.10 mode bits"]
            #[inline]
            pub fn mode10(&mut self) -> _MODE10W {
                _MODE10W { w: self }
            }
            #[doc = "Bits 10:11 - Port n.10 configuration bits"]
            #[inline]
            pub fn cnf10(&mut self) -> _CNF10W {
                _CNF10W { w: self }
            }
            #[doc = "Bits 12:13 - Port n.11 mode bits"]
            #[inline]
            pub fn mode11(&mut self) -> _MODE11W {
                _MODE11W { w: self }
            }
            #[doc = "Bits 14:15 - Port n.11 configuration bits"]
            #[inline]
            pub fn cnf11(&mut self) -> _CNF11W {
                _CNF11W { w: self }
            }
            #[doc = "Bits 16:17 - Port n.12 mode bits"]
            #[inline]
            pub fn mode12(&mut self) -> _MODE12W {
                _MODE12W { w: self }
            }
            #[doc = "Bits 18:19 - Port n.12 configuration bits"]
            #[inline]
            pub fn cnf12(&mut self) -> _CNF12W {
                _CNF12W { w: self }
            }
            #[doc = "Bits 20:21 - Port n.13 mode bits"]
            #[inline]
            pub fn mode13(&mut self) -> _MODE13W {
                _MODE13W { w: self }
            }
            #[doc = "Bits 22:23 - Port n.13 configuration bits"]
            #[inline]
            pub fn cnf13(&mut self) -> _CNF13W {
                _CNF13W { w: self }
            }
            #[doc = "Bits 24:25 - Port n.14 mode bits"]
            #[inline]
            pub fn mode14(&mut self) -> _MODE14W {
                _MODE14W { w: self }
            }
            #[doc = "Bits 26:27 - Port n.14 configuration bits"]
            #[inline]
            pub fn cnf14(&mut self) -> _CNF14W {
                _CNF14W { w: self }
            }
            #[doc = "Bits 28:29 - Port n.15 mode bits"]
            #[inline]
            pub fn mode15(&mut self) -> _MODE15W {
                _MODE15W { w: self }
            }
            #[doc = "Bits 30:31 - Port n.15 configuration bits"]
            #[inline]
            pub fn cnf15(&mut self) -> _CNF15W {
                _CNF15W { w: self }
            }
        }
    }
    #[doc = "Port input data register (GPIOn_IDR)"]
    pub struct IDR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Port input data register (GPIOn_IDR)"]
    pub mod idr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::IDR {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = "Possible values of the field `IDR0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDR0R {
            #[doc = "Input is logic high"]
            HIGH,
            #[doc = "Input is logic low"]
            LOW,
        }
        impl IDR0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IDR0R::HIGH => true,
                    IDR0R::LOW => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IDR0R {
                match value {
                    true => IDR0R::HIGH,
                    false => IDR0R::LOW,
                }
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == IDR0R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == IDR0R::LOW
            }
        }
        #[doc = "Possible values of the field `IDR1`"]
        pub type IDR1R = IDR0R;
        #[doc = "Possible values of the field `IDR2`"]
        pub type IDR2R = IDR0R;
        #[doc = "Possible values of the field `IDR3`"]
        pub type IDR3R = IDR0R;
        #[doc = "Possible values of the field `IDR4`"]
        pub type IDR4R = IDR0R;
        #[doc = "Possible values of the field `IDR5`"]
        pub type IDR5R = IDR0R;
        #[doc = "Possible values of the field `IDR6`"]
        pub type IDR6R = IDR0R;
        #[doc = "Possible values of the field `IDR7`"]
        pub type IDR7R = IDR0R;
        #[doc = "Possible values of the field `IDR8`"]
        pub type IDR8R = IDR0R;
        #[doc = "Possible values of the field `IDR9`"]
        pub type IDR9R = IDR0R;
        #[doc = "Possible values of the field `IDR10`"]
        pub type IDR10R = IDR0R;
        #[doc = "Possible values of the field `IDR11`"]
        pub type IDR11R = IDR0R;
        #[doc = "Possible values of the field `IDR12`"]
        pub type IDR12R = IDR0R;
        #[doc = "Possible values of the field `IDR13`"]
        pub type IDR13R = IDR0R;
        #[doc = "Possible values of the field `IDR14`"]
        pub type IDR14R = IDR0R;
        #[doc = "Possible values of the field `IDR15`"]
        pub type IDR15R = IDR0R;
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Port input data"]
            #[inline]
            pub fn idr0(&self) -> IDR0R {
                IDR0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Port input data"]
            #[inline]
            pub fn idr1(&self) -> IDR1R {
                IDR1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Port input data"]
            #[inline]
            pub fn idr2(&self) -> IDR2R {
                IDR2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Port input data"]
            #[inline]
            pub fn idr3(&self) -> IDR3R {
                IDR3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Port input data"]
            #[inline]
            pub fn idr4(&self) -> IDR4R {
                IDR4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Port input data"]
            #[inline]
            pub fn idr5(&self) -> IDR5R {
                IDR5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Port input data"]
            #[inline]
            pub fn idr6(&self) -> IDR6R {
                IDR6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Port input data"]
            #[inline]
            pub fn idr7(&self) -> IDR7R {
                IDR7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Port input data"]
            #[inline]
            pub fn idr8(&self) -> IDR8R {
                IDR8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Port input data"]
            #[inline]
            pub fn idr9(&self) -> IDR9R {
                IDR9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Port input data"]
            #[inline]
            pub fn idr10(&self) -> IDR10R {
                IDR10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Port input data"]
            #[inline]
            pub fn idr11(&self) -> IDR11R {
                IDR11R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Port input data"]
            #[inline]
            pub fn idr12(&self) -> IDR12R {
                IDR12R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Port input data"]
            #[inline]
            pub fn idr13(&self) -> IDR13R {
                IDR13R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Port input data"]
            #[inline]
            pub fn idr14(&self) -> IDR14R {
                IDR14R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Port input data"]
            #[inline]
            pub fn idr15(&self) -> IDR15R {
                IDR15R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "Port output data register (GPIOn_ODR)"]
    pub struct ODR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Port output data register (GPIOn_ODR)"]
    pub mod odr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ODR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ODR0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR0R {
            #[doc = "Set output to logic high"]
            HIGH,
            #[doc = "Set output to logic low"]
            LOW,
        }
        impl ODR0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR0R::HIGH => true,
                    ODR0R::LOW => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR0R {
                match value {
                    true => ODR0R::HIGH,
                    false => ODR0R::LOW,
                }
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == ODR0R::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == ODR0R::LOW
            }
        }
        #[doc = "Possible values of the field `ODR1`"]
        pub type ODR1R = ODR0R;
        #[doc = "Possible values of the field `ODR2`"]
        pub type ODR2R = ODR0R;
        #[doc = "Possible values of the field `ODR3`"]
        pub type ODR3R = ODR0R;
        #[doc = "Possible values of the field `ODR4`"]
        pub type ODR4R = ODR0R;
        #[doc = "Possible values of the field `ODR5`"]
        pub type ODR5R = ODR0R;
        #[doc = "Possible values of the field `ODR6`"]
        pub type ODR6R = ODR0R;
        #[doc = "Possible values of the field `ODR7`"]
        pub type ODR7R = ODR0R;
        #[doc = "Possible values of the field `ODR8`"]
        pub type ODR8R = ODR0R;
        #[doc = "Possible values of the field `ODR9`"]
        pub type ODR9R = ODR0R;
        #[doc = "Possible values of the field `ODR10`"]
        pub type ODR10R = ODR0R;
        #[doc = "Possible values of the field `ODR11`"]
        pub type ODR11R = ODR0R;
        #[doc = "Possible values of the field `ODR12`"]
        pub type ODR12R = ODR0R;
        #[doc = "Possible values of the field `ODR13`"]
        pub type ODR13R = ODR0R;
        #[doc = "Possible values of the field `ODR14`"]
        pub type ODR14R = ODR0R;
        #[doc = "Possible values of the field `ODR15`"]
        pub type ODR15R = ODR0R;
        #[doc = "Values that can be written to the field `ODR0`"]
        pub enum ODR0W {
            #[doc = "Set output to logic high"]
            HIGH,
            #[doc = "Set output to logic low"]
            LOW,
        }
        impl ODR0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODR0W::HIGH => true,
                    ODR0W::LOW => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODR0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODR0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0W::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0W::LOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ODR1`"]
        pub type ODR1W = ODR0W;
        #[doc = r" Proxy"]
        pub struct _ODR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODR1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODR1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0W::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0W::LOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ODR2`"]
        pub type ODR2W = ODR0W;
        #[doc = r" Proxy"]
        pub struct _ODR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODR2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODR2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0W::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0W::LOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ODR3`"]
        pub type ODR3W = ODR0W;
        #[doc = r" Proxy"]
        pub struct _ODR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODR3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODR3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0W::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0W::LOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ODR4`"]
        pub type ODR4W = ODR0W;
        #[doc = r" Proxy"]
        pub struct _ODR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODR4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODR4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0W::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0W::LOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ODR5`"]
        pub type ODR5W = ODR0W;
        #[doc = r" Proxy"]
        pub struct _ODR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODR5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODR5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0W::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0W::LOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ODR6`"]
        pub type ODR6W = ODR0W;
        #[doc = r" Proxy"]
        pub struct _ODR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODR6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODR6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0W::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0W::LOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ODR7`"]
        pub type ODR7W = ODR0W;
        #[doc = r" Proxy"]
        pub struct _ODR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODR7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODR7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0W::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0W::LOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ODR8`"]
        pub type ODR8W = ODR0W;
        #[doc = r" Proxy"]
        pub struct _ODR8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODR8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODR8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0W::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0W::LOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ODR9`"]
        pub type ODR9W = ODR0W;
        #[doc = r" Proxy"]
        pub struct _ODR9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODR9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODR9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0W::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0W::LOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ODR10`"]
        pub type ODR10W = ODR0W;
        #[doc = r" Proxy"]
        pub struct _ODR10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODR10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODR10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0W::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0W::LOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ODR11`"]
        pub type ODR11W = ODR0W;
        #[doc = r" Proxy"]
        pub struct _ODR11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODR11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODR11W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0W::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0W::LOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ODR12`"]
        pub type ODR12W = ODR0W;
        #[doc = r" Proxy"]
        pub struct _ODR12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODR12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODR12W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0W::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0W::LOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ODR13`"]
        pub type ODR13W = ODR0W;
        #[doc = r" Proxy"]
        pub struct _ODR13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODR13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODR13W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0W::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0W::LOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ODR14`"]
        pub type ODR14W = ODR0W;
        #[doc = r" Proxy"]
        pub struct _ODR14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODR14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODR14W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0W::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0W::LOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ODR15`"]
        pub type ODR15W = ODR0W;
        #[doc = r" Proxy"]
        pub struct _ODR15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODR15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODR15W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set output to logic high"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0W::HIGH)
            }
            #[doc = "Set output to logic low"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0W::LOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Port output data"]
            #[inline]
            pub fn odr0(&self) -> ODR0R {
                ODR0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Port output data"]
            #[inline]
            pub fn odr1(&self) -> ODR1R {
                ODR1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Port output data"]
            #[inline]
            pub fn odr2(&self) -> ODR2R {
                ODR2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Port output data"]
            #[inline]
            pub fn odr3(&self) -> ODR3R {
                ODR3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Port output data"]
            #[inline]
            pub fn odr4(&self) -> ODR4R {
                ODR4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Port output data"]
            #[inline]
            pub fn odr5(&self) -> ODR5R {
                ODR5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Port output data"]
            #[inline]
            pub fn odr6(&self) -> ODR6R {
                ODR6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Port output data"]
            #[inline]
            pub fn odr7(&self) -> ODR7R {
                ODR7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Port output data"]
            #[inline]
            pub fn odr8(&self) -> ODR8R {
                ODR8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Port output data"]
            #[inline]
            pub fn odr9(&self) -> ODR9R {
                ODR9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Port output data"]
            #[inline]
            pub fn odr10(&self) -> ODR10R {
                ODR10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Port output data"]
            #[inline]
            pub fn odr11(&self) -> ODR11R {
                ODR11R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Port output data"]
            #[inline]
            pub fn odr12(&self) -> ODR12R {
                ODR12R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Port output data"]
            #[inline]
            pub fn odr13(&self) -> ODR13R {
                ODR13R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Port output data"]
            #[inline]
            pub fn odr14(&self) -> ODR14R {
                ODR14R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Port output data"]
            #[inline]
            pub fn odr15(&self) -> ODR15R {
                ODR15R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Port output data"]
            #[inline]
            pub fn odr0(&mut self) -> _ODR0W {
                _ODR0W { w: self }
            }
            #[doc = "Bit 1 - Port output data"]
            #[inline]
            pub fn odr1(&mut self) -> _ODR1W {
                _ODR1W { w: self }
            }
            #[doc = "Bit 2 - Port output data"]
            #[inline]
            pub fn odr2(&mut self) -> _ODR2W {
                _ODR2W { w: self }
            }
            #[doc = "Bit 3 - Port output data"]
            #[inline]
            pub fn odr3(&mut self) -> _ODR3W {
                _ODR3W { w: self }
            }
            #[doc = "Bit 4 - Port output data"]
            #[inline]
            pub fn odr4(&mut self) -> _ODR4W {
                _ODR4W { w: self }
            }
            #[doc = "Bit 5 - Port output data"]
            #[inline]
            pub fn odr5(&mut self) -> _ODR5W {
                _ODR5W { w: self }
            }
            #[doc = "Bit 6 - Port output data"]
            #[inline]
            pub fn odr6(&mut self) -> _ODR6W {
                _ODR6W { w: self }
            }
            #[doc = "Bit 7 - Port output data"]
            #[inline]
            pub fn odr7(&mut self) -> _ODR7W {
                _ODR7W { w: self }
            }
            #[doc = "Bit 8 - Port output data"]
            #[inline]
            pub fn odr8(&mut self) -> _ODR8W {
                _ODR8W { w: self }
            }
            #[doc = "Bit 9 - Port output data"]
            #[inline]
            pub fn odr9(&mut self) -> _ODR9W {
                _ODR9W { w: self }
            }
            #[doc = "Bit 10 - Port output data"]
            #[inline]
            pub fn odr10(&mut self) -> _ODR10W {
                _ODR10W { w: self }
            }
            #[doc = "Bit 11 - Port output data"]
            #[inline]
            pub fn odr11(&mut self) -> _ODR11W {
                _ODR11W { w: self }
            }
            #[doc = "Bit 12 - Port output data"]
            #[inline]
            pub fn odr12(&mut self) -> _ODR12W {
                _ODR12W { w: self }
            }
            #[doc = "Bit 13 - Port output data"]
            #[inline]
            pub fn odr13(&mut self) -> _ODR13W {
                _ODR13W { w: self }
            }
            #[doc = "Bit 14 - Port output data"]
            #[inline]
            pub fn odr14(&mut self) -> _ODR14W {
                _ODR14W { w: self }
            }
            #[doc = "Bit 15 - Port output data"]
            #[inline]
            pub fn odr15(&mut self) -> _ODR15W {
                _ODR15W { w: self }
            }
        }
    }
    #[doc = "Port bit set/reset register (GPIOn_BSRR)"]
    pub struct BSRR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Port bit set/reset register (GPIOn_BSRR)"]
    pub mod bsrr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BSRR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Values that can be written to the field `BS0`"]
        pub enum BS0W {
            #[doc = "Sets the corresponding ODRx bit"]
            SET,
        }
        impl BS0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BS0W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BS0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BS0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BS0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BS1`"]
        pub type BS1W = BS0W;
        #[doc = r" Proxy"]
        pub struct _BS1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BS1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BS1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BS2`"]
        pub type BS2W = BS0W;
        #[doc = r" Proxy"]
        pub struct _BS2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BS2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BS2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BS3`"]
        pub type BS3W = BS0W;
        #[doc = r" Proxy"]
        pub struct _BS3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BS3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BS3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BS4`"]
        pub type BS4W = BS0W;
        #[doc = r" Proxy"]
        pub struct _BS4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BS4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BS4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BS5`"]
        pub type BS5W = BS0W;
        #[doc = r" Proxy"]
        pub struct _BS5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BS5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BS5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BS6`"]
        pub type BS6W = BS0W;
        #[doc = r" Proxy"]
        pub struct _BS6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BS6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BS6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BS7`"]
        pub type BS7W = BS0W;
        #[doc = r" Proxy"]
        pub struct _BS7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BS7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BS7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BS8`"]
        pub type BS8W = BS0W;
        #[doc = r" Proxy"]
        pub struct _BS8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BS8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BS8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BS9`"]
        pub type BS9W = BS0W;
        #[doc = r" Proxy"]
        pub struct _BS9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BS9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BS9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BS10`"]
        pub type BS10W = BS0W;
        #[doc = r" Proxy"]
        pub struct _BS10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BS10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BS10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BS11`"]
        pub type BS11W = BS0W;
        #[doc = r" Proxy"]
        pub struct _BS11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BS11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BS11W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BS12`"]
        pub type BS12W = BS0W;
        #[doc = r" Proxy"]
        pub struct _BS12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BS12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BS12W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BS13`"]
        pub type BS13W = BS0W;
        #[doc = r" Proxy"]
        pub struct _BS13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BS13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BS13W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BS14`"]
        pub type BS14W = BS0W;
        #[doc = r" Proxy"]
        pub struct _BS14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BS14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BS14W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BS15`"]
        pub type BS15W = BS0W;
        #[doc = r" Proxy"]
        pub struct _BS15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BS15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BS15W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets the corresponding ODRx bit"]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR0`"]
        pub enum BR0W {
            #[doc = "Resets the corresponding ODRx bit"]
            RESET,
        }
        impl BR0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BR0W::RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR1`"]
        pub type BR1W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR2`"]
        pub type BR2W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR3`"]
        pub type BR3W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR4`"]
        pub type BR4W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR5`"]
        pub type BR5W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR6`"]
        pub type BR6W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR7`"]
        pub type BR7W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR8`"]
        pub type BR8W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR9`"]
        pub type BR9W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR10`"]
        pub type BR10W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR11`"]
        pub type BR11W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR11W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR12`"]
        pub type BR12W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR12W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR13`"]
        pub type BR13W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR13W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR14`"]
        pub type BR14W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR14W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR15`"]
        pub type BR15W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR15W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the corresponding ODRx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Set bit 0"]
            #[inline]
            pub fn bs0(&mut self) -> _BS0W {
                _BS0W { w: self }
            }
            #[doc = "Bit 1 - Set bit 1"]
            #[inline]
            pub fn bs1(&mut self) -> _BS1W {
                _BS1W { w: self }
            }
            #[doc = "Bit 2 - Set bit 1"]
            #[inline]
            pub fn bs2(&mut self) -> _BS2W {
                _BS2W { w: self }
            }
            #[doc = "Bit 3 - Set bit 3"]
            #[inline]
            pub fn bs3(&mut self) -> _BS3W {
                _BS3W { w: self }
            }
            #[doc = "Bit 4 - Set bit 4"]
            #[inline]
            pub fn bs4(&mut self) -> _BS4W {
                _BS4W { w: self }
            }
            #[doc = "Bit 5 - Set bit 5"]
            #[inline]
            pub fn bs5(&mut self) -> _BS5W {
                _BS5W { w: self }
            }
            #[doc = "Bit 6 - Set bit 6"]
            #[inline]
            pub fn bs6(&mut self) -> _BS6W {
                _BS6W { w: self }
            }
            #[doc = "Bit 7 - Set bit 7"]
            #[inline]
            pub fn bs7(&mut self) -> _BS7W {
                _BS7W { w: self }
            }
            #[doc = "Bit 8 - Set bit 8"]
            #[inline]
            pub fn bs8(&mut self) -> _BS8W {
                _BS8W { w: self }
            }
            #[doc = "Bit 9 - Set bit 9"]
            #[inline]
            pub fn bs9(&mut self) -> _BS9W {
                _BS9W { w: self }
            }
            #[doc = "Bit 10 - Set bit 10"]
            #[inline]
            pub fn bs10(&mut self) -> _BS10W {
                _BS10W { w: self }
            }
            #[doc = "Bit 11 - Set bit 11"]
            #[inline]
            pub fn bs11(&mut self) -> _BS11W {
                _BS11W { w: self }
            }
            #[doc = "Bit 12 - Set bit 12"]
            #[inline]
            pub fn bs12(&mut self) -> _BS12W {
                _BS12W { w: self }
            }
            #[doc = "Bit 13 - Set bit 13"]
            #[inline]
            pub fn bs13(&mut self) -> _BS13W {
                _BS13W { w: self }
            }
            #[doc = "Bit 14 - Set bit 14"]
            #[inline]
            pub fn bs14(&mut self) -> _BS14W {
                _BS14W { w: self }
            }
            #[doc = "Bit 15 - Set bit 15"]
            #[inline]
            pub fn bs15(&mut self) -> _BS15W {
                _BS15W { w: self }
            }
            #[doc = "Bit 16 - Reset bit 0"]
            #[inline]
            pub fn br0(&mut self) -> _BR0W {
                _BR0W { w: self }
            }
            #[doc = "Bit 17 - Reset bit 1"]
            #[inline]
            pub fn br1(&mut self) -> _BR1W {
                _BR1W { w: self }
            }
            #[doc = "Bit 18 - Reset bit 2"]
            #[inline]
            pub fn br2(&mut self) -> _BR2W {
                _BR2W { w: self }
            }
            #[doc = "Bit 19 - Reset bit 3"]
            #[inline]
            pub fn br3(&mut self) -> _BR3W {
                _BR3W { w: self }
            }
            #[doc = "Bit 20 - Reset bit 4"]
            #[inline]
            pub fn br4(&mut self) -> _BR4W {
                _BR4W { w: self }
            }
            #[doc = "Bit 21 - Reset bit 5"]
            #[inline]
            pub fn br5(&mut self) -> _BR5W {
                _BR5W { w: self }
            }
            #[doc = "Bit 22 - Reset bit 6"]
            #[inline]
            pub fn br6(&mut self) -> _BR6W {
                _BR6W { w: self }
            }
            #[doc = "Bit 23 - Reset bit 7"]
            #[inline]
            pub fn br7(&mut self) -> _BR7W {
                _BR7W { w: self }
            }
            #[doc = "Bit 24 - Reset bit 8"]
            #[inline]
            pub fn br8(&mut self) -> _BR8W {
                _BR8W { w: self }
            }
            #[doc = "Bit 25 - Reset bit 9"]
            #[inline]
            pub fn br9(&mut self) -> _BR9W {
                _BR9W { w: self }
            }
            #[doc = "Bit 26 - Reset bit 10"]
            #[inline]
            pub fn br10(&mut self) -> _BR10W {
                _BR10W { w: self }
            }
            #[doc = "Bit 27 - Reset bit 11"]
            #[inline]
            pub fn br11(&mut self) -> _BR11W {
                _BR11W { w: self }
            }
            #[doc = "Bit 28 - Reset bit 12"]
            #[inline]
            pub fn br12(&mut self) -> _BR12W {
                _BR12W { w: self }
            }
            #[doc = "Bit 29 - Reset bit 13"]
            #[inline]
            pub fn br13(&mut self) -> _BR13W {
                _BR13W { w: self }
            }
            #[doc = "Bit 30 - Reset bit 14"]
            #[inline]
            pub fn br14(&mut self) -> _BR14W {
                _BR14W { w: self }
            }
            #[doc = "Bit 31 - Reset bit 15"]
            #[inline]
            pub fn br15(&mut self) -> _BR15W {
                _BR15W { w: self }
            }
        }
    }
    #[doc = "Port bit reset register (GPIOn_BRR)"]
    pub struct BRR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Port bit reset register (GPIOn_BRR)"]
    pub mod brr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BRR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Values that can be written to the field `BR0`"]
        pub enum BR0W {
            #[doc = "No action on the corresponding ODx bit"]
            NOACTION,
            #[doc = "Reset the ODx bit"]
            RESET,
        }
        impl BR0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BR0W::NOACTION => false,
                    BR0W::RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0W::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR1`"]
        pub type BR1W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0W::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR2`"]
        pub type BR2W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0W::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR3`"]
        pub type BR3W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0W::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR4`"]
        pub type BR4W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0W::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR5`"]
        pub type BR5W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0W::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR6`"]
        pub type BR6W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0W::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR7`"]
        pub type BR7W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0W::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR8`"]
        pub type BR8W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0W::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR9`"]
        pub type BR9W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0W::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR10`"]
        pub type BR10W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0W::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR11`"]
        pub type BR11W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR11W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0W::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR12`"]
        pub type BR12W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR12W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0W::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR13`"]
        pub type BR13W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR13W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0W::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR14`"]
        pub type BR14W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR14W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0W::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BR15`"]
        pub type BR15W = BR0W;
        #[doc = r" Proxy"]
        pub struct _BR15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BR15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BR15W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action on the corresponding ODx bit"]
            #[inline]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0W::NOACTION)
            }
            #[doc = "Reset the ODx bit"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0W::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Reset bit 0"]
            #[inline]
            pub fn br0(&mut self) -> _BR0W {
                _BR0W { w: self }
            }
            #[doc = "Bit 1 - Reset bit 1"]
            #[inline]
            pub fn br1(&mut self) -> _BR1W {
                _BR1W { w: self }
            }
            #[doc = "Bit 2 - Reset bit 1"]
            #[inline]
            pub fn br2(&mut self) -> _BR2W {
                _BR2W { w: self }
            }
            #[doc = "Bit 3 - Reset bit 3"]
            #[inline]
            pub fn br3(&mut self) -> _BR3W {
                _BR3W { w: self }
            }
            #[doc = "Bit 4 - Reset bit 4"]
            #[inline]
            pub fn br4(&mut self) -> _BR4W {
                _BR4W { w: self }
            }
            #[doc = "Bit 5 - Reset bit 5"]
            #[inline]
            pub fn br5(&mut self) -> _BR5W {
                _BR5W { w: self }
            }
            #[doc = "Bit 6 - Reset bit 6"]
            #[inline]
            pub fn br6(&mut self) -> _BR6W {
                _BR6W { w: self }
            }
            #[doc = "Bit 7 - Reset bit 7"]
            #[inline]
            pub fn br7(&mut self) -> _BR7W {
                _BR7W { w: self }
            }
            #[doc = "Bit 8 - Reset bit 8"]
            #[inline]
            pub fn br8(&mut self) -> _BR8W {
                _BR8W { w: self }
            }
            #[doc = "Bit 9 - Reset bit 9"]
            #[inline]
            pub fn br9(&mut self) -> _BR9W {
                _BR9W { w: self }
            }
            #[doc = "Bit 10 - Reset bit 10"]
            #[inline]
            pub fn br10(&mut self) -> _BR10W {
                _BR10W { w: self }
            }
            #[doc = "Bit 11 - Reset bit 11"]
            #[inline]
            pub fn br11(&mut self) -> _BR11W {
                _BR11W { w: self }
            }
            #[doc = "Bit 12 - Reset bit 12"]
            #[inline]
            pub fn br12(&mut self) -> _BR12W {
                _BR12W { w: self }
            }
            #[doc = "Bit 13 - Reset bit 13"]
            #[inline]
            pub fn br13(&mut self) -> _BR13W {
                _BR13W { w: self }
            }
            #[doc = "Bit 14 - Reset bit 14"]
            #[inline]
            pub fn br14(&mut self) -> _BR14W {
                _BR14W { w: self }
            }
            #[doc = "Bit 15 - Reset bit 15"]
            #[inline]
            pub fn br15(&mut self) -> _BR15W {
                _BR15W { w: self }
            }
        }
    }
    #[doc = "Port configuration lock register"]
    pub struct LCKR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Port configuration lock register"]
    pub mod lckr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LCKR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `LCK0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LCK0R {
            #[doc = "Port configuration not locked"]
            UNLOCKED,
            #[doc = "Port configuration locked"]
            LOCKED,
        }
        impl LCK0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LCK0R::UNLOCKED => false,
                    LCK0R::LOCKED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LCK0R {
                match value {
                    false => LCK0R::UNLOCKED,
                    true => LCK0R::LOCKED,
                }
            }
            #[doc = "Checks if the value of the field is `UNLOCKED`"]
            #[inline]
            pub fn is_unlocked(&self) -> bool {
                *self == LCK0R::UNLOCKED
            }
            #[doc = "Checks if the value of the field is `LOCKED`"]
            #[inline]
            pub fn is_locked(&self) -> bool {
                *self == LCK0R::LOCKED
            }
        }
        #[doc = "Possible values of the field `LCK1`"]
        pub type LCK1R = LCK0R;
        #[doc = "Possible values of the field `LCK2`"]
        pub type LCK2R = LCK0R;
        #[doc = "Possible values of the field `LCK3`"]
        pub type LCK3R = LCK0R;
        #[doc = "Possible values of the field `LCK4`"]
        pub type LCK4R = LCK0R;
        #[doc = "Possible values of the field `LCK5`"]
        pub type LCK5R = LCK0R;
        #[doc = "Possible values of the field `LCK6`"]
        pub type LCK6R = LCK0R;
        #[doc = "Possible values of the field `LCK7`"]
        pub type LCK7R = LCK0R;
        #[doc = "Possible values of the field `LCK8`"]
        pub type LCK8R = LCK0R;
        #[doc = "Possible values of the field `LCK9`"]
        pub type LCK9R = LCK0R;
        #[doc = "Possible values of the field `LCK10`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LCK10R {
            #[doc = "Port configuration not locked"]
            UNLOCKED,
            #[doc = "Port configuration locked"]
            LOCKED,
        }
        impl LCK10R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LCK10R::UNLOCKED => false,
                    LCK10R::LOCKED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LCK10R {
                match value {
                    false => LCK10R::UNLOCKED,
                    true => LCK10R::LOCKED,
                }
            }
            #[doc = "Checks if the value of the field is `UNLOCKED`"]
            #[inline]
            pub fn is_unlocked(&self) -> bool {
                *self == LCK10R::UNLOCKED
            }
            #[doc = "Checks if the value of the field is `LOCKED`"]
            #[inline]
            pub fn is_locked(&self) -> bool {
                *self == LCK10R::LOCKED
            }
        }
        #[doc = "Possible values of the field `LCK11`"]
        pub type LCK11R = LCK10R;
        #[doc = "Possible values of the field `LCK12`"]
        pub type LCK12R = LCK10R;
        #[doc = "Possible values of the field `LCK13`"]
        pub type LCK13R = LCK10R;
        #[doc = "Possible values of the field `LCK14`"]
        pub type LCK14R = LCK10R;
        #[doc = "Possible values of the field `LCK15`"]
        pub type LCK15R = LCK10R;
        #[doc = "Possible values of the field `LCKK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LCKKR {
            #[doc = "Port configuration lock key not active"]
            NOTACTIVE,
            #[doc = "Port configuration lock key active"]
            ACTIVE,
        }
        impl LCKKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LCKKR::NOTACTIVE => false,
                    LCKKR::ACTIVE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LCKKR {
                match value {
                    false => LCKKR::NOTACTIVE,
                    true => LCKKR::ACTIVE,
                }
            }
            #[doc = "Checks if the value of the field is `NOTACTIVE`"]
            #[inline]
            pub fn is_not_active(&self) -> bool {
                *self == LCKKR::NOTACTIVE
            }
            #[doc = "Checks if the value of the field is `ACTIVE`"]
            #[inline]
            pub fn is_active(&self) -> bool {
                *self == LCKKR::ACTIVE
            }
        }
        #[doc = "Values that can be written to the field `LCK0`"]
        pub enum LCK0W {
            #[doc = "Port configuration not locked"]
            UNLOCKED,
            #[doc = "Port configuration locked"]
            LOCKED,
        }
        impl LCK0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LCK0W::UNLOCKED => false,
                    LCK0W::LOCKED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LCK0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCK0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCK0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0W::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0W::LOCKED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LCK1`"]
        pub type LCK1W = LCK0W;
        #[doc = r" Proxy"]
        pub struct _LCK1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCK1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCK1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0W::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0W::LOCKED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LCK2`"]
        pub type LCK2W = LCK0W;
        #[doc = r" Proxy"]
        pub struct _LCK2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCK2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCK2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0W::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0W::LOCKED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LCK3`"]
        pub type LCK3W = LCK0W;
        #[doc = r" Proxy"]
        pub struct _LCK3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCK3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCK3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0W::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0W::LOCKED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LCK4`"]
        pub type LCK4W = LCK0W;
        #[doc = r" Proxy"]
        pub struct _LCK4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCK4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCK4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0W::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0W::LOCKED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LCK5`"]
        pub type LCK5W = LCK0W;
        #[doc = r" Proxy"]
        pub struct _LCK5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCK5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCK5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0W::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0W::LOCKED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LCK6`"]
        pub type LCK6W = LCK0W;
        #[doc = r" Proxy"]
        pub struct _LCK6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCK6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCK6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0W::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0W::LOCKED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LCK7`"]
        pub type LCK7W = LCK0W;
        #[doc = r" Proxy"]
        pub struct _LCK7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCK7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCK7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0W::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0W::LOCKED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LCK8`"]
        pub type LCK8W = LCK0W;
        #[doc = r" Proxy"]
        pub struct _LCK8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCK8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCK8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0W::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0W::LOCKED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LCK9`"]
        pub type LCK9W = LCK0W;
        #[doc = r" Proxy"]
        pub struct _LCK9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCK9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCK9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0W::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0W::LOCKED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LCK10`"]
        pub enum LCK10W {
            #[doc = "Port configuration not locked"]
            UNLOCKED,
            #[doc = "Port configuration locked"]
            LOCKED,
        }
        impl LCK10W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LCK10W::UNLOCKED => false,
                    LCK10W::LOCKED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LCK10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCK10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCK10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK10W::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK10W::LOCKED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LCK11`"]
        pub type LCK11W = LCK10W;
        #[doc = r" Proxy"]
        pub struct _LCK11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCK11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCK11W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK10W::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK10W::LOCKED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LCK12`"]
        pub type LCK12W = LCK10W;
        #[doc = r" Proxy"]
        pub struct _LCK12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCK12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCK12W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK10W::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK10W::LOCKED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LCK13`"]
        pub type LCK13W = LCK10W;
        #[doc = r" Proxy"]
        pub struct _LCK13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCK13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCK13W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK10W::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK10W::LOCKED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LCK14`"]
        pub type LCK14W = LCK10W;
        #[doc = r" Proxy"]
        pub struct _LCK14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCK14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCK14W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK10W::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK10W::LOCKED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LCK15`"]
        pub type LCK15W = LCK10W;
        #[doc = r" Proxy"]
        pub struct _LCK15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCK15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCK15W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration not locked"]
            #[inline]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK10W::UNLOCKED)
            }
            #[doc = "Port configuration locked"]
            #[inline]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK10W::LOCKED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LCKK`"]
        pub enum LCKKW {
            #[doc = "Port configuration lock key not active"]
            NOTACTIVE,
            #[doc = "Port configuration lock key active"]
            ACTIVE,
        }
        impl LCKKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LCKKW::NOTACTIVE => false,
                    LCKKW::ACTIVE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LCKKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LCKKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LCKKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Port configuration lock key not active"]
            #[inline]
            pub fn not_active(self) -> &'a mut W {
                self.variant(LCKKW::NOTACTIVE)
            }
            #[doc = "Port configuration lock key active"]
            #[inline]
            pub fn active(self) -> &'a mut W {
                self.variant(LCKKW::ACTIVE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Port A Lock bit 0"]
            #[inline]
            pub fn lck0(&self) -> LCK0R {
                LCK0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Port A Lock bit 1"]
            #[inline]
            pub fn lck1(&self) -> LCK1R {
                LCK1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Port A Lock bit 2"]
            #[inline]
            pub fn lck2(&self) -> LCK2R {
                LCK2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Port A Lock bit 3"]
            #[inline]
            pub fn lck3(&self) -> LCK3R {
                LCK3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Port A Lock bit 4"]
            #[inline]
            pub fn lck4(&self) -> LCK4R {
                LCK4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Port A Lock bit 5"]
            #[inline]
            pub fn lck5(&self) -> LCK5R {
                LCK5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Port A Lock bit 6"]
            #[inline]
            pub fn lck6(&self) -> LCK6R {
                LCK6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Port A Lock bit 7"]
            #[inline]
            pub fn lck7(&self) -> LCK7R {
                LCK7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Port A Lock bit 8"]
            #[inline]
            pub fn lck8(&self) -> LCK8R {
                LCK8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Port A Lock bit 9"]
            #[inline]
            pub fn lck9(&self) -> LCK9R {
                LCK9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Port A Lock bit 10"]
            #[inline]
            pub fn lck10(&self) -> LCK10R {
                LCK10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Port A Lock bit 11"]
            #[inline]
            pub fn lck11(&self) -> LCK11R {
                LCK11R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Port A Lock bit 12"]
            #[inline]
            pub fn lck12(&self) -> LCK12R {
                LCK12R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Port A Lock bit 13"]
            #[inline]
            pub fn lck13(&self) -> LCK13R {
                LCK13R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Port A Lock bit 14"]
            #[inline]
            pub fn lck14(&self) -> LCK14R {
                LCK14R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Port A Lock bit 15"]
            #[inline]
            pub fn lck15(&self) -> LCK15R {
                LCK15R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Lock key"]
            #[inline]
            pub fn lckk(&self) -> LCKKR {
                LCKKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Port A Lock bit 0"]
            #[inline]
            pub fn lck0(&mut self) -> _LCK0W {
                _LCK0W { w: self }
            }
            #[doc = "Bit 1 - Port A Lock bit 1"]
            #[inline]
            pub fn lck1(&mut self) -> _LCK1W {
                _LCK1W { w: self }
            }
            #[doc = "Bit 2 - Port A Lock bit 2"]
            #[inline]
            pub fn lck2(&mut self) -> _LCK2W {
                _LCK2W { w: self }
            }
            #[doc = "Bit 3 - Port A Lock bit 3"]
            #[inline]
            pub fn lck3(&mut self) -> _LCK3W {
                _LCK3W { w: self }
            }
            #[doc = "Bit 4 - Port A Lock bit 4"]
            #[inline]
            pub fn lck4(&mut self) -> _LCK4W {
                _LCK4W { w: self }
            }
            #[doc = "Bit 5 - Port A Lock bit 5"]
            #[inline]
            pub fn lck5(&mut self) -> _LCK5W {
                _LCK5W { w: self }
            }
            #[doc = "Bit 6 - Port A Lock bit 6"]
            #[inline]
            pub fn lck6(&mut self) -> _LCK6W {
                _LCK6W { w: self }
            }
            #[doc = "Bit 7 - Port A Lock bit 7"]
            #[inline]
            pub fn lck7(&mut self) -> _LCK7W {
                _LCK7W { w: self }
            }
            #[doc = "Bit 8 - Port A Lock bit 8"]
            #[inline]
            pub fn lck8(&mut self) -> _LCK8W {
                _LCK8W { w: self }
            }
            #[doc = "Bit 9 - Port A Lock bit 9"]
            #[inline]
            pub fn lck9(&mut self) -> _LCK9W {
                _LCK9W { w: self }
            }
            #[doc = "Bit 10 - Port A Lock bit 10"]
            #[inline]
            pub fn lck10(&mut self) -> _LCK10W {
                _LCK10W { w: self }
            }
            #[doc = "Bit 11 - Port A Lock bit 11"]
            #[inline]
            pub fn lck11(&mut self) -> _LCK11W {
                _LCK11W { w: self }
            }
            #[doc = "Bit 12 - Port A Lock bit 12"]
            #[inline]
            pub fn lck12(&mut self) -> _LCK12W {
                _LCK12W { w: self }
            }
            #[doc = "Bit 13 - Port A Lock bit 13"]
            #[inline]
            pub fn lck13(&mut self) -> _LCK13W {
                _LCK13W { w: self }
            }
            #[doc = "Bit 14 - Port A Lock bit 14"]
            #[inline]
            pub fn lck14(&mut self) -> _LCK14W {
                _LCK14W { w: self }
            }
            #[doc = "Bit 15 - Port A Lock bit 15"]
            #[inline]
            pub fn lck15(&mut self) -> _LCK15W {
                _LCK15W { w: self }
            }
            #[doc = "Bit 16 - Lock key"]
            #[inline]
            pub fn lckk(&mut self) -> _LCKKW {
                _LCKKW { w: self }
            }
        }
    }
}
#[doc = "GPIOB"]
#[cfg(feature = "gpiob")]
pub struct GPIOB {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "gpiob")]
unsafe impl Send for GPIOB {}
#[cfg(feature = "gpiob")]
impl GPIOB {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const gpioa::RegisterBlock {
        0x4001_0c00 as *const _
    }
}
#[cfg(feature = "gpiob")]
impl Deref for GPIOB {
    type Target = gpioa::RegisterBlock;
    fn deref(&self) -> &gpioa::RegisterBlock {
        unsafe { &*GPIOB::ptr() }
    }
}
#[doc = "GPIOC"]
#[cfg(feature = "gpioc")]
pub struct GPIOC {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "gpioc")]
unsafe impl Send for GPIOC {}
#[cfg(feature = "gpioc")]
impl GPIOC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const gpioa::RegisterBlock {
        0x4001_1000 as *const _
    }
}
#[cfg(feature = "gpioc")]
impl Deref for GPIOC {
    type Target = gpioa::RegisterBlock;
    fn deref(&self) -> &gpioa::RegisterBlock {
        unsafe { &*GPIOC::ptr() }
    }
}
#[doc = "GPIOD"]
#[cfg(feature = "gpiod")]
pub struct GPIOD {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "gpiod")]
unsafe impl Send for GPIOD {}
#[cfg(feature = "gpiod")]
impl GPIOD {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const gpioa::RegisterBlock {
        0x4001_1400 as *const _
    }
}
#[cfg(feature = "gpiod")]
impl Deref for GPIOD {
    type Target = gpioa::RegisterBlock;
    fn deref(&self) -> &gpioa::RegisterBlock {
        unsafe { &*GPIOD::ptr() }
    }
}
#[doc = "GPIOE"]
#[cfg(feature = "gpioe")]
pub struct GPIOE {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "gpioe")]
unsafe impl Send for GPIOE {}
#[cfg(feature = "gpioe")]
impl GPIOE {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const gpioa::RegisterBlock {
        0x4001_1800 as *const _
    }
}
#[cfg(feature = "gpioe")]
impl Deref for GPIOE {
    type Target = gpioa::RegisterBlock;
    fn deref(&self) -> &gpioa::RegisterBlock {
        unsafe { &*GPIOE::ptr() }
    }
}
#[doc = "GPIOF"]
#[cfg(feature = "gpiof")]
pub struct GPIOF {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "gpiof")]
unsafe impl Send for GPIOF {}
#[cfg(feature = "gpiof")]
impl GPIOF {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const gpioa::RegisterBlock {
        0x4001_1c00 as *const _
    }
}
#[cfg(feature = "gpiof")]
impl Deref for GPIOF {
    type Target = gpioa::RegisterBlock;
    fn deref(&self) -> &gpioa::RegisterBlock {
        unsafe { &*GPIOF::ptr() }
    }
}
#[doc = "GPIOG"]
#[cfg(feature = "gpiog")]
pub struct GPIOG {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "gpiog")]
unsafe impl Send for GPIOG {}
#[cfg(feature = "gpiog")]
impl GPIOG {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const gpioa::RegisterBlock {
        0x4001_2000 as *const _
    }
}
#[cfg(feature = "gpiog")]
impl Deref for GPIOG {
    type Target = gpioa::RegisterBlock;
    fn deref(&self) -> &gpioa::RegisterBlock {
        unsafe { &*GPIOG::ptr() }
    }
}
#[doc = "Alternate function I/O"]
#[cfg(feature = "afio")]
pub struct AFIO {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "afio")]
unsafe impl Send for AFIO {}
#[cfg(feature = "afio")]
impl AFIO {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const afio::RegisterBlock {
        0x4001_0000 as *const _
    }
}
#[cfg(feature = "afio")]
impl Deref for AFIO {
    type Target = afio::RegisterBlock;
    fn deref(&self) -> &afio::RegisterBlock {
        unsafe { &*AFIO::ptr() }
    }
}
#[doc = "Alternate function I/O"]
#[cfg(feature = "afio")]
pub mod afio {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Event Control Register (AFIO_EVCR)"]
        pub evcr: EVCR,
        #[doc = "0x04 - AF remap and debug I/O configuration register (AFIO_MAPR)"]
        pub mapr: MAPR,
        #[doc = "0x08 - External interrupt configuration register 1 (AFIO_EXTICR1)"]
        pub exticr1: EXTICR1,
        #[doc = "0x0c - External interrupt configuration register 2 (AFIO_EXTICR2)"]
        pub exticr2: EXTICR2,
        #[doc = "0x10 - External interrupt configuration register 3 (AFIO_EXTICR3)"]
        pub exticr3: EXTICR3,
        #[doc = "0x14 - External interrupt configuration register 4 (AFIO_EXTICR4)"]
        pub exticr4: EXTICR4,
        _reserved0: [u8; 4usize],
        #[doc = "0x1c - AF remap and debug I/O configuration register"]
        pub mapr2: MAPR2,
    }
    #[doc = "Event Control Register (AFIO_EVCR)"]
    pub struct EVCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Event Control Register (AFIO_EVCR)"]
    pub mod evcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PINR {
            bits: u8,
        }
        impl PINR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PORTR {
            bits: u8,
        }
        impl PORTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVOER {
            bits: bool,
        }
        impl EVOER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PORTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PORTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVOEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVOEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Pin selection"]
            #[inline]
            pub fn pin(&self) -> PINR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PINR { bits }
            }
            #[doc = "Bits 4:6 - Port selection"]
            #[inline]
            pub fn port(&self) -> PORTR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PORTR { bits }
            }
            #[doc = "Bit 7 - Event Output Enable"]
            #[inline]
            pub fn evoe(&self) -> EVOER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVOER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Pin selection"]
            #[inline]
            pub fn pin(&mut self) -> _PINW {
                _PINW { w: self }
            }
            #[doc = "Bits 4:6 - Port selection"]
            #[inline]
            pub fn port(&mut self) -> _PORTW {
                _PORTW { w: self }
            }
            #[doc = "Bit 7 - Event Output Enable"]
            #[inline]
            pub fn evoe(&mut self) -> _EVOEW {
                _EVOEW { w: self }
            }
        }
    }
    #[doc = "AF remap and debug I/O configuration register (AFIO_MAPR)"]
    pub struct MAPR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "AF remap and debug I/O configuration register (AFIO_MAPR)"]
    pub mod mapr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MAPR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI1_REMAPR {
            bits: bool,
        }
        impl SPI1_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C1_REMAPR {
            bits: bool,
        }
        impl I2C1_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USART1_REMAPR {
            bits: bool,
        }
        impl USART1_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USART2_REMAPR {
            bits: bool,
        }
        impl USART2_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USART3_REMAPR {
            bits: u8,
        }
        impl USART3_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIM1_REMAPR {
            bits: u8,
        }
        impl TIM1_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIM2_REMAPR {
            bits: u8,
        }
        impl TIM2_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIM3_REMAPR {
            bits: u8,
        }
        impl TIM3_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIM4_REMAPR {
            bits: bool,
        }
        impl TIM4_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PD01_REMAPR {
            bits: bool,
        }
        impl PD01_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIM5CH4_IREMAPR {
            bits: bool,
        }
        impl TIM5CH4_IREMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_REMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C1_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C1_REMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _USART1_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USART1_REMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _USART2_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USART2_REMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _USART3_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USART3_REMAPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIM1_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM1_REMAPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIM2_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM2_REMAPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIM3_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM3_REMAPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIM4_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM4_REMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PD01_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PD01_REMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIM5CH4_IREMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM5CH4_IREMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWJ_CFGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWJ_CFGW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - SPI1 remapping"]
            #[inline]
            pub fn spi1_remap(&self) -> SPI1_REMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI1_REMAPR { bits }
            }
            #[doc = "Bit 1 - I2C1 remapping"]
            #[inline]
            pub fn i2c1_remap(&self) -> I2C1_REMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2C1_REMAPR { bits }
            }
            #[doc = "Bit 2 - USART1 remapping"]
            #[inline]
            pub fn usart1_remap(&self) -> USART1_REMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USART1_REMAPR { bits }
            }
            #[doc = "Bit 3 - USART2 remapping"]
            #[inline]
            pub fn usart2_remap(&self) -> USART2_REMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USART2_REMAPR { bits }
            }
            #[doc = "Bits 4:5 - USART3 remapping"]
            #[inline]
            pub fn usart3_remap(&self) -> USART3_REMAPR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                USART3_REMAPR { bits }
            }
            #[doc = "Bits 6:7 - TIM1 remapping"]
            #[inline]
            pub fn tim1_remap(&self) -> TIM1_REMAPR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TIM1_REMAPR { bits }
            }
            #[doc = "Bits 8:9 - TIM2 remapping"]
            #[inline]
            pub fn tim2_remap(&self) -> TIM2_REMAPR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TIM2_REMAPR { bits }
            }
            #[doc = "Bits 10:11 - TIM3 remapping"]
            #[inline]
            pub fn tim3_remap(&self) -> TIM3_REMAPR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TIM3_REMAPR { bits }
            }
            #[doc = "Bit 12 - TIM4 remapping"]
            #[inline]
            pub fn tim4_remap(&self) -> TIM4_REMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIM4_REMAPR { bits }
            }
            #[doc = "Bit 15 - Port D0/Port D1 mapping on OSCIN/OSCOUT"]
            #[inline]
            pub fn pd01_remap(&self) -> PD01_REMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PD01_REMAPR { bits }
            }
            #[doc = "Bit 16 - Set and cleared by software"]
            #[inline]
            pub fn tim5ch4_iremap(&self) -> TIM5CH4_IREMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIM5CH4_IREMAPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - SPI1 remapping"]
            #[inline]
            pub fn spi1_remap(&mut self) -> _SPI1_REMAPW {
                _SPI1_REMAPW { w: self }
            }
            #[doc = "Bit 1 - I2C1 remapping"]
            #[inline]
            pub fn i2c1_remap(&mut self) -> _I2C1_REMAPW {
                _I2C1_REMAPW { w: self }
            }
            #[doc = "Bit 2 - USART1 remapping"]
            #[inline]
            pub fn usart1_remap(&mut self) -> _USART1_REMAPW {
                _USART1_REMAPW { w: self }
            }
            #[doc = "Bit 3 - USART2 remapping"]
            #[inline]
            pub fn usart2_remap(&mut self) -> _USART2_REMAPW {
                _USART2_REMAPW { w: self }
            }
            #[doc = "Bits 4:5 - USART3 remapping"]
            #[inline]
            pub fn usart3_remap(&mut self) -> _USART3_REMAPW {
                _USART3_REMAPW { w: self }
            }
            #[doc = "Bits 6:7 - TIM1 remapping"]
            #[inline]
            pub fn tim1_remap(&mut self) -> _TIM1_REMAPW {
                _TIM1_REMAPW { w: self }
            }
            #[doc = "Bits 8:9 - TIM2 remapping"]
            #[inline]
            pub fn tim2_remap(&mut self) -> _TIM2_REMAPW {
                _TIM2_REMAPW { w: self }
            }
            #[doc = "Bits 10:11 - TIM3 remapping"]
            #[inline]
            pub fn tim3_remap(&mut self) -> _TIM3_REMAPW {
                _TIM3_REMAPW { w: self }
            }
            #[doc = "Bit 12 - TIM4 remapping"]
            #[inline]
            pub fn tim4_remap(&mut self) -> _TIM4_REMAPW {
                _TIM4_REMAPW { w: self }
            }
            #[doc = "Bit 15 - Port D0/Port D1 mapping on OSCIN/OSCOUT"]
            #[inline]
            pub fn pd01_remap(&mut self) -> _PD01_REMAPW {
                _PD01_REMAPW { w: self }
            }
            #[doc = "Bit 16 - Set and cleared by software"]
            #[inline]
            pub fn tim5ch4_iremap(&mut self) -> _TIM5CH4_IREMAPW {
                _TIM5CH4_IREMAPW { w: self }
            }
            #[doc = "Bits 24:26 - Serial wire JTAG configuration"]
            #[inline]
            pub fn swj_cfg(&mut self) -> _SWJ_CFGW {
                _SWJ_CFGW { w: self }
            }
        }
    }
    #[doc = "External interrupt configuration register 1 (AFIO_EXTICR1)"]
    pub struct EXTICR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "External interrupt configuration register 1 (AFIO_EXTICR1)"]
    pub mod exticr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EXTICR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTI0R {
            bits: u8,
        }
        impl EXTI0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTI1R {
            bits: u8,
        }
        impl EXTI1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTI2R {
            bits: u8,
        }
        impl EXTI2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTI3R {
            bits: u8,
        }
        impl EXTI3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTI0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTI0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTI1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTI1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTI2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTI2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTI3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTI3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - EXTI0 configuration"]
            #[inline]
            pub fn exti0(&self) -> EXTI0R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTI0R { bits }
            }
            #[doc = "Bits 4:7 - EXTI1 configuration"]
            #[inline]
            pub fn exti1(&self) -> EXTI1R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTI1R { bits }
            }
            #[doc = "Bits 8:11 - EXTI2 configuration"]
            #[inline]
            pub fn exti2(&self) -> EXTI2R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTI2R { bits }
            }
            #[doc = "Bits 12:15 - EXTI3 configuration"]
            #[inline]
            pub fn exti3(&self) -> EXTI3R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTI3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - EXTI0 configuration"]
            #[inline]
            pub fn exti0(&mut self) -> _EXTI0W {
                _EXTI0W { w: self }
            }
            #[doc = "Bits 4:7 - EXTI1 configuration"]
            #[inline]
            pub fn exti1(&mut self) -> _EXTI1W {
                _EXTI1W { w: self }
            }
            #[doc = "Bits 8:11 - EXTI2 configuration"]
            #[inline]
            pub fn exti2(&mut self) -> _EXTI2W {
                _EXTI2W { w: self }
            }
            #[doc = "Bits 12:15 - EXTI3 configuration"]
            #[inline]
            pub fn exti3(&mut self) -> _EXTI3W {
                _EXTI3W { w: self }
            }
        }
    }
    #[doc = "External interrupt configuration register 2 (AFIO_EXTICR2)"]
    pub struct EXTICR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "External interrupt configuration register 2 (AFIO_EXTICR2)"]
    pub mod exticr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EXTICR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTI4R {
            bits: u8,
        }
        impl EXTI4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTI5R {
            bits: u8,
        }
        impl EXTI5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTI6R {
            bits: u8,
        }
        impl EXTI6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTI7R {
            bits: u8,
        }
        impl EXTI7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTI4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTI4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTI5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTI5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTI6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTI6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTI7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTI7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - EXTI4 configuration"]
            #[inline]
            pub fn exti4(&self) -> EXTI4R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTI4R { bits }
            }
            #[doc = "Bits 4:7 - EXTI5 configuration"]
            #[inline]
            pub fn exti5(&self) -> EXTI5R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTI5R { bits }
            }
            #[doc = "Bits 8:11 - EXTI6 configuration"]
            #[inline]
            pub fn exti6(&self) -> EXTI6R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTI6R { bits }
            }
            #[doc = "Bits 12:15 - EXTI7 configuration"]
            #[inline]
            pub fn exti7(&self) -> EXTI7R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTI7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - EXTI4 configuration"]
            #[inline]
            pub fn exti4(&mut self) -> _EXTI4W {
                _EXTI4W { w: self }
            }
            #[doc = "Bits 4:7 - EXTI5 configuration"]
            #[inline]
            pub fn exti5(&mut self) -> _EXTI5W {
                _EXTI5W { w: self }
            }
            #[doc = "Bits 8:11 - EXTI6 configuration"]
            #[inline]
            pub fn exti6(&mut self) -> _EXTI6W {
                _EXTI6W { w: self }
            }
            #[doc = "Bits 12:15 - EXTI7 configuration"]
            #[inline]
            pub fn exti7(&mut self) -> _EXTI7W {
                _EXTI7W { w: self }
            }
        }
    }
    #[doc = "External interrupt configuration register 3 (AFIO_EXTICR3)"]
    pub struct EXTICR3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "External interrupt configuration register 3 (AFIO_EXTICR3)"]
    pub mod exticr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EXTICR3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTI8R {
            bits: u8,
        }
        impl EXTI8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTI9R {
            bits: u8,
        }
        impl EXTI9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTI10R {
            bits: u8,
        }
        impl EXTI10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTI11R {
            bits: u8,
        }
        impl EXTI11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTI8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTI8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTI9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTI9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTI10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTI10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTI11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTI11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - EXTI8 configuration"]
            #[inline]
            pub fn exti8(&self) -> EXTI8R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTI8R { bits }
            }
            #[doc = "Bits 4:7 - EXTI9 configuration"]
            #[inline]
            pub fn exti9(&self) -> EXTI9R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTI9R { bits }
            }
            #[doc = "Bits 8:11 - EXTI10 configuration"]
            #[inline]
            pub fn exti10(&self) -> EXTI10R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTI10R { bits }
            }
            #[doc = "Bits 12:15 - EXTI11 configuration"]
            #[inline]
            pub fn exti11(&self) -> EXTI11R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTI11R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - EXTI8 configuration"]
            #[inline]
            pub fn exti8(&mut self) -> _EXTI8W {
                _EXTI8W { w: self }
            }
            #[doc = "Bits 4:7 - EXTI9 configuration"]
            #[inline]
            pub fn exti9(&mut self) -> _EXTI9W {
                _EXTI9W { w: self }
            }
            #[doc = "Bits 8:11 - EXTI10 configuration"]
            #[inline]
            pub fn exti10(&mut self) -> _EXTI10W {
                _EXTI10W { w: self }
            }
            #[doc = "Bits 12:15 - EXTI11 configuration"]
            #[inline]
            pub fn exti11(&mut self) -> _EXTI11W {
                _EXTI11W { w: self }
            }
        }
    }
    #[doc = "External interrupt configuration register 4 (AFIO_EXTICR4)"]
    pub struct EXTICR4 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "External interrupt configuration register 4 (AFIO_EXTICR4)"]
    pub mod exticr4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EXTICR4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTI12R {
            bits: u8,
        }
        impl EXTI12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTI13R {
            bits: u8,
        }
        impl EXTI13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTI14R {
            bits: u8,
        }
        impl EXTI14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTI15R {
            bits: u8,
        }
        impl EXTI15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTI12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTI12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTI13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTI13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTI14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTI14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTI15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTI15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - EXTI12 configuration"]
            #[inline]
            pub fn exti12(&self) -> EXTI12R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTI12R { bits }
            }
            #[doc = "Bits 4:7 - EXTI13 configuration"]
            #[inline]
            pub fn exti13(&self) -> EXTI13R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTI13R { bits }
            }
            #[doc = "Bits 8:11 - EXTI14 configuration"]
            #[inline]
            pub fn exti14(&self) -> EXTI14R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTI14R { bits }
            }
            #[doc = "Bits 12:15 - EXTI15 configuration"]
            #[inline]
            pub fn exti15(&self) -> EXTI15R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTI15R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - EXTI12 configuration"]
            #[inline]
            pub fn exti12(&mut self) -> _EXTI12W {
                _EXTI12W { w: self }
            }
            #[doc = "Bits 4:7 - EXTI13 configuration"]
            #[inline]
            pub fn exti13(&mut self) -> _EXTI13W {
                _EXTI13W { w: self }
            }
            #[doc = "Bits 8:11 - EXTI14 configuration"]
            #[inline]
            pub fn exti14(&mut self) -> _EXTI14W {
                _EXTI14W { w: self }
            }
            #[doc = "Bits 12:15 - EXTI15 configuration"]
            #[inline]
            pub fn exti15(&mut self) -> _EXTI15W {
                _EXTI15W { w: self }
            }
        }
    }
    #[doc = "AF remap and debug I/O configuration register"]
    pub struct MAPR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "AF remap and debug I/O configuration register"]
    pub mod mapr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MAPR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIM15_REMAPR {
            bits: bool,
        }
        impl TIM15_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIM16_REMAPR {
            bits: bool,
        }
        impl TIM16_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIM17_REMAPR {
            bits: bool,
        }
        impl TIM17_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIM13_REMAPR {
            bits: bool,
        }
        impl TIM13_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIM14_REMAPR {
            bits: bool,
        }
        impl TIM14_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FSMC_NADVR {
            bits: bool,
        }
        impl FSMC_NADVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CEC_REMAPR {
            bits: bool,
        }
        impl CEC_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIM1_DMA_REMAPR {
            bits: bool,
        }
        impl TIM1_DMA_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIM67_DAC_DMA_REMAPR {
            bits: bool,
        }
        impl TIM67_DAC_DMA_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIM12_REMAPR {
            bits: bool,
        }
        impl TIM12_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MISC_REMAPR {
            bits: bool,
        }
        impl MISC_REMAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIM15_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM15_REMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIM16_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM16_REMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIM17_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM17_REMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIM13_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM13_REMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIM14_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM14_REMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FSMC_NADVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FSMC_NADVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CEC_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CEC_REMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIM1_DMA_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM1_DMA_REMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIM67_DAC_DMA_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM67_DAC_DMA_REMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIM12_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIM12_REMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MISC_REMAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MISC_REMAPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - TIM15 remapping"]
            #[inline]
            pub fn tim15_remap(&self) -> TIM15_REMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIM15_REMAPR { bits }
            }
            #[doc = "Bit 1 - TIM16 remapping"]
            #[inline]
            pub fn tim16_remap(&self) -> TIM16_REMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIM16_REMAPR { bits }
            }
            #[doc = "Bit 2 - TIM17 remapping"]
            #[inline]
            pub fn tim17_remap(&self) -> TIM17_REMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIM17_REMAPR { bits }
            }
            #[doc = "Bit 8 - TIM13 remapping"]
            #[inline]
            pub fn tim13_remap(&self) -> TIM13_REMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIM13_REMAPR { bits }
            }
            #[doc = "Bit 9 - TIM14 remapping"]
            #[inline]
            pub fn tim14_remap(&self) -> TIM14_REMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIM14_REMAPR { bits }
            }
            #[doc = "Bit 10 - NADV connect/disconnect"]
            #[inline]
            pub fn fsmc_nadv(&self) -> FSMC_NADVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FSMC_NADVR { bits }
            }
            #[doc = "Bit 3 - CEC remapping"]
            #[inline]
            pub fn cec_remap(&self) -> CEC_REMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CEC_REMAPR { bits }
            }
            #[doc = "Bit 4 - TIM1 DMA remapping"]
            #[inline]
            pub fn tim1_dma_remap(&self) -> TIM1_DMA_REMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIM1_DMA_REMAPR { bits }
            }
            #[doc = "Bit 11 - TIM67_DAC DMA remapping"]
            #[inline]
            pub fn tim67_dac_dma_remap(&self) -> TIM67_DAC_DMA_REMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIM67_DAC_DMA_REMAPR { bits }
            }
            #[doc = "Bit 12 - TIM12 remapping"]
            #[inline]
            pub fn tim12_remap(&self) -> TIM12_REMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIM12_REMAPR { bits }
            }
            #[doc = "Bit 13 - Miscellaneous features remapping"]
            #[inline]
            pub fn misc_remap(&self) -> MISC_REMAPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MISC_REMAPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - TIM15 remapping"]
            #[inline]
            pub fn tim15_remap(&mut self) -> _TIM15_REMAPW {
                _TIM15_REMAPW { w: self }
            }
            #[doc = "Bit 1 - TIM16 remapping"]
            #[inline]
            pub fn tim16_remap(&mut self) -> _TIM16_REMAPW {
                _TIM16_REMAPW { w: self }
            }
            #[doc = "Bit 2 - TIM17 remapping"]
            #[inline]
            pub fn tim17_remap(&mut self) -> _TIM17_REMAPW {
                _TIM17_REMAPW { w: self }
            }
            #[doc = "Bit 8 - TIM13 remapping"]
            #[inline]
            pub fn tim13_remap(&mut self) -> _TIM13_REMAPW {
                _TIM13_REMAPW { w: self }
            }
            #[doc = "Bit 9 - TIM14 remapping"]
            #[inline]
            pub fn tim14_remap(&mut self) -> _TIM14_REMAPW {
                _TIM14_REMAPW { w: self }
            }
            #[doc = "Bit 10 - NADV connect/disconnect"]
            #[inline]
            pub fn fsmc_nadv(&mut self) -> _FSMC_NADVW {
                _FSMC_NADVW { w: self }
            }
            #[doc = "Bit 3 - CEC remapping"]
            #[inline]
            pub fn cec_remap(&mut self) -> _CEC_REMAPW {
                _CEC_REMAPW { w: self }
            }
            #[doc = "Bit 4 - TIM1 DMA remapping"]
            #[inline]
            pub fn tim1_dma_remap(&mut self) -> _TIM1_DMA_REMAPW {
                _TIM1_DMA_REMAPW { w: self }
            }
            #[doc = "Bit 11 - TIM67_DAC DMA remapping"]
            #[inline]
            pub fn tim67_dac_dma_remap(&mut self) -> _TIM67_DAC_DMA_REMAPW {
                _TIM67_DAC_DMA_REMAPW { w: self }
            }
            #[doc = "Bit 12 - TIM12 remapping"]
            #[inline]
            pub fn tim12_remap(&mut self) -> _TIM12_REMAPW {
                _TIM12_REMAPW { w: self }
            }
            #[doc = "Bit 13 - Miscellaneous features remapping"]
            #[inline]
            pub fn misc_remap(&mut self) -> _MISC_REMAPW {
                _MISC_REMAPW { w: self }
            }
        }
    }
}
#[doc = "EXTI"]
#[cfg(feature = "exti")]
pub struct EXTI {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "exti")]
unsafe impl Send for EXTI {}
#[cfg(feature = "exti")]
impl EXTI {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const exti::RegisterBlock {
        0x4001_0400 as *const _
    }
}
#[cfg(feature = "exti")]
impl Deref for EXTI {
    type Target = exti::RegisterBlock;
    fn deref(&self) -> &exti::RegisterBlock {
        unsafe { &*EXTI::ptr() }
    }
}
#[doc = "EXTI"]
#[cfg(feature = "exti")]
pub mod exti {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Interrupt mask register (EXTI_IMR)"]
        pub imr: IMR,
        #[doc = "0x04 - Event mask register (EXTI_EMR)"]
        pub emr: EMR,
        #[doc = "0x08 - Rising Trigger selection register (EXTI_RTSR)"]
        pub rtsr: RTSR,
        #[doc = "0x0c - Falling Trigger selection register (EXTI_FTSR)"]
        pub ftsr: FTSR,
        #[doc = "0x10 - Software interrupt event register (EXTI_SWIER)"]
        pub swier: SWIER,
        #[doc = "0x14 - Pending register (EXTI_PR)"]
        pub pr: PR,
    }
    #[doc = "Interrupt mask register (EXTI_IMR)"]
    pub struct IMR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt mask register (EXTI_IMR)"]
    pub mod imr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IMR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR0R {
            bits: bool,
        }
        impl MR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR1R {
            bits: bool,
        }
        impl MR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR2R {
            bits: bool,
        }
        impl MR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR3R {
            bits: bool,
        }
        impl MR3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR4R {
            bits: bool,
        }
        impl MR4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR5R {
            bits: bool,
        }
        impl MR5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR6R {
            bits: bool,
        }
        impl MR6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR7R {
            bits: bool,
        }
        impl MR7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR8R {
            bits: bool,
        }
        impl MR8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR9R {
            bits: bool,
        }
        impl MR9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR10R {
            bits: bool,
        }
        impl MR10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR11R {
            bits: bool,
        }
        impl MR11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR12R {
            bits: bool,
        }
        impl MR12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR13R {
            bits: bool,
        }
        impl MR13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR14R {
            bits: bool,
        }
        impl MR14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR15R {
            bits: bool,
        }
        impl MR15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR16R {
            bits: bool,
        }
        impl MR16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR17R {
            bits: bool,
        }
        impl MR17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Interrupt Mask on line 0"]
            #[inline]
            pub fn mr0(&self) -> MR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR0R { bits }
            }
            #[doc = "Bit 1 - Interrupt Mask on line 1"]
            #[inline]
            pub fn mr1(&self) -> MR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR1R { bits }
            }
            #[doc = "Bit 2 - Interrupt Mask on line 2"]
            #[inline]
            pub fn mr2(&self) -> MR2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR2R { bits }
            }
            #[doc = "Bit 3 - Interrupt Mask on line 3"]
            #[inline]
            pub fn mr3(&self) -> MR3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR3R { bits }
            }
            #[doc = "Bit 4 - Interrupt Mask on line 4"]
            #[inline]
            pub fn mr4(&self) -> MR4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR4R { bits }
            }
            #[doc = "Bit 5 - Interrupt Mask on line 5"]
            #[inline]
            pub fn mr5(&self) -> MR5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR5R { bits }
            }
            #[doc = "Bit 6 - Interrupt Mask on line 6"]
            #[inline]
            pub fn mr6(&self) -> MR6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR6R { bits }
            }
            #[doc = "Bit 7 - Interrupt Mask on line 7"]
            #[inline]
            pub fn mr7(&self) -> MR7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR7R { bits }
            }
            #[doc = "Bit 8 - Interrupt Mask on line 8"]
            #[inline]
            pub fn mr8(&self) -> MR8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR8R { bits }
            }
            #[doc = "Bit 9 - Interrupt Mask on line 9"]
            #[inline]
            pub fn mr9(&self) -> MR9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR9R { bits }
            }
            #[doc = "Bit 10 - Interrupt Mask on line 10"]
            #[inline]
            pub fn mr10(&self) -> MR10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR10R { bits }
            }
            #[doc = "Bit 11 - Interrupt Mask on line 11"]
            #[inline]
            pub fn mr11(&self) -> MR11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR11R { bits }
            }
            #[doc = "Bit 12 - Interrupt Mask on line 12"]
            #[inline]
            pub fn mr12(&self) -> MR12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR12R { bits }
            }
            #[doc = "Bit 13 - Interrupt Mask on line 13"]
            #[inline]
            pub fn mr13(&self) -> MR13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR13R { bits }
            }
            #[doc = "Bit 14 - Interrupt Mask on line 14"]
            #[inline]
            pub fn mr14(&self) -> MR14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR14R { bits }
            }
            #[doc = "Bit 15 - Interrupt Mask on line 15"]
            #[inline]
            pub fn mr15(&self) -> MR15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR15R { bits }
            }
            #[doc = "Bit 16 - Interrupt Mask on line 16"]
            #[inline]
            pub fn mr16(&self) -> MR16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR16R { bits }
            }
            #[doc = "Bit 17 - Interrupt Mask on line 17"]
            #[inline]
            pub fn mr17(&self) -> MR17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR17R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Interrupt Mask on line 0"]
            #[inline]
            pub fn mr0(&mut self) -> _MR0W {
                _MR0W { w: self }
            }
            #[doc = "Bit 1 - Interrupt Mask on line 1"]
            #[inline]
            pub fn mr1(&mut self) -> _MR1W {
                _MR1W { w: self }
            }
            #[doc = "Bit 2 - Interrupt Mask on line 2"]
            #[inline]
            pub fn mr2(&mut self) -> _MR2W {
                _MR2W { w: self }
            }
            #[doc = "Bit 3 - Interrupt Mask on line 3"]
            #[inline]
            pub fn mr3(&mut self) -> _MR3W {
                _MR3W { w: self }
            }
            #[doc = "Bit 4 - Interrupt Mask on line 4"]
            #[inline]
            pub fn mr4(&mut self) -> _MR4W {
                _MR4W { w: self }
            }
            #[doc = "Bit 5 - Interrupt Mask on line 5"]
            #[inline]
            pub fn mr5(&mut self) -> _MR5W {
                _MR5W { w: self }
            }
            #[doc = "Bit 6 - Interrupt Mask on line 6"]
            #[inline]
            pub fn mr6(&mut self) -> _MR6W {
                _MR6W { w: self }
            }
            #[doc = "Bit 7 - Interrupt Mask on line 7"]
            #[inline]
            pub fn mr7(&mut self) -> _MR7W {
                _MR7W { w: self }
            }
            #[doc = "Bit 8 - Interrupt Mask on line 8"]
            #[inline]
            pub fn mr8(&mut self) -> _MR8W {
                _MR8W { w: self }
            }
            #[doc = "Bit 9 - Interrupt Mask on line 9"]
            #[inline]
            pub fn mr9(&mut self) -> _MR9W {
                _MR9W { w: self }
            }
            #[doc = "Bit 10 - Interrupt Mask on line 10"]
            #[inline]
            pub fn mr10(&mut self) -> _MR10W {
                _MR10W { w: self }
            }
            #[doc = "Bit 11 - Interrupt Mask on line 11"]
            #[inline]
            pub fn mr11(&mut self) -> _MR11W {
                _MR11W { w: self }
            }
            #[doc = "Bit 12 - Interrupt Mask on line 12"]
            #[inline]
            pub fn mr12(&mut self) -> _MR12W {
                _MR12W { w: self }
            }
            #[doc = "Bit 13 - Interrupt Mask on line 13"]
            #[inline]
            pub fn mr13(&mut self) -> _MR13W {
                _MR13W { w: self }
            }
            #[doc = "Bit 14 - Interrupt Mask on line 14"]
            #[inline]
            pub fn mr14(&mut self) -> _MR14W {
                _MR14W { w: self }
            }
            #[doc = "Bit 15 - Interrupt Mask on line 15"]
            #[inline]
            pub fn mr15(&mut self) -> _MR15W {
                _MR15W { w: self }
            }
            #[doc = "Bit 16 - Interrupt Mask on line 16"]
            #[inline]
            pub fn mr16(&mut self) -> _MR16W {
                _MR16W { w: self }
            }
            #[doc = "Bit 17 - Interrupt Mask on line 17"]
            #[inline]
            pub fn mr17(&mut self) -> _MR17W {
                _MR17W { w: self }
            }
        }
    }
    #[doc = "Event mask register (EXTI_EMR)"]
    pub struct EMR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Event mask register (EXTI_EMR)"]
    pub mod emr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EMR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR0R {
            bits: bool,
        }
        impl MR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR1R {
            bits: bool,
        }
        impl MR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR2R {
            bits: bool,
        }
        impl MR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR3R {
            bits: bool,
        }
        impl MR3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR4R {
            bits: bool,
        }
        impl MR4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR5R {
            bits: bool,
        }
        impl MR5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR6R {
            bits: bool,
        }
        impl MR6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR7R {
            bits: bool,
        }
        impl MR7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR8R {
            bits: bool,
        }
        impl MR8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR9R {
            bits: bool,
        }
        impl MR9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR10R {
            bits: bool,
        }
        impl MR10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR11R {
            bits: bool,
        }
        impl MR11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR12R {
            bits: bool,
        }
        impl MR12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR13R {
            bits: bool,
        }
        impl MR13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR14R {
            bits: bool,
        }
        impl MR14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR15R {
            bits: bool,
        }
        impl MR15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR16R {
            bits: bool,
        }
        impl MR16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR17R {
            bits: bool,
        }
        impl MR17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Event Mask on line 0"]
            #[inline]
            pub fn mr0(&self) -> MR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR0R { bits }
            }
            #[doc = "Bit 1 - Event Mask on line 1"]
            #[inline]
            pub fn mr1(&self) -> MR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR1R { bits }
            }
            #[doc = "Bit 2 - Event Mask on line 2"]
            #[inline]
            pub fn mr2(&self) -> MR2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR2R { bits }
            }
            #[doc = "Bit 3 - Event Mask on line 3"]
            #[inline]
            pub fn mr3(&self) -> MR3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR3R { bits }
            }
            #[doc = "Bit 4 - Event Mask on line 4"]
            #[inline]
            pub fn mr4(&self) -> MR4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR4R { bits }
            }
            #[doc = "Bit 5 - Event Mask on line 5"]
            #[inline]
            pub fn mr5(&self) -> MR5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR5R { bits }
            }
            #[doc = "Bit 6 - Event Mask on line 6"]
            #[inline]
            pub fn mr6(&self) -> MR6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR6R { bits }
            }
            #[doc = "Bit 7 - Event Mask on line 7"]
            #[inline]
            pub fn mr7(&self) -> MR7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR7R { bits }
            }
            #[doc = "Bit 8 - Event Mask on line 8"]
            #[inline]
            pub fn mr8(&self) -> MR8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR8R { bits }
            }
            #[doc = "Bit 9 - Event Mask on line 9"]
            #[inline]
            pub fn mr9(&self) -> MR9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR9R { bits }
            }
            #[doc = "Bit 10 - Event Mask on line 10"]
            #[inline]
            pub fn mr10(&self) -> MR10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR10R { bits }
            }
            #[doc = "Bit 11 - Event Mask on line 11"]
            #[inline]
            pub fn mr11(&self) -> MR11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR11R { bits }
            }
            #[doc = "Bit 12 - Event Mask on line 12"]
            #[inline]
            pub fn mr12(&self) -> MR12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR12R { bits }
            }
            #[doc = "Bit 13 - Event Mask on line 13"]
            #[inline]
            pub fn mr13(&self) -> MR13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR13R { bits }
            }
            #[doc = "Bit 14 - Event Mask on line 14"]
            #[inline]
            pub fn mr14(&self) -> MR14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR14R { bits }
            }
            #[doc = "Bit 15 - Event Mask on line 15"]
            #[inline]
            pub fn mr15(&self) -> MR15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR15R { bits }
            }
            #[doc = "Bit 16 - Event Mask on line 16"]
            #[inline]
            pub fn mr16(&self) -> MR16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR16R { bits }
            }
            #[doc = "Bit 17 - Event Mask on line 17"]
            #[inline]
            pub fn mr17(&self) -> MR17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR17R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Event Mask on line 0"]
            #[inline]
            pub fn mr0(&mut self) -> _MR0W {
                _MR0W { w: self }
            }
            #[doc = "Bit 1 - Event Mask on line 1"]
            #[inline]
            pub fn mr1(&mut self) -> _MR1W {
                _MR1W { w: self }
            }
            #[doc = "Bit 2 - Event Mask on line 2"]
            #[inline]
            pub fn mr2(&mut self) -> _MR2W {
                _MR2W { w: self }
            }
            #[doc = "Bit 3 - Event Mask on line 3"]
            #[inline]
            pub fn mr3(&mut self) -> _MR3W {
                _MR3W { w: self }
            }
            #[doc = "Bit 4 - Event Mask on line 4"]
            #[inline]
            pub fn mr4(&mut self) -> _MR4W {
                _MR4W { w: self }
            }
            #[doc = "Bit 5 - Event Mask on line 5"]
            #[inline]
            pub fn mr5(&mut self) -> _MR5W {
                _MR5W { w: self }
            }
            #[doc = "Bit 6 - Event Mask on line 6"]
            #[inline]
            pub fn mr6(&mut self) -> _MR6W {
                _MR6W { w: self }
            }
            #[doc = "Bit 7 - Event Mask on line 7"]
            #[inline]
            pub fn mr7(&mut self) -> _MR7W {
                _MR7W { w: self }
            }
            #[doc = "Bit 8 - Event Mask on line 8"]
            #[inline]
            pub fn mr8(&mut self) -> _MR8W {
                _MR8W { w: self }
            }
            #[doc = "Bit 9 - Event Mask on line 9"]
            #[inline]
            pub fn mr9(&mut self) -> _MR9W {
                _MR9W { w: self }
            }
            #[doc = "Bit 10 - Event Mask on line 10"]
            #[inline]
            pub fn mr10(&mut self) -> _MR10W {
                _MR10W { w: self }
            }
            #[doc = "Bit 11 - Event Mask on line 11"]
            #[inline]
            pub fn mr11(&mut self) -> _MR11W {
                _MR11W { w: self }
            }
            #[doc = "Bit 12 - Event Mask on line 12"]
            #[inline]
            pub fn mr12(&mut self) -> _MR12W {
                _MR12W { w: self }
            }
            #[doc = "Bit 13 - Event Mask on line 13"]
            #[inline]
            pub fn mr13(&mut self) -> _MR13W {
                _MR13W { w: self }
            }
            #[doc = "Bit 14 - Event Mask on line 14"]
            #[inline]
            pub fn mr14(&mut self) -> _MR14W {
                _MR14W { w: self }
            }
            #[doc = "Bit 15 - Event Mask on line 15"]
            #[inline]
            pub fn mr15(&mut self) -> _MR15W {
                _MR15W { w: self }
            }
            #[doc = "Bit 16 - Event Mask on line 16"]
            #[inline]
            pub fn mr16(&mut self) -> _MR16W {
                _MR16W { w: self }
            }
            #[doc = "Bit 17 - Event Mask on line 17"]
            #[inline]
            pub fn mr17(&mut self) -> _MR17W {
                _MR17W { w: self }
            }
        }
    }
    #[doc = "Rising Trigger selection register (EXTI_RTSR)"]
    pub struct RTSR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Rising Trigger selection register (EXTI_RTSR)"]
    pub mod rtsr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RTSR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR0R {
            bits: bool,
        }
        impl TR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR1R {
            bits: bool,
        }
        impl TR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR2R {
            bits: bool,
        }
        impl TR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR3R {
            bits: bool,
        }
        impl TR3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR4R {
            bits: bool,
        }
        impl TR4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR5R {
            bits: bool,
        }
        impl TR5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR6R {
            bits: bool,
        }
        impl TR6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR7R {
            bits: bool,
        }
        impl TR7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR8R {
            bits: bool,
        }
        impl TR8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR9R {
            bits: bool,
        }
        impl TR9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR10R {
            bits: bool,
        }
        impl TR10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR11R {
            bits: bool,
        }
        impl TR11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR12R {
            bits: bool,
        }
        impl TR12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR13R {
            bits: bool,
        }
        impl TR13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR14R {
            bits: bool,
        }
        impl TR14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR15R {
            bits: bool,
        }
        impl TR15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR16R {
            bits: bool,
        }
        impl TR16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR17R {
            bits: bool,
        }
        impl TR17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Rising trigger event configuration of line 0"]
            #[inline]
            pub fn tr0(&self) -> TR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR0R { bits }
            }
            #[doc = "Bit 1 - Rising trigger event configuration of line 1"]
            #[inline]
            pub fn tr1(&self) -> TR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR1R { bits }
            }
            #[doc = "Bit 2 - Rising trigger event configuration of line 2"]
            #[inline]
            pub fn tr2(&self) -> TR2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR2R { bits }
            }
            #[doc = "Bit 3 - Rising trigger event configuration of line 3"]
            #[inline]
            pub fn tr3(&self) -> TR3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR3R { bits }
            }
            #[doc = "Bit 4 - Rising trigger event configuration of line 4"]
            #[inline]
            pub fn tr4(&self) -> TR4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR4R { bits }
            }
            #[doc = "Bit 5 - Rising trigger event configuration of line 5"]
            #[inline]
            pub fn tr5(&self) -> TR5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR5R { bits }
            }
            #[doc = "Bit 6 - Rising trigger event configuration of line 6"]
            #[inline]
            pub fn tr6(&self) -> TR6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR6R { bits }
            }
            #[doc = "Bit 7 - Rising trigger event configuration of line 7"]
            #[inline]
            pub fn tr7(&self) -> TR7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR7R { bits }
            }
            #[doc = "Bit 8 - Rising trigger event configuration of line 8"]
            #[inline]
            pub fn tr8(&self) -> TR8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR8R { bits }
            }
            #[doc = "Bit 9 - Rising trigger event configuration of line 9"]
            #[inline]
            pub fn tr9(&self) -> TR9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR9R { bits }
            }
            #[doc = "Bit 10 - Rising trigger event configuration of line 10"]
            #[inline]
            pub fn tr10(&self) -> TR10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR10R { bits }
            }
            #[doc = "Bit 11 - Rising trigger event configuration of line 11"]
            #[inline]
            pub fn tr11(&self) -> TR11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR11R { bits }
            }
            #[doc = "Bit 12 - Rising trigger event configuration of line 12"]
            #[inline]
            pub fn tr12(&self) -> TR12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR12R { bits }
            }
            #[doc = "Bit 13 - Rising trigger event configuration of line 13"]
            #[inline]
            pub fn tr13(&self) -> TR13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR13R { bits }
            }
            #[doc = "Bit 14 - Rising trigger event configuration of line 14"]
            #[inline]
            pub fn tr14(&self) -> TR14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR14R { bits }
            }
            #[doc = "Bit 15 - Rising trigger event configuration of line 15"]
            #[inline]
            pub fn tr15(&self) -> TR15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR15R { bits }
            }
            #[doc = "Bit 16 - Rising trigger event configuration of line 16"]
            #[inline]
            pub fn tr16(&self) -> TR16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR16R { bits }
            }
            #[doc = "Bit 17 - Rising trigger event configuration of line 17"]
            #[inline]
            pub fn tr17(&self) -> TR17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR17R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Rising trigger event configuration of line 0"]
            #[inline]
            pub fn tr0(&mut self) -> _TR0W {
                _TR0W { w: self }
            }
            #[doc = "Bit 1 - Rising trigger event configuration of line 1"]
            #[inline]
            pub fn tr1(&mut self) -> _TR1W {
                _TR1W { w: self }
            }
            #[doc = "Bit 2 - Rising trigger event configuration of line 2"]
            #[inline]
            pub fn tr2(&mut self) -> _TR2W {
                _TR2W { w: self }
            }
            #[doc = "Bit 3 - Rising trigger event configuration of line 3"]
            #[inline]
            pub fn tr3(&mut self) -> _TR3W {
                _TR3W { w: self }
            }
            #[doc = "Bit 4 - Rising trigger event configuration of line 4"]
            #[inline]
            pub fn tr4(&mut self) -> _TR4W {
                _TR4W { w: self }
            }
            #[doc = "Bit 5 - Rising trigger event configuration of line 5"]
            #[inline]
            pub fn tr5(&mut self) -> _TR5W {
                _TR5W { w: self }
            }
            #[doc = "Bit 6 - Rising trigger event configuration of line 6"]
            #[inline]
            pub fn tr6(&mut self) -> _TR6W {
                _TR6W { w: self }
            }
            #[doc = "Bit 7 - Rising trigger event configuration of line 7"]
            #[inline]
            pub fn tr7(&mut self) -> _TR7W {
                _TR7W { w: self }
            }
            #[doc = "Bit 8 - Rising trigger event configuration of line 8"]
            #[inline]
            pub fn tr8(&mut self) -> _TR8W {
                _TR8W { w: self }
            }
            #[doc = "Bit 9 - Rising trigger event configuration of line 9"]
            #[inline]
            pub fn tr9(&mut self) -> _TR9W {
                _TR9W { w: self }
            }
            #[doc = "Bit 10 - Rising trigger event configuration of line 10"]
            #[inline]
            pub fn tr10(&mut self) -> _TR10W {
                _TR10W { w: self }
            }
            #[doc = "Bit 11 - Rising trigger event configuration of line 11"]
            #[inline]
            pub fn tr11(&mut self) -> _TR11W {
                _TR11W { w: self }
            }
            #[doc = "Bit 12 - Rising trigger event configuration of line 12"]
            #[inline]
            pub fn tr12(&mut self) -> _TR12W {
                _TR12W { w: self }
            }
            #[doc = "Bit 13 - Rising trigger event configuration of line 13"]
            #[inline]
            pub fn tr13(&mut self) -> _TR13W {
                _TR13W { w: self }
            }
            #[doc = "Bit 14 - Rising trigger event configuration of line 14"]
            #[inline]
            pub fn tr14(&mut self) -> _TR14W {
                _TR14W { w: self }
            }
            #[doc = "Bit 15 - Rising trigger event configuration of line 15"]
            #[inline]
            pub fn tr15(&mut self) -> _TR15W {
                _TR15W { w: self }
            }
            #[doc = "Bit 16 - Rising trigger event configuration of line 16"]
            #[inline]
            pub fn tr16(&mut self) -> _TR16W {
                _TR16W { w: self }
            }
            #[doc = "Bit 17 - Rising trigger event configuration of line 17"]
            #[inline]
            pub fn tr17(&mut self) -> _TR17W {
                _TR17W { w: self }
            }
        }
    }
    #[doc = "Falling Trigger selection register (EXTI_FTSR)"]
    pub struct FTSR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Falling Trigger selection register (EXTI_FTSR)"]
    pub mod ftsr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FTSR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR0R {
            bits: bool,
        }
        impl TR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR1R {
            bits: bool,
        }
        impl TR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR2R {
            bits: bool,
        }
        impl TR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR3R {
            bits: bool,
        }
        impl TR3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR4R {
            bits: bool,
        }
        impl TR4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR5R {
            bits: bool,
        }
        impl TR5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR6R {
            bits: bool,
        }
        impl TR6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR7R {
            bits: bool,
        }
        impl TR7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR8R {
            bits: bool,
        }
        impl TR8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR9R {
            bits: bool,
        }
        impl TR9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR10R {
            bits: bool,
        }
        impl TR10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR11R {
            bits: bool,
        }
        impl TR11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR12R {
            bits: bool,
        }
        impl TR12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR13R {
            bits: bool,
        }
        impl TR13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR14R {
            bits: bool,
        }
        impl TR14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR15R {
            bits: bool,
        }
        impl TR15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR16R {
            bits: bool,
        }
        impl TR16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR17R {
            bits: bool,
        }
        impl TR17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TR17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TR17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Falling trigger event configuration of line 0"]
            #[inline]
            pub fn tr0(&self) -> TR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR0R { bits }
            }
            #[doc = "Bit 1 - Falling trigger event configuration of line 1"]
            #[inline]
            pub fn tr1(&self) -> TR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR1R { bits }
            }
            #[doc = "Bit 2 - Falling trigger event configuration of line 2"]
            #[inline]
            pub fn tr2(&self) -> TR2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR2R { bits }
            }
            #[doc = "Bit 3 - Falling trigger event configuration of line 3"]
            #[inline]
            pub fn tr3(&self) -> TR3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR3R { bits }
            }
            #[doc = "Bit 4 - Falling trigger event configuration of line 4"]
            #[inline]
            pub fn tr4(&self) -> TR4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR4R { bits }
            }
            #[doc = "Bit 5 - Falling trigger event configuration of line 5"]
            #[inline]
            pub fn tr5(&self) -> TR5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR5R { bits }
            }
            #[doc = "Bit 6 - Falling trigger event configuration of line 6"]
            #[inline]
            pub fn tr6(&self) -> TR6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR6R { bits }
            }
            #[doc = "Bit 7 - Falling trigger event configuration of line 7"]
            #[inline]
            pub fn tr7(&self) -> TR7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR7R { bits }
            }
            #[doc = "Bit 8 - Falling trigger event configuration of line 8"]
            #[inline]
            pub fn tr8(&self) -> TR8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR8R { bits }
            }
            #[doc = "Bit 9 - Falling trigger event configuration of line 9"]
            #[inline]
            pub fn tr9(&self) -> TR9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR9R { bits }
            }
            #[doc = "Bit 10 - Falling trigger event configuration of line 10"]
            #[inline]
            pub fn tr10(&self) -> TR10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR10R { bits }
            }
            #[doc = "Bit 11 - Falling trigger event configuration of line 11"]
            #[inline]
            pub fn tr11(&self) -> TR11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR11R { bits }
            }
            #[doc = "Bit 12 - Falling trigger event configuration of line 12"]
            #[inline]
            pub fn tr12(&self) -> TR12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR12R { bits }
            }
            #[doc = "Bit 13 - Falling trigger event configuration of line 13"]
            #[inline]
            pub fn tr13(&self) -> TR13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR13R { bits }
            }
            #[doc = "Bit 14 - Falling trigger event configuration of line 14"]
            #[inline]
            pub fn tr14(&self) -> TR14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR14R { bits }
            }
            #[doc = "Bit 15 - Falling trigger event configuration of line 15"]
            #[inline]
            pub fn tr15(&self) -> TR15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR15R { bits }
            }
            #[doc = "Bit 16 - Falling trigger event configuration of line 16"]
            #[inline]
            pub fn tr16(&self) -> TR16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR16R { bits }
            }
            #[doc = "Bit 17 - Falling trigger event configuration of line 17"]
            #[inline]
            pub fn tr17(&self) -> TR17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TR17R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Falling trigger event configuration of line 0"]
            #[inline]
            pub fn tr0(&mut self) -> _TR0W {
                _TR0W { w: self }
            }
            #[doc = "Bit 1 - Falling trigger event configuration of line 1"]
            #[inline]
            pub fn tr1(&mut self) -> _TR1W {
                _TR1W { w: self }
            }
            #[doc = "Bit 2 - Falling trigger event configuration of line 2"]
            #[inline]
            pub fn tr2(&mut self) -> _TR2W {
                _TR2W { w: self }
            }
            #[doc = "Bit 3 - Falling trigger event configuration of line 3"]
            #[inline]
            pub fn tr3(&mut self) -> _TR3W {
                _TR3W { w: self }
            }
            #[doc = "Bit 4 - Falling trigger event configuration of line 4"]
            #[inline]
            pub fn tr4(&mut self) -> _TR4W {
                _TR4W { w: self }
            }
            #[doc = "Bit 5 - Falling trigger event configuration of line 5"]
            #[inline]
            pub fn tr5(&mut self) -> _TR5W {
                _TR5W { w: self }
            }
            #[doc = "Bit 6 - Falling trigger event configuration of line 6"]
            #[inline]
            pub fn tr6(&mut self) -> _TR6W {
                _TR6W { w: self }
            }
            #[doc = "Bit 7 - Falling trigger event configuration of line 7"]
            #[inline]
            pub fn tr7(&mut self) -> _TR7W {
                _TR7W { w: self }
            }
            #[doc = "Bit 8 - Falling trigger event configuration of line 8"]
            #[inline]
            pub fn tr8(&mut self) -> _TR8W {
                _TR8W { w: self }
            }
            #[doc = "Bit 9 - Falling trigger event configuration of line 9"]
            #[inline]
            pub fn tr9(&mut self) -> _TR9W {
                _TR9W { w: self }
            }
            #[doc = "Bit 10 - Falling trigger event configuration of line 10"]
            #[inline]
            pub fn tr10(&mut self) -> _TR10W {
                _TR10W { w: self }
            }
            #[doc = "Bit 11 - Falling trigger event configuration of line 11"]
            #[inline]
            pub fn tr11(&mut self) -> _TR11W {
                _TR11W { w: self }
            }
            #[doc = "Bit 12 - Falling trigger event configuration of line 12"]
            #[inline]
            pub fn tr12(&mut self) -> _TR12W {
                _TR12W { w: self }
            }
            #[doc = "Bit 13 - Falling trigger event configuration of line 13"]
            #[inline]
            pub fn tr13(&mut self) -> _TR13W {
                _TR13W { w: self }
            }
            #[doc = "Bit 14 - Falling trigger event configuration of line 14"]
            #[inline]
            pub fn tr14(&mut self) -> _TR14W {
                _TR14W { w: self }
            }
            #[doc = "Bit 15 - Falling trigger event configuration of line 15"]
            #[inline]
            pub fn tr15(&mut self) -> _TR15W {
                _TR15W { w: self }
            }
            #[doc = "Bit 16 - Falling trigger event configuration of line 16"]
            #[inline]
            pub fn tr16(&mut self) -> _TR16W {
                _TR16W { w: self }
            }
            #[doc = "Bit 17 - Falling trigger event configuration of line 17"]
            #[inline]
            pub fn tr17(&mut self) -> _TR17W {
                _TR17W { w: self }
            }
        }
    }
    #[doc = "Software interrupt event register (EXTI_SWIER)"]
    pub struct SWIER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Software interrupt event register (EXTI_SWIER)"]
    pub mod swier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SWIER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER0R {
            bits: bool,
        }
        impl SWIER0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER1R {
            bits: bool,
        }
        impl SWIER1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER2R {
            bits: bool,
        }
        impl SWIER2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER3R {
            bits: bool,
        }
        impl SWIER3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER4R {
            bits: bool,
        }
        impl SWIER4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER5R {
            bits: bool,
        }
        impl SWIER5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER6R {
            bits: bool,
        }
        impl SWIER6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER7R {
            bits: bool,
        }
        impl SWIER7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER8R {
            bits: bool,
        }
        impl SWIER8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER9R {
            bits: bool,
        }
        impl SWIER9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER10R {
            bits: bool,
        }
        impl SWIER10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER11R {
            bits: bool,
        }
        impl SWIER11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER12R {
            bits: bool,
        }
        impl SWIER12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER13R {
            bits: bool,
        }
        impl SWIER13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER14R {
            bits: bool,
        }
        impl SWIER14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER15R {
            bits: bool,
        }
        impl SWIER15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER16R {
            bits: bool,
        }
        impl SWIER16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWIER17R {
            bits: bool,
        }
        impl SWIER17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWIER17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWIER17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Software Interrupt on line 0"]
            #[inline]
            pub fn swier0(&self) -> SWIER0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER0R { bits }
            }
            #[doc = "Bit 1 - Software Interrupt on line 1"]
            #[inline]
            pub fn swier1(&self) -> SWIER1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER1R { bits }
            }
            #[doc = "Bit 2 - Software Interrupt on line 2"]
            #[inline]
            pub fn swier2(&self) -> SWIER2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER2R { bits }
            }
            #[doc = "Bit 3 - Software Interrupt on line 3"]
            #[inline]
            pub fn swier3(&self) -> SWIER3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER3R { bits }
            }
            #[doc = "Bit 4 - Software Interrupt on line 4"]
            #[inline]
            pub fn swier4(&self) -> SWIER4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER4R { bits }
            }
            #[doc = "Bit 5 - Software Interrupt on line 5"]
            #[inline]
            pub fn swier5(&self) -> SWIER5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER5R { bits }
            }
            #[doc = "Bit 6 - Software Interrupt on line 6"]
            #[inline]
            pub fn swier6(&self) -> SWIER6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER6R { bits }
            }
            #[doc = "Bit 7 - Software Interrupt on line 7"]
            #[inline]
            pub fn swier7(&self) -> SWIER7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER7R { bits }
            }
            #[doc = "Bit 8 - Software Interrupt on line 8"]
            #[inline]
            pub fn swier8(&self) -> SWIER8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER8R { bits }
            }
            #[doc = "Bit 9 - Software Interrupt on line 9"]
            #[inline]
            pub fn swier9(&self) -> SWIER9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER9R { bits }
            }
            #[doc = "Bit 10 - Software Interrupt on line 10"]
            #[inline]
            pub fn swier10(&self) -> SWIER10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER10R { bits }
            }
            #[doc = "Bit 11 - Software Interrupt on line 11"]
            #[inline]
            pub fn swier11(&self) -> SWIER11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER11R { bits }
            }
            #[doc = "Bit 12 - Software Interrupt on line 12"]
            #[inline]
            pub fn swier12(&self) -> SWIER12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER12R { bits }
            }
            #[doc = "Bit 13 - Software Interrupt on line 13"]
            #[inline]
            pub fn swier13(&self) -> SWIER13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER13R { bits }
            }
            #[doc = "Bit 14 - Software Interrupt on line 14"]
            #[inline]
            pub fn swier14(&self) -> SWIER14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER14R { bits }
            }
            #[doc = "Bit 15 - Software Interrupt on line 15"]
            #[inline]
            pub fn swier15(&self) -> SWIER15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER15R { bits }
            }
            #[doc = "Bit 16 - Software Interrupt on line 16"]
            #[inline]
            pub fn swier16(&self) -> SWIER16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER16R { bits }
            }
            #[doc = "Bit 17 - Software Interrupt on line 17"]
            #[inline]
            pub fn swier17(&self) -> SWIER17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWIER17R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Interrupt on line 0"]
            #[inline]
            pub fn swier0(&mut self) -> _SWIER0W {
                _SWIER0W { w: self }
            }
            #[doc = "Bit 1 - Software Interrupt on line 1"]
            #[inline]
            pub fn swier1(&mut self) -> _SWIER1W {
                _SWIER1W { w: self }
            }
            #[doc = "Bit 2 - Software Interrupt on line 2"]
            #[inline]
            pub fn swier2(&mut self) -> _SWIER2W {
                _SWIER2W { w: self }
            }
            #[doc = "Bit 3 - Software Interrupt on line 3"]
            #[inline]
            pub fn swier3(&mut self) -> _SWIER3W {
                _SWIER3W { w: self }
            }
            #[doc = "Bit 4 - Software Interrupt on line 4"]
            #[inline]
            pub fn swier4(&mut self) -> _SWIER4W {
                _SWIER4W { w: self }
            }
            #[doc = "Bit 5 - Software Interrupt on line 5"]
            #[inline]
            pub fn swier5(&mut self) -> _SWIER5W {
                _SWIER5W { w: self }
            }
            #[doc = "Bit 6 - Software Interrupt on line 6"]
            #[inline]
            pub fn swier6(&mut self) -> _SWIER6W {
                _SWIER6W { w: self }
            }
            #[doc = "Bit 7 - Software Interrupt on line 7"]
            #[inline]
            pub fn swier7(&mut self) -> _SWIER7W {
                _SWIER7W { w: self }
            }
            #[doc = "Bit 8 - Software Interrupt on line 8"]
            #[inline]
            pub fn swier8(&mut self) -> _SWIER8W {
                _SWIER8W { w: self }
            }
            #[doc = "Bit 9 - Software Interrupt on line 9"]
            #[inline]
            pub fn swier9(&mut self) -> _SWIER9W {
                _SWIER9W { w: self }
            }
            #[doc = "Bit 10 - Software Interrupt on line 10"]
            #[inline]
            pub fn swier10(&mut self) -> _SWIER10W {
                _SWIER10W { w: self }
            }
            #[doc = "Bit 11 - Software Interrupt on line 11"]
            #[inline]
            pub fn swier11(&mut self) -> _SWIER11W {
                _SWIER11W { w: self }
            }
            #[doc = "Bit 12 - Software Interrupt on line 12"]
            #[inline]
            pub fn swier12(&mut self) -> _SWIER12W {
                _SWIER12W { w: self }
            }
            #[doc = "Bit 13 - Software Interrupt on line 13"]
            #[inline]
            pub fn swier13(&mut self) -> _SWIER13W {
                _SWIER13W { w: self }
            }
            #[doc = "Bit 14 - Software Interrupt on line 14"]
            #[inline]
            pub fn swier14(&mut self) -> _SWIER14W {
                _SWIER14W { w: self }
            }
            #[doc = "Bit 15 - Software Interrupt on line 15"]
            #[inline]
            pub fn swier15(&mut self) -> _SWIER15W {
                _SWIER15W { w: self }
            }
            #[doc = "Bit 16 - Software Interrupt on line 16"]
            #[inline]
            pub fn swier16(&mut self) -> _SWIER16W {
                _SWIER16W { w: self }
            }
            #[doc = "Bit 17 - Software Interrupt on line 17"]
            #[inline]
            pub fn swier17(&mut self) -> _SWIER17W {
                _SWIER17W { w: self }
            }
        }
    }
    #[doc = "Pending register (EXTI_PR)"]
    pub struct PR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pending register (EXTI_PR)"]
    pub mod pr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR0R {
            bits: bool,
        }
        impl PR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR1R {
            bits: bool,
        }
        impl PR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR2R {
            bits: bool,
        }
        impl PR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR3R {
            bits: bool,
        }
        impl PR3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR4R {
            bits: bool,
        }
        impl PR4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR5R {
            bits: bool,
        }
        impl PR5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR6R {
            bits: bool,
        }
        impl PR6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR7R {
            bits: bool,
        }
        impl PR7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR8R {
            bits: bool,
        }
        impl PR8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR9R {
            bits: bool,
        }
        impl PR9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR10R {
            bits: bool,
        }
        impl PR10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR11R {
            bits: bool,
        }
        impl PR11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR12R {
            bits: bool,
        }
        impl PR12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR13R {
            bits: bool,
        }
        impl PR13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR14R {
            bits: bool,
        }
        impl PR14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR15R {
            bits: bool,
        }
        impl PR15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR16R {
            bits: bool,
        }
        impl PR16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PR17R {
            bits: bool,
        }
        impl PR17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Pending bit 0"]
            #[inline]
            pub fn pr0(&self) -> PR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR0R { bits }
            }
            #[doc = "Bit 1 - Pending bit 1"]
            #[inline]
            pub fn pr1(&self) -> PR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR1R { bits }
            }
            #[doc = "Bit 2 - Pending bit 2"]
            #[inline]
            pub fn pr2(&self) -> PR2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR2R { bits }
            }
            #[doc = "Bit 3 - Pending bit 3"]
            #[inline]
            pub fn pr3(&self) -> PR3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR3R { bits }
            }
            #[doc = "Bit 4 - Pending bit 4"]
            #[inline]
            pub fn pr4(&self) -> PR4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR4R { bits }
            }
            #[doc = "Bit 5 - Pending bit 5"]
            #[inline]
            pub fn pr5(&self) -> PR5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR5R { bits }
            }
            #[doc = "Bit 6 - Pending bit 6"]
            #[inline]
            pub fn pr6(&self) -> PR6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR6R { bits }
            }
            #[doc = "Bit 7 - Pending bit 7"]
            #[inline]
            pub fn pr7(&self) -> PR7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR7R { bits }
            }
            #[doc = "Bit 8 - Pending bit 8"]
            #[inline]
            pub fn pr8(&self) -> PR8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR8R { bits }
            }
            #[doc = "Bit 9 - Pending bit 9"]
            #[inline]
            pub fn pr9(&self) -> PR9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR9R { bits }
            }
            #[doc = "Bit 10 - Pending bit 10"]
            #[inline]
            pub fn pr10(&self) -> PR10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR10R { bits }
            }
            #[doc = "Bit 11 - Pending bit 11"]
            #[inline]
            pub fn pr11(&self) -> PR11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR11R { bits }
            }
            #[doc = "Bit 12 - Pending bit 12"]
            #[inline]
            pub fn pr12(&self) -> PR12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR12R { bits }
            }
            #[doc = "Bit 13 - Pending bit 13"]
            #[inline]
            pub fn pr13(&self) -> PR13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR13R { bits }
            }
            #[doc = "Bit 14 - Pending bit 14"]
            #[inline]
            pub fn pr14(&self) -> PR14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR14R { bits }
            }
            #[doc = "Bit 15 - Pending bit 15"]
            #[inline]
            pub fn pr15(&self) -> PR15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR15R { bits }
            }
            #[doc = "Bit 16 - Pending bit 16"]
            #[inline]
            pub fn pr16(&self) -> PR16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR16R { bits }
            }
            #[doc = "Bit 17 - Pending bit 17"]
            #[inline]
            pub fn pr17(&self) -> PR17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PR17R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Pending bit 0"]
            #[inline]
            pub fn pr0(&mut self) -> _PR0W {
                _PR0W { w: self }
            }
            #[doc = "Bit 1 - Pending bit 1"]
            #[inline]
            pub fn pr1(&mut self) -> _PR1W {
                _PR1W { w: self }
            }
            #[doc = "Bit 2 - Pending bit 2"]
            #[inline]
            pub fn pr2(&mut self) -> _PR2W {
                _PR2W { w: self }
            }
            #[doc = "Bit 3 - Pending bit 3"]
            #[inline]
            pub fn pr3(&mut self) -> _PR3W {
                _PR3W { w: self }
            }
            #[doc = "Bit 4 - Pending bit 4"]
            #[inline]
            pub fn pr4(&mut self) -> _PR4W {
                _PR4W { w: self }
            }
            #[doc = "Bit 5 - Pending bit 5"]
            #[inline]
            pub fn pr5(&mut self) -> _PR5W {
                _PR5W { w: self }
            }
            #[doc = "Bit 6 - Pending bit 6"]
            #[inline]
            pub fn pr6(&mut self) -> _PR6W {
                _PR6W { w: self }
            }
            #[doc = "Bit 7 - Pending bit 7"]
            #[inline]
            pub fn pr7(&mut self) -> _PR7W {
                _PR7W { w: self }
            }
            #[doc = "Bit 8 - Pending bit 8"]
            #[inline]
            pub fn pr8(&mut self) -> _PR8W {
                _PR8W { w: self }
            }
            #[doc = "Bit 9 - Pending bit 9"]
            #[inline]
            pub fn pr9(&mut self) -> _PR9W {
                _PR9W { w: self }
            }
            #[doc = "Bit 10 - Pending bit 10"]
            #[inline]
            pub fn pr10(&mut self) -> _PR10W {
                _PR10W { w: self }
            }
            #[doc = "Bit 11 - Pending bit 11"]
            #[inline]
            pub fn pr11(&mut self) -> _PR11W {
                _PR11W { w: self }
            }
            #[doc = "Bit 12 - Pending bit 12"]
            #[inline]
            pub fn pr12(&mut self) -> _PR12W {
                _PR12W { w: self }
            }
            #[doc = "Bit 13 - Pending bit 13"]
            #[inline]
            pub fn pr13(&mut self) -> _PR13W {
                _PR13W { w: self }
            }
            #[doc = "Bit 14 - Pending bit 14"]
            #[inline]
            pub fn pr14(&mut self) -> _PR14W {
                _PR14W { w: self }
            }
            #[doc = "Bit 15 - Pending bit 15"]
            #[inline]
            pub fn pr15(&mut self) -> _PR15W {
                _PR15W { w: self }
            }
            #[doc = "Bit 16 - Pending bit 16"]
            #[inline]
            pub fn pr16(&mut self) -> _PR16W {
                _PR16W { w: self }
            }
            #[doc = "Bit 17 - Pending bit 17"]
            #[inline]
            pub fn pr17(&mut self) -> _PR17W {
                _PR17W { w: self }
            }
        }
    }
}
#[doc = "DMA controller"]
#[cfg(feature = "dma1")]
pub struct DMA1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "dma1")]
unsafe impl Send for DMA1 {}
#[cfg(feature = "dma1")]
impl DMA1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const dma1::RegisterBlock {
        0x4002_0000 as *const _
    }
}
#[cfg(feature = "dma1")]
impl Deref for DMA1 {
    type Target = dma1::RegisterBlock;
    fn deref(&self) -> &dma1::RegisterBlock {
        unsafe { &*DMA1::ptr() }
    }
}
#[doc = "DMA controller"]
#[cfg(feature = "dma1")]
pub mod dma1 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - DMA interrupt status register (DMA_ISR)"]
        pub isr: ISR,
        #[doc = "0x04 - DMA interrupt flag clear register (DMA_IFCR)"]
        pub ifcr: IFCR,
        #[doc = "0x08 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch1: CH,
        _reserved0: [u8; 4usize],
        #[doc = "0x1c - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch2: CH,
        _reserved1: [u8; 4usize],
        #[doc = "0x30 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch3: CH,
        _reserved2: [u8; 4usize],
        #[doc = "0x44 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch4: CH,
        _reserved3: [u8; 4usize],
        #[doc = "0x58 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch5: CH,
        _reserved4: [u8; 4usize],
        #[doc = "0x6c - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch6: CH,
        _reserved5: [u8; 4usize],
        #[doc = "0x80 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
        pub ch7: CH,
    }
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct CH {
        #[doc = "0x00 - DMA channel configuration register (DMA_CCR)"]
        pub cr: self::ch::CR,
        #[doc = "0x04 - DMA channel 1 number of data register"]
        pub ndtr: self::ch::NDTR,
        #[doc = "0x08 - DMA channel 1 peripheral address register"]
        pub par: self::ch::PAR,
        #[doc = "0x0c - DMA channel 1 memory address register"]
        pub mar: self::ch::MAR,
    }
    #[doc = r" Register block"]
    #[doc = "Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers"]
    pub mod ch {
        #[doc = "DMA channel configuration register (DMA_CCR)"]
        pub struct CR {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "DMA channel configuration register (DMA_CCR)"]
        pub mod cr {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::CR {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits: bits };
                    let mut w = W { bits: bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = "Possible values of the field `EN`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum ENR {
                #[doc = "Channel disabled"]
                DISABLED,
                #[doc = "Channel enabled"]
                ENABLED,
            }
            impl ENR {
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    match *self {
                        ENR::DISABLED => false,
                        ENR::ENABLED => true,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: bool) -> ENR {
                    match value {
                        false => ENR::DISABLED,
                        true => ENR::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline]
                pub fn is_disabled(&self) -> bool {
                    *self == ENR::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline]
                pub fn is_enabled(&self) -> bool {
                    *self == ENR::ENABLED
                }
            }
            #[doc = "Possible values of the field `TCIE`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum TCIER {
                #[doc = "Transfer Complete interrupt disabled"]
                DISABLED,
                #[doc = "Transfer Complete interrupt enabled"]
                ENABLED,
            }
            impl TCIER {
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    match *self {
                        TCIER::DISABLED => false,
                        TCIER::ENABLED => true,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: bool) -> TCIER {
                    match value {
                        false => TCIER::DISABLED,
                        true => TCIER::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline]
                pub fn is_disabled(&self) -> bool {
                    *self == TCIER::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline]
                pub fn is_enabled(&self) -> bool {
                    *self == TCIER::ENABLED
                }
            }
            #[doc = "Possible values of the field `HTIE`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum HTIER {
                #[doc = "Half Transfer interrupt disabled"]
                DISABLED,
                #[doc = "Half Transfer interrupt enabled"]
                ENABLED,
            }
            impl HTIER {
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    match *self {
                        HTIER::DISABLED => false,
                        HTIER::ENABLED => true,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: bool) -> HTIER {
                    match value {
                        false => HTIER::DISABLED,
                        true => HTIER::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline]
                pub fn is_disabled(&self) -> bool {
                    *self == HTIER::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline]
                pub fn is_enabled(&self) -> bool {
                    *self == HTIER::ENABLED
                }
            }
            #[doc = "Possible values of the field `TEIE`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum TEIER {
                #[doc = "Transfer Error interrupt disabled"]
                DISABLED,
                #[doc = "Transfer Error interrupt enabled"]
                ENABLED,
            }
            impl TEIER {
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    match *self {
                        TEIER::DISABLED => false,
                        TEIER::ENABLED => true,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: bool) -> TEIER {
                    match value {
                        false => TEIER::DISABLED,
                        true => TEIER::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline]
                pub fn is_disabled(&self) -> bool {
                    *self == TEIER::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline]
                pub fn is_enabled(&self) -> bool {
                    *self == TEIER::ENABLED
                }
            }
            #[doc = "Possible values of the field `DIR`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum DIRR {
                #[doc = "Read from peripheral"]
                FROMPERIPHERAL,
                #[doc = "Read from memory"]
                FROMMEMORY,
            }
            impl DIRR {
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    match *self {
                        DIRR::FROMPERIPHERAL => false,
                        DIRR::FROMMEMORY => true,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: bool) -> DIRR {
                    match value {
                        false => DIRR::FROMPERIPHERAL,
                        true => DIRR::FROMMEMORY,
                    }
                }
                #[doc = "Checks if the value of the field is `FROMPERIPHERAL`"]
                #[inline]
                pub fn is_from_peripheral(&self) -> bool {
                    *self == DIRR::FROMPERIPHERAL
                }
                #[doc = "Checks if the value of the field is `FROMMEMORY`"]
                #[inline]
                pub fn is_from_memory(&self) -> bool {
                    *self == DIRR::FROMMEMORY
                }
            }
            #[doc = "Possible values of the field `CIRC`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum CIRCR {
                #[doc = "Circular buffer disabled"]
                DISABLED,
                #[doc = "Circular buffer enabled"]
                ENABLED,
            }
            impl CIRCR {
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    match *self {
                        CIRCR::DISABLED => false,
                        CIRCR::ENABLED => true,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: bool) -> CIRCR {
                    match value {
                        false => CIRCR::DISABLED,
                        true => CIRCR::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline]
                pub fn is_disabled(&self) -> bool {
                    *self == CIRCR::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline]
                pub fn is_enabled(&self) -> bool {
                    *self == CIRCR::ENABLED
                }
            }
            #[doc = "Possible values of the field `PINC`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum PINCR {
                #[doc = "Increment mode disabled"]
                DISABLED,
                #[doc = "Increment mode enabled"]
                ENABLED,
            }
            impl PINCR {
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    match *self {
                        PINCR::DISABLED => false,
                        PINCR::ENABLED => true,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: bool) -> PINCR {
                    match value {
                        false => PINCR::DISABLED,
                        true => PINCR::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline]
                pub fn is_disabled(&self) -> bool {
                    *self == PINCR::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline]
                pub fn is_enabled(&self) -> bool {
                    *self == PINCR::ENABLED
                }
            }
            #[doc = "Possible values of the field `MINC`"]
            pub type MINCR = PINCR;
            #[doc = "Possible values of the field `PSIZE`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum PSIZER {
                #[doc = "8-bit size"]
                BIT8,
                #[doc = "16-bit size"]
                BIT16,
                #[doc = "32-bit size"]
                BIT32,
                #[doc = r" Reserved"]
                _Reserved(u8),
            }
            impl PSIZER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    match *self {
                        PSIZER::BIT8 => 0,
                        PSIZER::BIT16 => 0x01,
                        PSIZER::BIT32 => 0x02,
                        PSIZER::_Reserved(bits) => bits,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: u8) -> PSIZER {
                    match value {
                        0 => PSIZER::BIT8,
                        1 => PSIZER::BIT16,
                        2 => PSIZER::BIT32,
                        i => PSIZER::_Reserved(i),
                    }
                }
                #[doc = "Checks if the value of the field is `BIT8`"]
                #[inline]
                pub fn is_bit8(&self) -> bool {
                    *self == PSIZER::BIT8
                }
                #[doc = "Checks if the value of the field is `BIT16`"]
                #[inline]
                pub fn is_bit16(&self) -> bool {
                    *self == PSIZER::BIT16
                }
                #[doc = "Checks if the value of the field is `BIT32`"]
                #[inline]
                pub fn is_bit32(&self) -> bool {
                    *self == PSIZER::BIT32
                }
            }
            #[doc = "Possible values of the field `MSIZE`"]
            pub type MSIZER = PSIZER;
            #[doc = "Possible values of the field `PL`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum PLR {
                #[doc = "Low priority"]
                LOW,
                #[doc = "Medium priority"]
                MEDIUM,
                #[doc = "High priority"]
                HIGH,
                #[doc = "Very high priority"]
                VERYHIGH,
            }
            impl PLR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    match *self {
                        PLR::LOW => 0,
                        PLR::MEDIUM => 0x01,
                        PLR::HIGH => 0x02,
                        PLR::VERYHIGH => 0x03,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: u8) -> PLR {
                    match value {
                        0 => PLR::LOW,
                        1 => PLR::MEDIUM,
                        2 => PLR::HIGH,
                        3 => PLR::VERYHIGH,
                        _ => unreachable!(),
                    }
                }
                #[doc = "Checks if the value of the field is `LOW`"]
                #[inline]
                pub fn is_low(&self) -> bool {
                    *self == PLR::LOW
                }
                #[doc = "Checks if the value of the field is `MEDIUM`"]
                #[inline]
                pub fn is_medium(&self) -> bool {
                    *self == PLR::MEDIUM
                }
                #[doc = "Checks if the value of the field is `HIGH`"]
                #[inline]
                pub fn is_high(&self) -> bool {
                    *self == PLR::HIGH
                }
                #[doc = "Checks if the value of the field is `VERYHIGH`"]
                #[inline]
                pub fn is_very_high(&self) -> bool {
                    *self == PLR::VERYHIGH
                }
            }
            #[doc = "Possible values of the field `MEM2MEM`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum MEM2MEMR {
                #[doc = "Memory to memory mode disabled"]
                DISABLED,
                #[doc = "Memory to memory mode enabled"]
                ENABLED,
            }
            impl MEM2MEMR {
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    match *self {
                        MEM2MEMR::DISABLED => false,
                        MEM2MEMR::ENABLED => true,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: bool) -> MEM2MEMR {
                    match value {
                        false => MEM2MEMR::DISABLED,
                        true => MEM2MEMR::ENABLED,
                    }
                }
                #[doc = "Checks if the value of the field is `DISABLED`"]
                #[inline]
                pub fn is_disabled(&self) -> bool {
                    *self == MEM2MEMR::DISABLED
                }
                #[doc = "Checks if the value of the field is `ENABLED`"]
                #[inline]
                pub fn is_enabled(&self) -> bool {
                    *self == MEM2MEMR::ENABLED
                }
            }
            #[doc = "Values that can be written to the field `EN`"]
            pub enum ENW {
                #[doc = "Channel disabled"]
                DISABLED,
                #[doc = "Channel enabled"]
                ENABLED,
            }
            impl ENW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> bool {
                    match *self {
                        ENW::DISABLED => false,
                        ENW::ENABLED => true,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _ENW<'a> {
                w: &'a mut W,
            }
            impl<'a> _ENW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: ENW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Channel disabled"]
                #[inline]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(ENW::DISABLED)
                }
                #[doc = "Channel enabled"]
                #[inline]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(ENW::ENABLED)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `TCIE`"]
            pub enum TCIEW {
                #[doc = "Transfer Complete interrupt disabled"]
                DISABLED,
                #[doc = "Transfer Complete interrupt enabled"]
                ENABLED,
            }
            impl TCIEW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> bool {
                    match *self {
                        TCIEW::DISABLED => false,
                        TCIEW::ENABLED => true,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _TCIEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _TCIEW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: TCIEW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Transfer Complete interrupt disabled"]
                #[inline]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(TCIEW::DISABLED)
                }
                #[doc = "Transfer Complete interrupt enabled"]
                #[inline]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(TCIEW::ENABLED)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `HTIE`"]
            pub enum HTIEW {
                #[doc = "Half Transfer interrupt disabled"]
                DISABLED,
                #[doc = "Half Transfer interrupt enabled"]
                ENABLED,
            }
            impl HTIEW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> bool {
                    match *self {
                        HTIEW::DISABLED => false,
                        HTIEW::ENABLED => true,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _HTIEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _HTIEW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: HTIEW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Half Transfer interrupt disabled"]
                #[inline]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(HTIEW::DISABLED)
                }
                #[doc = "Half Transfer interrupt enabled"]
                #[inline]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(HTIEW::ENABLED)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `TEIE`"]
            pub enum TEIEW {
                #[doc = "Transfer Error interrupt disabled"]
                DISABLED,
                #[doc = "Transfer Error interrupt enabled"]
                ENABLED,
            }
            impl TEIEW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> bool {
                    match *self {
                        TEIEW::DISABLED => false,
                        TEIEW::ENABLED => true,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _TEIEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _TEIEW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: TEIEW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Transfer Error interrupt disabled"]
                #[inline]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(TEIEW::DISABLED)
                }
                #[doc = "Transfer Error interrupt enabled"]
                #[inline]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(TEIEW::ENABLED)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `DIR`"]
            pub enum DIRW {
                #[doc = "Read from peripheral"]
                FROMPERIPHERAL,
                #[doc = "Read from memory"]
                FROMMEMORY,
            }
            impl DIRW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> bool {
                    match *self {
                        DIRW::FROMPERIPHERAL => false,
                        DIRW::FROMMEMORY => true,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _DIRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DIRW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: DIRW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Read from peripheral"]
                #[inline]
                pub fn from_peripheral(self) -> &'a mut W {
                    self.variant(DIRW::FROMPERIPHERAL)
                }
                #[doc = "Read from memory"]
                #[inline]
                pub fn from_memory(self) -> &'a mut W {
                    self.variant(DIRW::FROMMEMORY)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `CIRC`"]
            pub enum CIRCW {
                #[doc = "Circular buffer disabled"]
                DISABLED,
                #[doc = "Circular buffer enabled"]
                ENABLED,
            }
            impl CIRCW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> bool {
                    match *self {
                        CIRCW::DISABLED => false,
                        CIRCW::ENABLED => true,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _CIRCW<'a> {
                w: &'a mut W,
            }
            impl<'a> _CIRCW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: CIRCW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Circular buffer disabled"]
                #[inline]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(CIRCW::DISABLED)
                }
                #[doc = "Circular buffer enabled"]
                #[inline]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(CIRCW::ENABLED)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `PINC`"]
            pub enum PINCW {
                #[doc = "Increment mode disabled"]
                DISABLED,
                #[doc = "Increment mode enabled"]
                ENABLED,
            }
            impl PINCW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> bool {
                    match *self {
                        PINCW::DISABLED => false,
                        PINCW::ENABLED => true,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _PINCW<'a> {
                w: &'a mut W,
            }
            impl<'a> _PINCW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: PINCW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Increment mode disabled"]
                #[inline]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(PINCW::DISABLED)
                }
                #[doc = "Increment mode enabled"]
                #[inline]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(PINCW::ENABLED)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `MINC`"]
            pub type MINCW = PINCW;
            #[doc = r" Proxy"]
            pub struct _MINCW<'a> {
                w: &'a mut W,
            }
            impl<'a> _MINCW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: MINCW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Increment mode disabled"]
                #[inline]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(PINCW::DISABLED)
                }
                #[doc = "Increment mode enabled"]
                #[inline]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(PINCW::ENABLED)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `PSIZE`"]
            pub enum PSIZEW {
                #[doc = "8-bit size"]
                BIT8,
                #[doc = "16-bit size"]
                BIT16,
                #[doc = "32-bit size"]
                BIT32,
            }
            impl PSIZEW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> u8 {
                    match *self {
                        PSIZEW::BIT8 => 0,
                        PSIZEW::BIT16 => 1,
                        PSIZEW::BIT32 => 2,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _PSIZEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _PSIZEW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: PSIZEW) -> &'a mut W {
                    unsafe { self.bits(variant._bits()) }
                }
                #[doc = "8-bit size"]
                #[inline]
                pub fn bit8(self) -> &'a mut W {
                    self.variant(PSIZEW::BIT8)
                }
                #[doc = "16-bit size"]
                #[inline]
                pub fn bit16(self) -> &'a mut W {
                    self.variant(PSIZEW::BIT16)
                }
                #[doc = "32-bit size"]
                #[inline]
                pub fn bit32(self) -> &'a mut W {
                    self.variant(PSIZEW::BIT32)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `MSIZE`"]
            pub type MSIZEW = PSIZEW;
            #[doc = r" Proxy"]
            pub struct _MSIZEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _MSIZEW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: MSIZEW) -> &'a mut W {
                    unsafe { self.bits(variant._bits()) }
                }
                #[doc = "8-bit size"]
                #[inline]
                pub fn bit8(self) -> &'a mut W {
                    self.variant(PSIZEW::BIT8)
                }
                #[doc = "16-bit size"]
                #[inline]
                pub fn bit16(self) -> &'a mut W {
                    self.variant(PSIZEW::BIT16)
                }
                #[doc = "32-bit size"]
                #[inline]
                pub fn bit32(self) -> &'a mut W {
                    self.variant(PSIZEW::BIT32)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 10;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `PL`"]
            pub enum PLW {
                #[doc = "Low priority"]
                LOW,
                #[doc = "Medium priority"]
                MEDIUM,
                #[doc = "High priority"]
                HIGH,
                #[doc = "Very high priority"]
                VERYHIGH,
            }
            impl PLW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> u8 {
                    match *self {
                        PLW::LOW => 0,
                        PLW::MEDIUM => 1,
                        PLW::HIGH => 2,
                        PLW::VERYHIGH => 3,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _PLW<'a> {
                w: &'a mut W,
            }
            impl<'a> _PLW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: PLW) -> &'a mut W {
                    {
                        self.bits(variant._bits())
                    }
                }
                #[doc = "Low priority"]
                #[inline]
                pub fn low(self) -> &'a mut W {
                    self.variant(PLW::LOW)
                }
                #[doc = "Medium priority"]
                #[inline]
                pub fn medium(self) -> &'a mut W {
                    self.variant(PLW::MEDIUM)
                }
                #[doc = "High priority"]
                #[inline]
                pub fn high(self) -> &'a mut W {
                    self.variant(PLW::HIGH)
                }
                #[doc = "Very high priority"]
                #[inline]
                pub fn very_high(self) -> &'a mut W {
                    self.variant(PLW::VERYHIGH)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 12;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `MEM2MEM`"]
            pub enum MEM2MEMW {
                #[doc = "Memory to memory mode disabled"]
                DISABLED,
                #[doc = "Memory to memory mode enabled"]
                ENABLED,
            }
            impl MEM2MEMW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> bool {
                    match *self {
                        MEM2MEMW::DISABLED => false,
                        MEM2MEMW::ENABLED => true,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _MEM2MEMW<'a> {
                w: &'a mut W,
            }
            impl<'a> _MEM2MEMW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: MEM2MEMW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Memory to memory mode disabled"]
                #[inline]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(MEM2MEMW::DISABLED)
                }
                #[doc = "Memory to memory mode enabled"]
                #[inline]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(MEM2MEMW::ENABLED)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bit 0 - Channel enable"]
                #[inline]
                pub fn en(&self) -> ENR {
                    ENR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    })
                }
                #[doc = "Bit 1 - Transfer complete interrupt enable"]
                #[inline]
                pub fn tcie(&self) -> TCIER {
                    TCIER::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    })
                }
                #[doc = "Bit 2 - Half Transfer interrupt enable"]
                #[inline]
                pub fn htie(&self) -> HTIER {
                    HTIER::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    })
                }
                #[doc = "Bit 3 - Transfer error interrupt enable"]
                #[inline]
                pub fn teie(&self) -> TEIER {
                    TEIER::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    })
                }
                #[doc = "Bit 4 - Data transfer direction"]
                #[inline]
                pub fn dir(&self) -> DIRR {
                    DIRR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    })
                }
                #[doc = "Bit 5 - Circular mode"]
                #[inline]
                pub fn circ(&self) -> CIRCR {
                    CIRCR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    })
                }
                #[doc = "Bit 6 - Peripheral increment mode"]
                #[inline]
                pub fn pinc(&self) -> PINCR {
                    PINCR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    })
                }
                #[doc = "Bit 7 - Memory increment mode"]
                #[inline]
                pub fn minc(&self) -> MINCR {
                    MINCR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    })
                }
                #[doc = "Bits 8:9 - Peripheral size"]
                #[inline]
                pub fn psize(&self) -> PSIZER {
                    PSIZER::_from({
                        const MASK: u8 = 0x03;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    })
                }
                #[doc = "Bits 10:11 - Memory size"]
                #[inline]
                pub fn msize(&self) -> MSIZER {
                    MSIZER::_from({
                        const MASK: u8 = 0x03;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    })
                }
                #[doc = "Bits 12:13 - Channel Priority level"]
                #[inline]
                pub fn pl(&self) -> PLR {
                    PLR::_from({
                        const MASK: u8 = 0x03;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    })
                }
                #[doc = "Bit 14 - Memory to memory mode"]
                #[inline]
                pub fn mem2mem(&self) -> MEM2MEMR {
                    MEM2MEMR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    })
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bit 0 - Channel enable"]
                #[inline]
                pub fn en(&mut self) -> _ENW {
                    _ENW { w: self }
                }
                #[doc = "Bit 1 - Transfer complete interrupt enable"]
                #[inline]
                pub fn tcie(&mut self) -> _TCIEW {
                    _TCIEW { w: self }
                }
                #[doc = "Bit 2 - Half Transfer interrupt enable"]
                #[inline]
                pub fn htie(&mut self) -> _HTIEW {
                    _HTIEW { w: self }
                }
                #[doc = "Bit 3 - Transfer error interrupt enable"]
                #[inline]
                pub fn teie(&mut self) -> _TEIEW {
                    _TEIEW { w: self }
                }
                #[doc = "Bit 4 - Data transfer direction"]
                #[inline]
                pub fn dir(&mut self) -> _DIRW {
                    _DIRW { w: self }
                }
                #[doc = "Bit 5 - Circular mode"]
                #[inline]
                pub fn circ(&mut self) -> _CIRCW {
                    _CIRCW { w: self }
                }
                #[doc = "Bit 6 - Peripheral increment mode"]
                #[inline]
                pub fn pinc(&mut self) -> _PINCW {
                    _PINCW { w: self }
                }
                #[doc = "Bit 7 - Memory increment mode"]
                #[inline]
                pub fn minc(&mut self) -> _MINCW {
                    _MINCW { w: self }
                }
                #[doc = "Bits 8:9 - Peripheral size"]
                #[inline]
                pub fn psize(&mut self) -> _PSIZEW {
                    _PSIZEW { w: self }
                }
                #[doc = "Bits 10:11 - Memory size"]
                #[inline]
                pub fn msize(&mut self) -> _MSIZEW {
                    _MSIZEW { w: self }
                }
                #[doc = "Bits 12:13 - Channel Priority level"]
                #[inline]
                pub fn pl(&mut self) -> _PLW {
                    _PLW { w: self }
                }
                #[doc = "Bit 14 - Memory to memory mode"]
                #[inline]
                pub fn mem2mem(&mut self) -> _MEM2MEMW {
                    _MEM2MEMW { w: self }
                }
            }
        }
        #[doc = "DMA channel 1 number of data register"]
        pub struct NDTR {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "DMA channel 1 number of data register"]
        pub mod ndtr {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::NDTR {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits: bits };
                    let mut w = W { bits: bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = r" Value of the field"]
            pub struct NDTR {
                bits: u16,
            }
            impl NDTR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u16 {
                    self.bits
                }
            }
            #[doc = r" Proxy"]
            pub struct _NDTW<'a> {
                w: &'a mut W,
            }
            impl<'a> _NDTW<'a> {
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bits(self, value: u16) -> &'a mut W {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bits 0:15 - Number of data to transfer"]
                #[inline]
                pub fn ndt(&self) -> NDTR {
                    let bits = {
                        const MASK: u16 = 0xffff;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u16
                    };
                    NDTR { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bits 0:15 - Number of data to transfer"]
                #[inline]
                pub fn ndt(&mut self) -> _NDTW {
                    _NDTW { w: self }
                }
            }
        }
        #[doc = "DMA channel 1 peripheral address register"]
        pub struct PAR {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "DMA channel 1 peripheral address register"]
        pub mod par {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::PAR {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits: bits };
                    let mut w = W { bits: bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = r" Value of the field"]
            pub struct PAR {
                bits: u32,
            }
            impl PAR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
            }
            #[doc = r" Proxy"]
            pub struct _PAW<'a> {
                w: &'a mut W,
            }
            impl<'a> _PAW<'a> {
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bits(self, value: u32) -> &'a mut W {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bits 0:31 - Peripheral address"]
                #[inline]
                pub fn pa(&self) -> PAR {
                    let bits = {
                        const MASK: u32 = 0xffff_ffff;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u32
                    };
                    PAR { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bits 0:31 - Peripheral address"]
                #[inline]
                pub fn pa(&mut self) -> _PAW {
                    _PAW { w: self }
                }
            }
        }
        #[doc = "DMA channel 1 memory address register"]
        pub struct MAR {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "DMA channel 1 memory address register"]
        pub mod mar {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::MAR {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits: bits };
                    let mut w = W { bits: bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = r" Value of the field"]
            pub struct MAR {
                bits: u32,
            }
            impl MAR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
            }
            #[doc = r" Proxy"]
            pub struct _MAW<'a> {
                w: &'a mut W,
            }
            impl<'a> _MAW<'a> {
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bits(self, value: u32) -> &'a mut W {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bits 0:31 - Memory address"]
                #[inline]
                pub fn ma(&self) -> MAR {
                    let bits = {
                        const MASK: u32 = 0xffff_ffff;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u32
                    };
                    MAR { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bits 0:31 - Memory address"]
                #[inline]
                pub fn ma(&mut self) -> _MAW {
                    _MAW { w: self }
                }
            }
        }
    }
    #[doc = "DMA interrupt status register (DMA_ISR)"]
    pub struct ISR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA interrupt status register (DMA_ISR)"]
    pub mod isr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::ISR {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = "Possible values of the field `GIF1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GIF1R {
            #[doc = "No transfer error, half event, complete event"]
            NOEVENT,
            #[doc = "A transfer error, half event or complete event has occured"]
            EVENT,
        }
        impl GIF1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    GIF1R::NOEVENT => false,
                    GIF1R::EVENT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> GIF1R {
                match value {
                    false => GIF1R::NOEVENT,
                    true => GIF1R::EVENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOEVENT`"]
            #[inline]
            pub fn is_no_event(&self) -> bool {
                *self == GIF1R::NOEVENT
            }
            #[doc = "Checks if the value of the field is `EVENT`"]
            #[inline]
            pub fn is_event(&self) -> bool {
                *self == GIF1R::EVENT
            }
        }
        #[doc = "Possible values of the field `TCIF1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TCIF1R {
            #[doc = "No transfer complete event"]
            NOTCOMPLETE,
            #[doc = "A transfer complete event has occured"]
            COMPLETE,
        }
        impl TCIF1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TCIF1R::NOTCOMPLETE => false,
                    TCIF1R::COMPLETE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TCIF1R {
                match value {
                    false => TCIF1R::NOTCOMPLETE,
                    true => TCIF1R::COMPLETE,
                }
            }
            #[doc = "Checks if the value of the field is `NOTCOMPLETE`"]
            #[inline]
            pub fn is_not_complete(&self) -> bool {
                *self == TCIF1R::NOTCOMPLETE
            }
            #[doc = "Checks if the value of the field is `COMPLETE`"]
            #[inline]
            pub fn is_complete(&self) -> bool {
                *self == TCIF1R::COMPLETE
            }
        }
        #[doc = "Possible values of the field `HTIF1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HTIF1R {
            #[doc = "No half transfer event"]
            NOTHALT,
            #[doc = "A half transfer event has occured"]
            HALF,
        }
        impl HTIF1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HTIF1R::NOTHALT => false,
                    HTIF1R::HALF => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HTIF1R {
                match value {
                    false => HTIF1R::NOTHALT,
                    true => HTIF1R::HALF,
                }
            }
            #[doc = "Checks if the value of the field is `NOTHALT`"]
            #[inline]
            pub fn is_not_halt(&self) -> bool {
                *self == HTIF1R::NOTHALT
            }
            #[doc = "Checks if the value of the field is `HALF`"]
            #[inline]
            pub fn is_half(&self) -> bool {
                *self == HTIF1R::HALF
            }
        }
        #[doc = "Possible values of the field `TEIF1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TEIF1R {
            #[doc = "No transfer error"]
            NOERROR,
            #[doc = "A transfer error has occured"]
            ERROR,
        }
        impl TEIF1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TEIF1R::NOERROR => false,
                    TEIF1R::ERROR => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TEIF1R {
                match value {
                    false => TEIF1R::NOERROR,
                    true => TEIF1R::ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline]
            pub fn is_no_error(&self) -> bool {
                *self == TEIF1R::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline]
            pub fn is_error(&self) -> bool {
                *self == TEIF1R::ERROR
            }
        }
        #[doc = "Possible values of the field `GIF2`"]
        pub type GIF2R = GIF1R;
        #[doc = "Possible values of the field `TCIF2`"]
        pub type TCIF2R = TCIF1R;
        #[doc = "Possible values of the field `HTIF2`"]
        pub type HTIF2R = HTIF1R;
        #[doc = "Possible values of the field `TEIF2`"]
        pub type TEIF2R = TEIF1R;
        #[doc = "Possible values of the field `GIF3`"]
        pub type GIF3R = GIF1R;
        #[doc = "Possible values of the field `TCIF3`"]
        pub type TCIF3R = TCIF1R;
        #[doc = "Possible values of the field `HTIF3`"]
        pub type HTIF3R = HTIF1R;
        #[doc = "Possible values of the field `TEIF3`"]
        pub type TEIF3R = TEIF1R;
        #[doc = "Possible values of the field `GIF4`"]
        pub type GIF4R = GIF1R;
        #[doc = "Possible values of the field `TCIF4`"]
        pub type TCIF4R = TCIF1R;
        #[doc = "Possible values of the field `HTIF4`"]
        pub type HTIF4R = HTIF1R;
        #[doc = "Possible values of the field `TEIF4`"]
        pub type TEIF4R = TEIF1R;
        #[doc = "Possible values of the field `GIF5`"]
        pub type GIF5R = GIF1R;
        #[doc = "Possible values of the field `TCIF5`"]
        pub type TCIF5R = TCIF1R;
        #[doc = "Possible values of the field `HTIF5`"]
        pub type HTIF5R = HTIF1R;
        #[doc = "Possible values of the field `TEIF5`"]
        pub type TEIF5R = TEIF1R;
        #[doc = "Possible values of the field `GIF6`"]
        pub type GIF6R = GIF1R;
        #[doc = "Possible values of the field `TCIF6`"]
        pub type TCIF6R = TCIF1R;
        #[doc = "Possible values of the field `HTIF6`"]
        pub type HTIF6R = HTIF1R;
        #[doc = "Possible values of the field `TEIF6`"]
        pub type TEIF6R = TEIF1R;
        #[doc = "Possible values of the field `GIF7`"]
        pub type GIF7R = GIF1R;
        #[doc = "Possible values of the field `TCIF7`"]
        pub type TCIF7R = TCIF1R;
        #[doc = "Possible values of the field `HTIF7`"]
        pub type HTIF7R = HTIF1R;
        #[doc = "Possible values of the field `TEIF7`"]
        pub type TEIF7R = TEIF1R;
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel 1 Global interrupt flag"]
            #[inline]
            pub fn gif1(&self) -> GIF1R {
                GIF1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Channel 1 Transfer Complete flag"]
            #[inline]
            pub fn tcif1(&self) -> TCIF1R {
                TCIF1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Channel 1 Half Transfer Complete flag"]
            #[inline]
            pub fn htif1(&self) -> HTIF1R {
                HTIF1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Channel 1 Transfer Error flag"]
            #[inline]
            pub fn teif1(&self) -> TEIF1R {
                TEIF1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Channel 2 Global interrupt flag"]
            #[inline]
            pub fn gif2(&self) -> GIF2R {
                GIF2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Channel 2 Transfer Complete flag"]
            #[inline]
            pub fn tcif2(&self) -> TCIF2R {
                TCIF2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Channel 2 Half Transfer Complete flag"]
            #[inline]
            pub fn htif2(&self) -> HTIF2R {
                HTIF2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Channel 2 Transfer Error flag"]
            #[inline]
            pub fn teif2(&self) -> TEIF2R {
                TEIF2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Channel 3 Global interrupt flag"]
            #[inline]
            pub fn gif3(&self) -> GIF3R {
                GIF3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Channel 3 Transfer Complete flag"]
            #[inline]
            pub fn tcif3(&self) -> TCIF3R {
                TCIF3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Channel 3 Half Transfer Complete flag"]
            #[inline]
            pub fn htif3(&self) -> HTIF3R {
                HTIF3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Channel 3 Transfer Error flag"]
            #[inline]
            pub fn teif3(&self) -> TEIF3R {
                TEIF3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Channel 4 Global interrupt flag"]
            #[inline]
            pub fn gif4(&self) -> GIF4R {
                GIF4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Channel 4 Transfer Complete flag"]
            #[inline]
            pub fn tcif4(&self) -> TCIF4R {
                TCIF4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Channel 4 Half Transfer Complete flag"]
            #[inline]
            pub fn htif4(&self) -> HTIF4R {
                HTIF4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Channel 4 Transfer Error flag"]
            #[inline]
            pub fn teif4(&self) -> TEIF4R {
                TEIF4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Channel 5 Global interrupt flag"]
            #[inline]
            pub fn gif5(&self) -> GIF5R {
                GIF5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Channel 5 Transfer Complete flag"]
            #[inline]
            pub fn tcif5(&self) -> TCIF5R {
                TCIF5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Channel 5 Half Transfer Complete flag"]
            #[inline]
            pub fn htif5(&self) -> HTIF5R {
                HTIF5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Channel 5 Transfer Error flag"]
            #[inline]
            pub fn teif5(&self) -> TEIF5R {
                TEIF5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - Channel 6 Global interrupt flag"]
            #[inline]
            pub fn gif6(&self) -> GIF6R {
                GIF6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - Channel 6 Transfer Complete flag"]
            #[inline]
            pub fn tcif6(&self) -> TCIF6R {
                TCIF6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - Channel 6 Half Transfer Complete flag"]
            #[inline]
            pub fn htif6(&self) -> HTIF6R {
                HTIF6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 23 - Channel 6 Transfer Error flag"]
            #[inline]
            pub fn teif6(&self) -> TEIF6R {
                TEIF6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Channel 7 Global interrupt flag"]
            #[inline]
            pub fn gif7(&self) -> GIF7R {
                GIF7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - Channel 7 Transfer Complete flag"]
            #[inline]
            pub fn tcif7(&self) -> TCIF7R {
                TCIF7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - Channel 7 Half Transfer Complete flag"]
            #[inline]
            pub fn htif7(&self) -> HTIF7R {
                HTIF7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 27 - Channel 7 Transfer Error flag"]
            #[inline]
            pub fn teif7(&self) -> TEIF7R {
                TEIF7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "DMA interrupt flag clear register (DMA_IFCR)"]
    pub struct IFCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA interrupt flag clear register (DMA_IFCR)"]
    pub mod ifcr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IFCR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Values that can be written to the field `CGIF1`"]
        pub enum CGIF1W {
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            CLEAR,
        }
        impl CGIF1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CGIF1W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CGIF1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CGIF1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CGIF1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CGIF2`"]
        pub type CGIF2W = CGIF1W;
        #[doc = r" Proxy"]
        pub struct _CGIF2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CGIF2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CGIF2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CGIF3`"]
        pub type CGIF3W = CGIF1W;
        #[doc = r" Proxy"]
        pub struct _CGIF3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CGIF3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CGIF3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CGIF4`"]
        pub type CGIF4W = CGIF1W;
        #[doc = r" Proxy"]
        pub struct _CGIF4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CGIF4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CGIF4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CGIF5`"]
        pub type CGIF5W = CGIF1W;
        #[doc = r" Proxy"]
        pub struct _CGIF5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CGIF5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CGIF5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CGIF6`"]
        pub type CGIF6W = CGIF1W;
        #[doc = r" Proxy"]
        pub struct _CGIF6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CGIF6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CGIF6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CGIF7`"]
        pub type CGIF7W = CGIF1W;
        #[doc = r" Proxy"]
        pub struct _CGIF7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CGIF7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CGIF7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTCIF1`"]
        pub enum CTCIF1W {
            #[doc = "Clears the TCIF flag in the ISR register"]
            CLEAR,
        }
        impl CTCIF1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CTCIF1W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTCIF1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTCIF1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTCIF1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTCIF2`"]
        pub type CTCIF2W = CTCIF1W;
        #[doc = r" Proxy"]
        pub struct _CTCIF2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTCIF2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTCIF2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTCIF3`"]
        pub type CTCIF3W = CTCIF1W;
        #[doc = r" Proxy"]
        pub struct _CTCIF3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTCIF3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTCIF3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTCIF4`"]
        pub type CTCIF4W = CTCIF1W;
        #[doc = r" Proxy"]
        pub struct _CTCIF4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTCIF4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTCIF4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTCIF5`"]
        pub type CTCIF5W = CTCIF1W;
        #[doc = r" Proxy"]
        pub struct _CTCIF5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTCIF5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTCIF5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTCIF6`"]
        pub type CTCIF6W = CTCIF1W;
        #[doc = r" Proxy"]
        pub struct _CTCIF6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTCIF6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTCIF6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTCIF7`"]
        pub type CTCIF7W = CTCIF1W;
        #[doc = r" Proxy"]
        pub struct _CTCIF7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTCIF7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTCIF7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the TCIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CHTIF1`"]
        pub enum CHTIF1W {
            #[doc = "Clears the HTIF flag in the ISR register"]
            CLEAR,
        }
        impl CHTIF1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CHTIF1W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CHTIF1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHTIF1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CHTIF1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CHTIF2`"]
        pub type CHTIF2W = CHTIF1W;
        #[doc = r" Proxy"]
        pub struct _CHTIF2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHTIF2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CHTIF2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CHTIF3`"]
        pub type CHTIF3W = CHTIF1W;
        #[doc = r" Proxy"]
        pub struct _CHTIF3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHTIF3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CHTIF3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CHTIF4`"]
        pub type CHTIF4W = CHTIF1W;
        #[doc = r" Proxy"]
        pub struct _CHTIF4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHTIF4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CHTIF4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CHTIF5`"]
        pub type CHTIF5W = CHTIF1W;
        #[doc = r" Proxy"]
        pub struct _CHTIF5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHTIF5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CHTIF5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CHTIF6`"]
        pub type CHTIF6W = CHTIF1W;
        #[doc = r" Proxy"]
        pub struct _CHTIF6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHTIF6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CHTIF6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CHTIF7`"]
        pub type CHTIF7W = CHTIF1W;
        #[doc = r" Proxy"]
        pub struct _CHTIF7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHTIF7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CHTIF7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the HTIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTEIF1`"]
        pub enum CTEIF1W {
            #[doc = "Clears the TEIF flag in the ISR register"]
            CLEAR,
        }
        impl CTEIF1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CTEIF1W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTEIF1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTEIF1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTEIF1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTEIF2`"]
        pub type CTEIF2W = CTEIF1W;
        #[doc = r" Proxy"]
        pub struct _CTEIF2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTEIF2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTEIF2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTEIF3`"]
        pub type CTEIF3W = CTEIF1W;
        #[doc = r" Proxy"]
        pub struct _CTEIF3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTEIF3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTEIF3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTEIF4`"]
        pub type CTEIF4W = CTEIF1W;
        #[doc = r" Proxy"]
        pub struct _CTEIF4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTEIF4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTEIF4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTEIF5`"]
        pub type CTEIF5W = CTEIF1W;
        #[doc = r" Proxy"]
        pub struct _CTEIF5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTEIF5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTEIF5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTEIF6`"]
        pub type CTEIF6W = CTEIF1W;
        #[doc = r" Proxy"]
        pub struct _CTEIF6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTEIF6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTEIF6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTEIF7`"]
        pub type CTEIF7W = CTEIF1W;
        #[doc = r" Proxy"]
        pub struct _CTEIF7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTEIF7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTEIF7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clears the TEIF flag in the ISR register"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel 1 Global interrupt clear"]
            #[inline]
            pub fn cgif1(&mut self) -> _CGIF1W {
                _CGIF1W { w: self }
            }
            #[doc = "Bit 4 - Channel 2 Global interrupt clear"]
            #[inline]
            pub fn cgif2(&mut self) -> _CGIF2W {
                _CGIF2W { w: self }
            }
            #[doc = "Bit 8 - Channel 3 Global interrupt clear"]
            #[inline]
            pub fn cgif3(&mut self) -> _CGIF3W {
                _CGIF3W { w: self }
            }
            #[doc = "Bit 12 - Channel 4 Global interrupt clear"]
            #[inline]
            pub fn cgif4(&mut self) -> _CGIF4W {
                _CGIF4W { w: self }
            }
            #[doc = "Bit 16 - Channel 5 Global interrupt clear"]
            #[inline]
            pub fn cgif5(&mut self) -> _CGIF5W {
                _CGIF5W { w: self }
            }
            #[doc = "Bit 20 - Channel 6 Global interrupt clear"]
            #[inline]
            pub fn cgif6(&mut self) -> _CGIF6W {
                _CGIF6W { w: self }
            }
            #[doc = "Bit 24 - Channel 7 Global interrupt clear"]
            #[inline]
            pub fn cgif7(&mut self) -> _CGIF7W {
                _CGIF7W { w: self }
            }
            #[doc = "Bit 1 - Channel 1 Transfer Complete clear"]
            #[inline]
            pub fn ctcif1(&mut self) -> _CTCIF1W {
                _CTCIF1W { w: self }
            }
            #[doc = "Bit 5 - Channel 2 Transfer Complete clear"]
            #[inline]
            pub fn ctcif2(&mut self) -> _CTCIF2W {
                _CTCIF2W { w: self }
            }
            #[doc = "Bit 9 - Channel 3 Transfer Complete clear"]
            #[inline]
            pub fn ctcif3(&mut self) -> _CTCIF3W {
                _CTCIF3W { w: self }
            }
            #[doc = "Bit 13 - Channel 4 Transfer Complete clear"]
            #[inline]
            pub fn ctcif4(&mut self) -> _CTCIF4W {
                _CTCIF4W { w: self }
            }
            #[doc = "Bit 17 - Channel 5 Transfer Complete clear"]
            #[inline]
            pub fn ctcif5(&mut self) -> _CTCIF5W {
                _CTCIF5W { w: self }
            }
            #[doc = "Bit 21 - Channel 6 Transfer Complete clear"]
            #[inline]
            pub fn ctcif6(&mut self) -> _CTCIF6W {
                _CTCIF6W { w: self }
            }
            #[doc = "Bit 25 - Channel 7 Transfer Complete clear"]
            #[inline]
            pub fn ctcif7(&mut self) -> _CTCIF7W {
                _CTCIF7W { w: self }
            }
            #[doc = "Bit 2 - Channel 1 Half Transfer clear"]
            #[inline]
            pub fn chtif1(&mut self) -> _CHTIF1W {
                _CHTIF1W { w: self }
            }
            #[doc = "Bit 6 - Channel 2 Half Transfer clear"]
            #[inline]
            pub fn chtif2(&mut self) -> _CHTIF2W {
                _CHTIF2W { w: self }
            }
            #[doc = "Bit 10 - Channel 3 Half Transfer clear"]
            #[inline]
            pub fn chtif3(&mut self) -> _CHTIF3W {
                _CHTIF3W { w: self }
            }
            #[doc = "Bit 14 - Channel 4 Half Transfer clear"]
            #[inline]
            pub fn chtif4(&mut self) -> _CHTIF4W {
                _CHTIF4W { w: self }
            }
            #[doc = "Bit 18 - Channel 5 Half Transfer clear"]
            #[inline]
            pub fn chtif5(&mut self) -> _CHTIF5W {
                _CHTIF5W { w: self }
            }
            #[doc = "Bit 22 - Channel 6 Half Transfer clear"]
            #[inline]
            pub fn chtif6(&mut self) -> _CHTIF6W {
                _CHTIF6W { w: self }
            }
            #[doc = "Bit 26 - Channel 7 Half Transfer clear"]
            #[inline]
            pub fn chtif7(&mut self) -> _CHTIF7W {
                _CHTIF7W { w: self }
            }
            #[doc = "Bit 3 - Channel 1 Transfer Error clear"]
            #[inline]
            pub fn cteif1(&mut self) -> _CTEIF1W {
                _CTEIF1W { w: self }
            }
            #[doc = "Bit 7 - Channel 2 Transfer Error clear"]
            #[inline]
            pub fn cteif2(&mut self) -> _CTEIF2W {
                _CTEIF2W { w: self }
            }
            #[doc = "Bit 11 - Channel 3 Transfer Error clear"]
            #[inline]
            pub fn cteif3(&mut self) -> _CTEIF3W {
                _CTEIF3W { w: self }
            }
            #[doc = "Bit 15 - Channel 4 Transfer Error clear"]
            #[inline]
            pub fn cteif4(&mut self) -> _CTEIF4W {
                _CTEIF4W { w: self }
            }
            #[doc = "Bit 19 - Channel 5 Transfer Error clear"]
            #[inline]
            pub fn cteif5(&mut self) -> _CTEIF5W {
                _CTEIF5W { w: self }
            }
            #[doc = "Bit 23 - Channel 6 Transfer Error clear"]
            #[inline]
            pub fn cteif6(&mut self) -> _CTEIF6W {
                _CTEIF6W { w: self }
            }
            #[doc = "Bit 27 - Channel 7 Transfer Error clear"]
            #[inline]
            pub fn cteif7(&mut self) -> _CTEIF7W {
                _CTEIF7W { w: self }
            }
        }
    }
}
#[doc = "DMA2"]
#[cfg(feature = "dma2")]
pub struct DMA2 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "dma2")]
unsafe impl Send for DMA2 {}
#[cfg(feature = "dma2")]
impl DMA2 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const dma1::RegisterBlock {
        0x4002_0400 as *const _
    }
}
#[cfg(feature = "dma2")]
impl Deref for DMA2 {
    type Target = dma1::RegisterBlock;
    fn deref(&self) -> &dma1::RegisterBlock {
        unsafe { &*DMA2::ptr() }
    }
}
#[doc = "Real time clock"]
#[cfg(feature = "rtc")]
pub struct RTC {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "rtc")]
unsafe impl Send for RTC {}
#[cfg(feature = "rtc")]
impl RTC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const rtc::RegisterBlock {
        0x4000_2800 as *const _
    }
}
#[cfg(feature = "rtc")]
impl Deref for RTC {
    type Target = rtc::RegisterBlock;
    fn deref(&self) -> &rtc::RegisterBlock {
        unsafe { &*RTC::ptr() }
    }
}
#[doc = "Real time clock"]
#[cfg(feature = "rtc")]
pub mod rtc {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - RTC Control Register High"]
        pub crh: CRH,
        #[doc = "0x04 - RTC Control Register Low"]
        pub crl: CRL,
        #[doc = "0x08 - RTC Prescaler Load Register High"]
        pub prlh: PRLH,
        #[doc = "0x0c - RTC Prescaler Load Register Low"]
        pub prll: PRLL,
        #[doc = "0x10 - RTC Prescaler Divider Register High"]
        pub divh: DIVH,
        #[doc = "0x14 - RTC Prescaler Divider Register Low"]
        pub divl: DIVL,
        #[doc = "0x18 - RTC Counter Register High"]
        pub cnth: CNTH,
        #[doc = "0x1c - RTC Counter Register Low"]
        pub cntl: CNTL,
        #[doc = "0x20 - RTC Alarm Register High"]
        pub alrh: ALRH,
        #[doc = "0x24 - RTC Alarm Register Low"]
        pub alrl: ALRL,
    }
    #[doc = "RTC Control Register High"]
    pub struct CRH {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RTC Control Register High"]
    pub mod crh {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CRH {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SECIER {
            bits: bool,
        }
        impl SECIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ALRIER {
            bits: bool,
        }
        impl ALRIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OWIER {
            bits: bool,
        }
        impl OWIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SECIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SECIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ALRIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ALRIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OWIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OWIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Second interrupt Enable"]
            #[inline]
            pub fn secie(&self) -> SECIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SECIER { bits }
            }
            #[doc = "Bit 1 - Alarm interrupt Enable"]
            #[inline]
            pub fn alrie(&self) -> ALRIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ALRIER { bits }
            }
            #[doc = "Bit 2 - Overflow interrupt Enable"]
            #[inline]
            pub fn owie(&self) -> OWIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OWIER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Second interrupt Enable"]
            #[inline]
            pub fn secie(&mut self) -> _SECIEW {
                _SECIEW { w: self }
            }
            #[doc = "Bit 1 - Alarm interrupt Enable"]
            #[inline]
            pub fn alrie(&mut self) -> _ALRIEW {
                _ALRIEW { w: self }
            }
            #[doc = "Bit 2 - Overflow interrupt Enable"]
            #[inline]
            pub fn owie(&mut self) -> _OWIEW {
                _OWIEW { w: self }
            }
        }
    }
    #[doc = "RTC Control Register Low"]
    pub struct CRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RTC Control Register Low"]
    pub mod crl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SECFR {
            bits: bool,
        }
        impl SECFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ALRFR {
            bits: bool,
        }
        impl ALRFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OWFR {
            bits: bool,
        }
        impl OWFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RSFR {
            bits: bool,
        }
        impl RSFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNFR {
            bits: bool,
        }
        impl CNFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RTOFFR {
            bits: bool,
        }
        impl RTOFFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SECFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SECFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ALRFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ALRFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OWFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OWFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Second Flag"]
            #[inline]
            pub fn secf(&self) -> SECFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SECFR { bits }
            }
            #[doc = "Bit 1 - Alarm Flag"]
            #[inline]
            pub fn alrf(&self) -> ALRFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ALRFR { bits }
            }
            #[doc = "Bit 2 - Overflow Flag"]
            #[inline]
            pub fn owf(&self) -> OWFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OWFR { bits }
            }
            #[doc = "Bit 3 - Registers Synchronized Flag"]
            #[inline]
            pub fn rsf(&self) -> RSFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RSFR { bits }
            }
            #[doc = "Bit 4 - Configuration Flag"]
            #[inline]
            pub fn cnf(&self) -> CNFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CNFR { bits }
            }
            #[doc = "Bit 5 - RTC operation OFF"]
            #[inline]
            pub fn rtoff(&self) -> RTOFFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RTOFFR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x20 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Second Flag"]
            #[inline]
            pub fn secf(&mut self) -> _SECFW {
                _SECFW { w: self }
            }
            #[doc = "Bit 1 - Alarm Flag"]
            #[inline]
            pub fn alrf(&mut self) -> _ALRFW {
                _ALRFW { w: self }
            }
            #[doc = "Bit 2 - Overflow Flag"]
            #[inline]
            pub fn owf(&mut self) -> _OWFW {
                _OWFW { w: self }
            }
            #[doc = "Bit 3 - Registers Synchronized Flag"]
            #[inline]
            pub fn rsf(&mut self) -> _RSFW {
                _RSFW { w: self }
            }
            #[doc = "Bit 4 - Configuration Flag"]
            #[inline]
            pub fn cnf(&mut self) -> _CNFW {
                _CNFW { w: self }
            }
        }
    }
    #[doc = "RTC Prescaler Load Register High"]
    pub struct PRLH {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RTC Prescaler Load Register High"]
    pub mod prlh {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PRLH {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRLHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRLHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - RTC Prescaler Load Register High"]
            #[inline]
            pub fn prlh(&mut self) -> _PRLHW {
                _PRLHW { w: self }
            }
        }
    }
    #[doc = "RTC Prescaler Load Register Low"]
    pub struct PRLL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RTC Prescaler Load Register Low"]
    pub mod prll {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PRLL {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRLLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRLLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x8000 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - RTC Prescaler Divider Register Low"]
            #[inline]
            pub fn prll(&mut self) -> _PRLLW {
                _PRLLW { w: self }
            }
        }
    }
    #[doc = "RTC Prescaler Divider Register High"]
    pub struct DIVH {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RTC Prescaler Divider Register High"]
    pub mod divh {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DIVH {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVHR {
            bits: u8,
        }
        impl DIVHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - RTC prescaler divider register high"]
            #[inline]
            pub fn divh(&self) -> DIVHR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVHR { bits }
            }
        }
    }
    #[doc = "RTC Prescaler Divider Register Low"]
    pub struct DIVL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RTC Prescaler Divider Register Low"]
    pub mod divl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DIVL {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVLR {
            bits: u16,
        }
        impl DIVLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - RTC prescaler divider register Low"]
            #[inline]
            pub fn divl(&self) -> DIVLR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DIVLR { bits }
            }
        }
    }
    #[doc = "RTC Counter Register High"]
    pub struct CNTH {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RTC Counter Register High"]
    pub mod cnth {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CNTH {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNTHR {
            bits: u16,
        }
        impl CNTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNTHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - RTC counter register high"]
            #[inline]
            pub fn cnth(&self) -> CNTHR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CNTHR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - RTC counter register high"]
            #[inline]
            pub fn cnth(&mut self) -> _CNTHW {
                _CNTHW { w: self }
            }
        }
    }
    #[doc = "RTC Counter Register Low"]
    pub struct CNTL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RTC Counter Register Low"]
    pub mod cntl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CNTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNTLR {
            bits: u16,
        }
        impl CNTLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNTLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNTLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - RTC counter register Low"]
            #[inline]
            pub fn cntl(&self) -> CNTLR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CNTLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - RTC counter register Low"]
            #[inline]
            pub fn cntl(&mut self) -> _CNTLW {
                _CNTLW { w: self }
            }
        }
    }
    #[doc = "RTC Alarm Register High"]
    pub struct ALRH {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RTC Alarm Register High"]
    pub mod alrh {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ALRH {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _ALRHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ALRHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - RTC alarm register high"]
            #[inline]
            pub fn alrh(&mut self) -> _ALRHW {
                _ALRHW { w: self }
            }
        }
    }
    #[doc = "RTC Alarm Register Low"]
    pub struct ALRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RTC Alarm Register Low"]
    pub mod alrl {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ALRL {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _ALRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ALRLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - RTC alarm register low"]
            #[inline]
            pub fn alrl(&mut self) -> _ALRLW {
                _ALRLW { w: self }
            }
        }
    }
}
#[doc = "Backup registers"]
#[cfg(feature = "bkp")]
pub struct BKP {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "bkp")]
unsafe impl Send for BKP {}
#[cfg(feature = "bkp")]
impl BKP {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const bkp::RegisterBlock {
        0x4000_6c04 as *const _
    }
}
#[cfg(feature = "bkp")]
impl Deref for BKP {
    type Target = bkp::RegisterBlock;
    fn deref(&self) -> &bkp::RegisterBlock {
        unsafe { &*BKP::ptr() }
    }
}
#[doc = "Backup registers"]
#[cfg(feature = "bkp")]
pub mod bkp {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Backup data register (BKP_DR)"]
        pub dr1: DR1,
        #[doc = "0x04 - Backup data register (BKP_DR)"]
        pub dr2: DR2,
        #[doc = "0x08 - Backup data register (BKP_DR)"]
        pub dr3: DR3,
        #[doc = "0x0c - Backup data register (BKP_DR)"]
        pub dr4: DR4,
        #[doc = "0x10 - Backup data register (BKP_DR)"]
        pub dr5: DR5,
        #[doc = "0x14 - Backup data register (BKP_DR)"]
        pub dr6: DR6,
        #[doc = "0x18 - Backup data register (BKP_DR)"]
        pub dr7: DR7,
        #[doc = "0x1c - Backup data register (BKP_DR)"]
        pub dr8: DR8,
        #[doc = "0x20 - Backup data register (BKP_DR)"]
        pub dr9: DR9,
        #[doc = "0x24 - Backup data register (BKP_DR)"]
        pub dr10: DR10,
        #[doc = "0x28 - RTC clock calibration register (BKP_RTCCR)"]
        pub rtccr: RTCCR,
        #[doc = "0x2c - Backup control register (BKP_CR)"]
        pub cr: CR,
        #[doc = "0x30 - BKP_CSR control/status register (BKP_CSR)"]
        pub csr: CSR,
        _reserved0: [u8; 8usize],
        #[doc = "0x3c - Backup data register (BKP_DR)"]
        pub dr11: DR11,
        #[doc = "0x40 - Backup data register (BKP_DR)"]
        pub dr12: DR12,
        #[doc = "0x44 - Backup data register (BKP_DR)"]
        pub dr13: DR13,
        #[doc = "0x48 - Backup data register (BKP_DR)"]
        pub dr14: DR14,
        #[doc = "0x4c - Backup data register (BKP_DR)"]
        pub dr15: DR15,
        #[doc = "0x50 - Backup data register (BKP_DR)"]
        pub dr16: DR16,
        #[doc = "0x54 - Backup data register (BKP_DR)"]
        pub dr17: DR17,
        #[doc = "0x58 - Backup data register (BKP_DR)"]
        pub dr18: DR18,
        #[doc = "0x5c - Backup data register (BKP_DR)"]
        pub dr19: DR19,
        #[doc = "0x60 - Backup data register (BKP_DR)"]
        pub dr20: DR20,
        #[doc = "0x64 - Backup data register (BKP_DR)"]
        pub dr21: DR21,
        #[doc = "0x68 - Backup data register (BKP_DR)"]
        pub dr22: DR22,
        #[doc = "0x6c - Backup data register (BKP_DR)"]
        pub dr23: DR23,
        #[doc = "0x70 - Backup data register (BKP_DR)"]
        pub dr24: DR24,
        #[doc = "0x74 - Backup data register (BKP_DR)"]
        pub dr25: DR25,
        #[doc = "0x78 - Backup data register (BKP_DR)"]
        pub dr26: DR26,
        #[doc = "0x7c - Backup data register (BKP_DR)"]
        pub dr27: DR27,
        #[doc = "0x80 - Backup data register (BKP_DR)"]
        pub dr28: DR28,
        #[doc = "0x84 - Backup data register (BKP_DR)"]
        pub dr29: DR29,
        #[doc = "0x88 - Backup data register (BKP_DR)"]
        pub dr30: DR30,
        #[doc = "0x8c - Backup data register (BKP_DR)"]
        pub dr31: DR31,
        #[doc = "0x90 - Backup data register (BKP_DR)"]
        pub dr32: DR32,
        #[doc = "0x94 - Backup data register (BKP_DR)"]
        pub dr33: DR33,
        #[doc = "0x98 - Backup data register (BKP_DR)"]
        pub dr34: DR34,
        #[doc = "0x9c - Backup data register (BKP_DR)"]
        pub dr35: DR35,
        #[doc = "0xa0 - Backup data register (BKP_DR)"]
        pub dr36: DR36,
        #[doc = "0xa4 - Backup data register (BKP_DR)"]
        pub dr37: DR37,
        #[doc = "0xa8 - Backup data register (BKP_DR)"]
        pub dr38: DR38,
        #[doc = "0xac - Backup data register (BKP_DR)"]
        pub dr39: DR39,
        #[doc = "0xb0 - Backup data register (BKP_DR)"]
        pub dr40: DR40,
        #[doc = "0xb4 - Backup data register (BKP_DR)"]
        pub dr41: DR41,
        #[doc = "0xb8 - Backup data register (BKP_DR)"]
        pub dr42: DR42,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D1R {
            bits: u16,
        }
        impl D1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d1(&self) -> D1R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d1(&mut self) -> _D1W {
                _D1W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D2R {
            bits: u16,
        }
        impl D2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d2(&self) -> D2R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D2R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d2(&mut self) -> _D2W {
                _D2W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D3R {
            bits: u16,
        }
        impl D3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d3(&self) -> D3R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d3(&mut self) -> _D3W {
                _D3W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR4 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D4R {
            bits: u16,
        }
        impl D4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d4(&self) -> D4R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D4R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d4(&mut self) -> _D4W {
                _D4W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR5 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D5R {
            bits: u16,
        }
        impl D5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d5(&self) -> D5R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D5R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d5(&mut self) -> _D5W {
                _D5W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR6 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR6 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D6R {
            bits: u16,
        }
        impl D6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d6(&self) -> D6R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D6R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d6(&mut self) -> _D6W {
                _D6W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR7 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr7 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR7 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D7R {
            bits: u16,
        }
        impl D7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d7(&self) -> D7R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d7(&mut self) -> _D7W {
                _D7W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR8 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr8 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR8 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D8R {
            bits: u16,
        }
        impl D8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d8(&self) -> D8R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D8R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d8(&mut self) -> _D8W {
                _D8W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR9 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr9 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR9 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D9R {
            bits: u16,
        }
        impl D9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d9(&self) -> D9R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D9R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d9(&mut self) -> _D9W {
                _D9W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR10 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr10 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR10 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D10R {
            bits: u16,
        }
        impl D10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d10(&self) -> D10R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D10R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d10(&mut self) -> _D10W {
                _D10W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR11 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr11 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR11 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DR11R {
            bits: u16,
        }
        impl DR11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DR11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DR11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn dr11(&self) -> DR11R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DR11R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn dr11(&mut self) -> _DR11W {
                _DR11W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR12 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr12 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR12 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DR12R {
            bits: u16,
        }
        impl DR12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DR12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DR12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn dr12(&self) -> DR12R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DR12R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn dr12(&mut self) -> _DR12W {
                _DR12W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR13 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr13 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR13 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DR13R {
            bits: u16,
        }
        impl DR13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DR13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DR13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn dr13(&self) -> DR13R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DR13R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn dr13(&mut self) -> _DR13W {
                _DR13W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR14 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr14 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR14 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D14R {
            bits: u16,
        }
        impl D14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d14(&self) -> D14R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D14R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d14(&mut self) -> _D14W {
                _D14W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR15 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr15 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR15 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D15R {
            bits: u16,
        }
        impl D15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d15(&self) -> D15R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D15R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d15(&mut self) -> _D15W {
                _D15W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR16 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr16 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR16 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D16R {
            bits: u16,
        }
        impl D16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D16W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d16(&self) -> D16R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D16R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d16(&mut self) -> _D16W {
                _D16W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR17 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr17 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR17 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D17R {
            bits: u16,
        }
        impl D17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D17W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d17(&self) -> D17R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D17R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d17(&mut self) -> _D17W {
                _D17W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR18 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr18 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR18 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D18R {
            bits: u16,
        }
        impl D18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D18W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d18(&self) -> D18R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D18R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d18(&mut self) -> _D18W {
                _D18W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR19 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr19 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR19 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D19R {
            bits: u16,
        }
        impl D19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D19W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d19(&self) -> D19R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D19R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d19(&mut self) -> _D19W {
                _D19W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR20 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr20 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR20 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D20R {
            bits: u16,
        }
        impl D20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D20W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d20(&self) -> D20R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D20R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d20(&mut self) -> _D20W {
                _D20W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR21 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr21 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR21 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D21R {
            bits: u16,
        }
        impl D21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D21W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d21(&self) -> D21R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D21R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d21(&mut self) -> _D21W {
                _D21W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR22 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr22 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR22 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D22R {
            bits: u16,
        }
        impl D22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D22W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d22(&self) -> D22R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D22R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d22(&mut self) -> _D22W {
                _D22W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR23 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr23 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR23 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D23R {
            bits: u16,
        }
        impl D23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D23W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d23(&self) -> D23R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D23R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d23(&mut self) -> _D23W {
                _D23W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR24 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr24 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR24 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D24R {
            bits: u16,
        }
        impl D24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D24W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d24(&self) -> D24R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D24R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d24(&mut self) -> _D24W {
                _D24W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR25 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr25 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR25 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D25R {
            bits: u16,
        }
        impl D25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D25W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d25(&self) -> D25R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D25R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d25(&mut self) -> _D25W {
                _D25W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR26 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr26 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR26 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D26R {
            bits: u16,
        }
        impl D26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D26W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d26(&self) -> D26R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D26R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d26(&mut self) -> _D26W {
                _D26W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR27 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr27 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR27 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D27R {
            bits: u16,
        }
        impl D27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D27W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d27(&self) -> D27R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D27R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d27(&mut self) -> _D27W {
                _D27W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR28 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr28 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR28 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D28R {
            bits: u16,
        }
        impl D28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D28W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d28(&self) -> D28R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D28R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d28(&mut self) -> _D28W {
                _D28W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR29 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr29 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR29 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D29R {
            bits: u16,
        }
        impl D29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D29W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d29(&self) -> D29R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D29R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d29(&mut self) -> _D29W {
                _D29W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR30 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr30 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR30 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D30R {
            bits: u16,
        }
        impl D30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D30W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d30(&self) -> D30R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D30R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d30(&mut self) -> _D30W {
                _D30W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR31 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr31 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR31 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D31R {
            bits: u16,
        }
        impl D31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D31W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d31(&self) -> D31R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d31(&mut self) -> _D31W {
                _D31W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR32 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr32 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR32 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D32R {
            bits: u16,
        }
        impl D32R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D32W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D32W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d32(&self) -> D32R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D32R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d32(&mut self) -> _D32W {
                _D32W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR33 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr33 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR33 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D33R {
            bits: u16,
        }
        impl D33R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D33W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D33W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d33(&self) -> D33R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D33R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d33(&mut self) -> _D33W {
                _D33W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR34 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr34 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR34 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D34R {
            bits: u16,
        }
        impl D34R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D34W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D34W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d34(&self) -> D34R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D34R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d34(&mut self) -> _D34W {
                _D34W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR35 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr35 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR35 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D35R {
            bits: u16,
        }
        impl D35R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D35W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D35W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d35(&self) -> D35R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D35R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d35(&mut self) -> _D35W {
                _D35W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR36 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr36 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR36 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D36R {
            bits: u16,
        }
        impl D36R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D36W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D36W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d36(&self) -> D36R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D36R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d36(&mut self) -> _D36W {
                _D36W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR37 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr37 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR37 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D37R {
            bits: u16,
        }
        impl D37R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D37W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D37W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d37(&self) -> D37R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D37R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d37(&mut self) -> _D37W {
                _D37W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR38 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr38 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR38 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D38R {
            bits: u16,
        }
        impl D38R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D38W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D38W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d38(&self) -> D38R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D38R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d38(&mut self) -> _D38W {
                _D38W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR39 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr39 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR39 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D39R {
            bits: u16,
        }
        impl D39R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D39W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D39W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d39(&self) -> D39R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D39R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d39(&mut self) -> _D39W {
                _D39W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR40 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr40 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR40 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D40R {
            bits: u16,
        }
        impl D40R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D40W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D40W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d40(&self) -> D40R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D40R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d40(&mut self) -> _D40W {
                _D40W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR41 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr41 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR41 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D41R {
            bits: u16,
        }
        impl D41R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D41W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D41W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d41(&self) -> D41R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D41R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d41(&mut self) -> _D41W {
                _D41W { w: self }
            }
        }
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub struct DR42 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup data register (BKP_DR)"]
    pub mod dr42 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR42 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct D42R {
            bits: u16,
        }
        impl D42R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _D42W<'a> {
            w: &'a mut W,
        }
        impl<'a> _D42W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d42(&self) -> D42R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                D42R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Backup data"]
            #[inline]
            pub fn d42(&mut self) -> _D42W {
                _D42W { w: self }
            }
        }
    }
    #[doc = "RTC clock calibration register (BKP_RTCCR)"]
    pub struct RTCCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RTC clock calibration register (BKP_RTCCR)"]
    pub mod rtccr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RTCCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CALR {
            bits: u8,
        }
        impl CALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCOR {
            bits: bool,
        }
        impl CCOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ASOER {
            bits: bool,
        }
        impl ASOER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ASOSR {
            bits: bool,
        }
        impl ASOSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x7f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ASOEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ASOEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ASOSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ASOSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:6 - Calibration value"]
            #[inline]
            pub fn cal(&self) -> CALR {
                let bits = {
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CALR { bits }
            }
            #[doc = "Bit 7 - Calibration Clock Output"]
            #[inline]
            pub fn cco(&self) -> CCOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CCOR { bits }
            }
            #[doc = "Bit 8 - Alarm or second output enable"]
            #[inline]
            pub fn asoe(&self) -> ASOER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ASOER { bits }
            }
            #[doc = "Bit 9 - Alarm or second output selection"]
            #[inline]
            pub fn asos(&self) -> ASOSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ASOSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:6 - Calibration value"]
            #[inline]
            pub fn cal(&mut self) -> _CALW {
                _CALW { w: self }
            }
            #[doc = "Bit 7 - Calibration Clock Output"]
            #[inline]
            pub fn cco(&mut self) -> _CCOW {
                _CCOW { w: self }
            }
            #[doc = "Bit 8 - Alarm or second output enable"]
            #[inline]
            pub fn asoe(&mut self) -> _ASOEW {
                _ASOEW { w: self }
            }
            #[doc = "Bit 9 - Alarm or second output selection"]
            #[inline]
            pub fn asos(&mut self) -> _ASOSW {
                _ASOSW { w: self }
            }
        }
    }
    #[doc = "Backup control register (BKP_CR)"]
    pub struct CR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Backup control register (BKP_CR)"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TPER {
            bits: bool,
        }
        impl TPER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TPALR {
            bits: bool,
        }
        impl TPALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _TPEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TPEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TPALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TPALW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Tamper pin enable"]
            #[inline]
            pub fn tpe(&self) -> TPER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TPER { bits }
            }
            #[doc = "Bit 1 - Tamper pin active level"]
            #[inline]
            pub fn tpal(&self) -> TPALR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TPALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Tamper pin enable"]
            #[inline]
            pub fn tpe(&mut self) -> _TPEW {
                _TPEW { w: self }
            }
            #[doc = "Bit 1 - Tamper pin active level"]
            #[inline]
            pub fn tpal(&mut self) -> _TPALW {
                _TPALW { w: self }
            }
        }
    }
    #[doc = "BKP_CSR control/status register (BKP_CSR)"]
    pub struct CSR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "BKP_CSR control/status register (BKP_CSR)"]
    pub mod csr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CSR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TPIER {
            bits: bool,
        }
        impl TPIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TEFR {
            bits: bool,
        }
        impl TEFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIFR {
            bits: bool,
        }
        impl TIFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TPIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TPIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 2 - Tamper Pin interrupt enable"]
            #[inline]
            pub fn tpie(&self) -> TPIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TPIER { bits }
            }
            #[doc = "Bit 8 - Tamper Event Flag"]
            #[inline]
            pub fn tef(&self) -> TEFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TEFR { bits }
            }
            #[doc = "Bit 9 - Tamper Interrupt Flag"]
            #[inline]
            pub fn tif(&self) -> TIFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIFR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Clear Tamper event"]
            #[inline]
            pub fn cte(&mut self) -> _CTEW {
                _CTEW { w: self }
            }
            #[doc = "Bit 1 - Clear Tamper Interrupt"]
            #[inline]
            pub fn cti(&mut self) -> _CTIW {
                _CTIW { w: self }
            }
            #[doc = "Bit 2 - Tamper Pin interrupt enable"]
            #[inline]
            pub fn tpie(&mut self) -> _TPIEW {
                _TPIEW { w: self }
            }
        }
    }
}
#[doc = "Independent watchdog"]
#[cfg(feature = "iwdg")]
pub struct IWDG {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "iwdg")]
unsafe impl Send for IWDG {}
#[cfg(feature = "iwdg")]
impl IWDG {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const iwdg::RegisterBlock {
        0x4000_3000 as *const _
    }
}
#[cfg(feature = "iwdg")]
impl Deref for IWDG {
    type Target = iwdg::RegisterBlock;
    fn deref(&self) -> &iwdg::RegisterBlock {
        unsafe { &*IWDG::ptr() }
    }
}
#[doc = "Independent watchdog"]
#[cfg(feature = "iwdg")]
pub mod iwdg {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Key register (IWDG_KR)"]
        pub kr: KR,
        #[doc = "0x04 - Prescaler register (IWDG_PR)"]
        pub pr: PR,
        #[doc = "0x08 - Reload register (IWDG_RLR)"]
        pub rlr: RLR,
        #[doc = "0x0c - Status register (IWDG_SR)"]
        pub sr: SR,
    }
    #[doc = "Key register (IWDG_KR)"]
    pub struct KR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Key register (IWDG_KR)"]
    pub mod kr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::KR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Values that can be written to the field `KEY`"]
        pub enum KEYW {
            #[doc = "Enable access to PR, RLR and WINR registers (0x5555)"]
            ENABLE,
            #[doc = "Reset the watchdog value (0xAAAA)"]
            RESET,
            #[doc = "Start the watchdog (0xCCCC)"]
            START,
        }
        impl KEYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u16 {
                match *self {
                    KEYW::ENABLE => 21845,
                    KEYW::RESET => 43690,
                    KEYW::START => 52428,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _KEYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _KEYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: KEYW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Enable access to PR, RLR and WINR registers (0x5555)"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(KEYW::ENABLE)
            }
            #[doc = "Reset the watchdog value (0xAAAA)"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(KEYW::RESET)
            }
            #[doc = "Start the watchdog (0xCCCC)"]
            #[inline]
            pub fn start(self) -> &'a mut W {
                self.variant(KEYW::START)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Key value"]
            #[inline]
            pub fn key(&mut self) -> _KEYW {
                _KEYW { w: self }
            }
        }
    }
    #[doc = "Prescaler register (IWDG_PR)"]
    pub struct PR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Prescaler register (IWDG_PR)"]
    pub mod pr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PRR {
            #[doc = "Divider /4"]
            DIVIDEBY4,
            #[doc = "Divider /8"]
            DIVIDEBY8,
            #[doc = "Divider /16"]
            DIVIDEBY16,
            #[doc = "Divider /32"]
            DIVIDEBY32,
            #[doc = "Divider /64"]
            DIVIDEBY64,
            #[doc = "Divider /128"]
            DIVIDEBY128,
            #[doc = "Divider /256"]
            DIVIDEBY256,
            #[doc = "Divider /256"]
            DIVIDEBY256BIS,
        }
        impl PRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PRR::DIVIDEBY4 => 0,
                    PRR::DIVIDEBY8 => 0x01,
                    PRR::DIVIDEBY16 => 0x02,
                    PRR::DIVIDEBY32 => 0x03,
                    PRR::DIVIDEBY64 => 0x04,
                    PRR::DIVIDEBY128 => 0x05,
                    PRR::DIVIDEBY256 => 0x06,
                    PRR::DIVIDEBY256BIS => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PRR {
                match value {
                    0 => PRR::DIVIDEBY4,
                    1 => PRR::DIVIDEBY8,
                    2 => PRR::DIVIDEBY16,
                    3 => PRR::DIVIDEBY32,
                    4 => PRR::DIVIDEBY64,
                    5 => PRR::DIVIDEBY128,
                    6 => PRR::DIVIDEBY256,
                    7 => PRR::DIVIDEBY256BIS,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY4`"]
            #[inline]
            pub fn is_divide_by4(&self) -> bool {
                *self == PRR::DIVIDEBY4
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY8`"]
            #[inline]
            pub fn is_divide_by8(&self) -> bool {
                *self == PRR::DIVIDEBY8
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY16`"]
            #[inline]
            pub fn is_divide_by16(&self) -> bool {
                *self == PRR::DIVIDEBY16
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY32`"]
            #[inline]
            pub fn is_divide_by32(&self) -> bool {
                *self == PRR::DIVIDEBY32
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY64`"]
            #[inline]
            pub fn is_divide_by64(&self) -> bool {
                *self == PRR::DIVIDEBY64
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY128`"]
            #[inline]
            pub fn is_divide_by128(&self) -> bool {
                *self == PRR::DIVIDEBY128
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY256`"]
            #[inline]
            pub fn is_divide_by256(&self) -> bool {
                *self == PRR::DIVIDEBY256
            }
            #[doc = "Checks if the value of the field is `DIVIDEBY256BIS`"]
            #[inline]
            pub fn is_divide_by256bis(&self) -> bool {
                *self == PRR::DIVIDEBY256BIS
            }
        }
        #[doc = "Values that can be written to the field `PR`"]
        pub enum PRW {
            #[doc = "Divider /4"]
            DIVIDEBY4,
            #[doc = "Divider /8"]
            DIVIDEBY8,
            #[doc = "Divider /16"]
            DIVIDEBY16,
            #[doc = "Divider /32"]
            DIVIDEBY32,
            #[doc = "Divider /64"]
            DIVIDEBY64,
            #[doc = "Divider /128"]
            DIVIDEBY128,
            #[doc = "Divider /256"]
            DIVIDEBY256,
            #[doc = "Divider /256"]
            DIVIDEBY256BIS,
        }
        impl PRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PRW::DIVIDEBY4 => 0,
                    PRW::DIVIDEBY8 => 1,
                    PRW::DIVIDEBY16 => 2,
                    PRW::DIVIDEBY32 => 3,
                    PRW::DIVIDEBY64 => 4,
                    PRW::DIVIDEBY128 => 5,
                    PRW::DIVIDEBY256 => 6,
                    PRW::DIVIDEBY256BIS => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PRW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Divider /4"]
            #[inline]
            pub fn divide_by4(self) -> &'a mut W {
                self.variant(PRW::DIVIDEBY4)
            }
            #[doc = "Divider /8"]
            #[inline]
            pub fn divide_by8(self) -> &'a mut W {
                self.variant(PRW::DIVIDEBY8)
            }
            #[doc = "Divider /16"]
            #[inline]
            pub fn divide_by16(self) -> &'a mut W {
                self.variant(PRW::DIVIDEBY16)
            }
            #[doc = "Divider /32"]
            #[inline]
            pub fn divide_by32(self) -> &'a mut W {
                self.variant(PRW::DIVIDEBY32)
            }
            #[doc = "Divider /64"]
            #[inline]
            pub fn divide_by64(self) -> &'a mut W {
                self.variant(PRW::DIVIDEBY64)
            }
            #[doc = "Divider /128"]
            #[inline]
            pub fn divide_by128(self) -> &'a mut W {
                self.variant(PRW::DIVIDEBY128)
            }
            #[doc = "Divider /256"]
            #[inline]
            pub fn divide_by256(self) -> &'a mut W {
                self.variant(PRW::DIVIDEBY256)
            }
            #[doc = "Divider /256"]
            #[inline]
            pub fn divide_by256bis(self) -> &'a mut W {
                self.variant(PRW::DIVIDEBY256BIS)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Prescaler divider"]
            #[inline]
            pub fn pr(&self) -> PRR {
                PRR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Prescaler divider"]
            #[inline]
            pub fn pr(&mut self) -> _PRW {
                _PRW { w: self }
            }
        }
    }
    #[doc = "Reload register (IWDG_RLR)"]
    pub struct RLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Reload register (IWDG_RLR)"]
    pub mod rlr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RLR {
            bits: u16,
        }
        impl RLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _RLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - Watchdog counter reload value"]
            #[inline]
            pub fn rl(&self) -> RLR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0fff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Watchdog counter reload value"]
            #[inline]
            pub fn rl(&mut self) -> _RLW {
                _RLW { w: self }
            }
        }
    }
    #[doc = "Status register (IWDG_SR)"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Status register (IWDG_SR)"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PVUR {
            bits: bool,
        }
        impl PVUR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RVUR {
            bits: bool,
        }
        impl RVUR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Watchdog prescaler value update"]
            #[inline]
            pub fn pvu(&self) -> PVUR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PVUR { bits }
            }
            #[doc = "Bit 1 - Watchdog counter reload value update"]
            #[inline]
            pub fn rvu(&self) -> RVUR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RVUR { bits }
            }
        }
    }
}
#[doc = "Window watchdog"]
#[cfg(feature = "wwdg")]
pub struct WWDG {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "wwdg")]
unsafe impl Send for WWDG {}
#[cfg(feature = "wwdg")]
impl WWDG {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const wwdg::RegisterBlock {
        0x4000_2c00 as *const _
    }
}
#[cfg(feature = "wwdg")]
impl Deref for WWDG {
    type Target = wwdg::RegisterBlock;
    fn deref(&self) -> &wwdg::RegisterBlock {
        unsafe { &*WWDG::ptr() }
    }
}
#[doc = "Window watchdog"]
#[cfg(feature = "wwdg")]
pub mod wwdg {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control register (WWDG_CR)"]
        pub cr: CR,
        #[doc = "0x04 - Configuration register (WWDG_CFR)"]
        pub cfr: CFR,
        #[doc = "0x08 - Status register (WWDG_SR)"]
        pub sr: SR,
    }
    #[doc = "Control register (WWDG_CR)"]
    pub struct CR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control register (WWDG_CR)"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR {
            bits: u8,
        }
        impl TR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `WDGA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDGAR {
            #[doc = "Watchdog disabled"]
            DISABLED,
            #[doc = "Watchdog enabled"]
            ENABLED,
        }
        impl WDGAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WDGAR::DISABLED => false,
                    WDGAR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WDGAR {
                match value {
                    false => WDGAR::DISABLED,
                    true => WDGAR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == WDGAR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == WDGAR::ENABLED
            }
        }
        #[doc = r" Proxy"]
        pub struct _TW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x7f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDGA`"]
        pub enum WDGAW {
            #[doc = "Watchdog disabled"]
            DISABLED,
            #[doc = "Watchdog enabled"]
            ENABLED,
        }
        impl WDGAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDGAW::DISABLED => false,
                    WDGAW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDGAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDGAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WDGAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Watchdog disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WDGAW::DISABLED)
            }
            #[doc = "Watchdog enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WDGAW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:6 - 7-bit counter (MSB to LSB)"]
            #[inline]
            pub fn t(&self) -> TR {
                let bits = {
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TR { bits }
            }
            #[doc = "Bit 7 - Activation bit"]
            #[inline]
            pub fn wdga(&self) -> WDGAR {
                WDGAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x7f }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:6 - 7-bit counter (MSB to LSB)"]
            #[inline]
            pub fn t(&mut self) -> _TW {
                _TW { w: self }
            }
            #[doc = "Bit 7 - Activation bit"]
            #[inline]
            pub fn wdga(&mut self) -> _WDGAW {
                _WDGAW { w: self }
            }
        }
    }
    #[doc = "Configuration register (WWDG_CFR)"]
    pub struct CFR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Configuration register (WWDG_CFR)"]
    pub mod cfr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CFR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WR {
            bits: u8,
        }
        impl WR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `EWI`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EWIR {
            #[doc = "interrupt occurs whenever the counter reaches the value 0x40"]
            ENABLE,
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl EWIR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    EWIR::ENABLE => true,
                    EWIR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> EWIR {
                match value {
                    true => EWIR::ENABLE,
                    i => EWIR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == EWIR::ENABLE
            }
        }
        #[doc = "Possible values of the field `WDGTB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDGTBR {
            #[doc = "Counter clock (PCLK1 div 4096) div 1"]
            DIV1,
            #[doc = "Counter clock (PCLK1 div 4096) div 2"]
            DIV2,
            #[doc = "Counter clock (PCLK1 div 4096) div 4"]
            DIV4,
            #[doc = "Counter clock (PCLK1 div 4096) div 8"]
            DIV8,
        }
        impl WDGTBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    WDGTBR::DIV1 => 0,
                    WDGTBR::DIV2 => 0x01,
                    WDGTBR::DIV4 => 0x02,
                    WDGTBR::DIV8 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> WDGTBR {
                match value {
                    0 => WDGTBR::DIV1,
                    1 => WDGTBR::DIV2,
                    2 => WDGTBR::DIV4,
                    3 => WDGTBR::DIV8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DIV1`"]
            #[inline]
            pub fn is_div1(&self) -> bool {
                *self == WDGTBR::DIV1
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline]
            pub fn is_div2(&self) -> bool {
                *self == WDGTBR::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline]
            pub fn is_div4(&self) -> bool {
                *self == WDGTBR::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline]
            pub fn is_div8(&self) -> bool {
                *self == WDGTBR::DIV8
            }
        }
        #[doc = r" Proxy"]
        pub struct _WW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x7f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EWI`"]
        pub enum EWIW {
            #[doc = "interrupt occurs whenever the counter reaches the value 0x40"]
            ENABLE,
        }
        impl EWIW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    EWIW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EWIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EWIW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EWIW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "interrupt occurs whenever the counter reaches the value 0x40"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(EWIW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDGTB`"]
        pub enum WDGTBW {
            #[doc = "Counter clock (PCLK1 div 4096) div 1"]
            DIV1,
            #[doc = "Counter clock (PCLK1 div 4096) div 2"]
            DIV2,
            #[doc = "Counter clock (PCLK1 div 4096) div 4"]
            DIV4,
            #[doc = "Counter clock (PCLK1 div 4096) div 8"]
            DIV8,
        }
        impl WDGTBW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WDGTBW::DIV1 => 0,
                    WDGTBW::DIV2 => 1,
                    WDGTBW::DIV4 => 2,
                    WDGTBW::DIV8 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDGTBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDGTBW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WDGTBW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Counter clock (PCLK1 div 4096) div 1"]
            #[inline]
            pub fn div1(self) -> &'a mut W {
                self.variant(WDGTBW::DIV1)
            }
            #[doc = "Counter clock (PCLK1 div 4096) div 2"]
            #[inline]
            pub fn div2(self) -> &'a mut W {
                self.variant(WDGTBW::DIV2)
            }
            #[doc = "Counter clock (PCLK1 div 4096) div 4"]
            #[inline]
            pub fn div4(self) -> &'a mut W {
                self.variant(WDGTBW::DIV4)
            }
            #[doc = "Counter clock (PCLK1 div 4096) div 8"]
            #[inline]
            pub fn div8(self) -> &'a mut W {
                self.variant(WDGTBW::DIV8)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:6 - 7-bit window value"]
            #[inline]
            pub fn w(&self) -> WR {
                let bits = {
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WR { bits }
            }
            #[doc = "Bit 9 - Early Wakeup Interrupt"]
            #[inline]
            pub fn ewi(&self) -> EWIR {
                EWIR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 7:8 - Timer Base"]
            #[inline]
            pub fn wdgtb(&self) -> WDGTBR {
                WDGTBR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x7f }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:6 - 7-bit window value"]
            #[inline]
            pub fn w(&mut self) -> _WW {
                _WW { w: self }
            }
            #[doc = "Bit 9 - Early Wakeup Interrupt"]
            #[inline]
            pub fn ewi(&mut self) -> _EWIW {
                _EWIW { w: self }
            }
            #[doc = "Bits 7:8 - Timer Base"]
            #[inline]
            pub fn wdgtb(&mut self) -> _WDGTBW {
                _WDGTBW { w: self }
            }
        }
    }
    #[doc = "Status register (WWDG_SR)"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Status register (WWDG_SR)"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `EWIF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EWIFR {
            #[doc = "The EWI Interrupt Service Routine has been triggered"]
            PENDING,
            #[doc = "The EWI Interrupt Service Routine has been serviced"]
            FINISHED,
        }
        impl EWIFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    EWIFR::PENDING => true,
                    EWIFR::FINISHED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> EWIFR {
                match value {
                    true => EWIFR::PENDING,
                    false => EWIFR::FINISHED,
                }
            }
            #[doc = "Checks if the value of the field is `PENDING`"]
            #[inline]
            pub fn is_pending(&self) -> bool {
                *self == EWIFR::PENDING
            }
            #[doc = "Checks if the value of the field is `FINISHED`"]
            #[inline]
            pub fn is_finished(&self) -> bool {
                *self == EWIFR::FINISHED
            }
        }
        #[doc = "Values that can be written to the field `EWIF`"]
        pub enum EWIFW {
            #[doc = "The EWI Interrupt Service Routine has been serviced"]
            FINISHED,
        }
        impl EWIFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    EWIFW::FINISHED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EWIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EWIFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EWIFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The EWI Interrupt Service Routine has been serviced"]
            #[inline]
            pub fn finished(self) -> &'a mut W {
                self.variant(EWIFW::FINISHED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Early Wakeup Interrupt"]
            #[inline]
            pub fn ewif(&self) -> EWIFR {
                EWIFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Early Wakeup Interrupt"]
            #[inline]
            pub fn ewif(&mut self) -> _EWIFW {
                _EWIFW { w: self }
            }
        }
    }
}
#[doc = "Advanced timer"]
#[cfg(feature = "tim1")]
pub struct TIM1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "tim1")]
unsafe impl Send for TIM1 {}
#[cfg(feature = "tim1")]
impl TIM1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const tim1::RegisterBlock {
        0x4001_2c00 as *const _
    }
}
#[cfg(feature = "tim1")]
impl Deref for TIM1 {
    type Target = tim1::RegisterBlock;
    fn deref(&self) -> &tim1::RegisterBlock {
        unsafe { &*TIM1::ptr() }
    }
}
#[doc = "Advanced timer"]
#[cfg(feature = "tim1")]
pub mod tim1 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - slave mode control register"]
        pub smcr: SMCR,
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        pub ccmr1_output: CCMR1_OUTPUT,
        #[doc = "0x1c - capture/compare mode register (output mode)"]
        pub ccmr2_output: CCMR2_OUTPUT,
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: CCER,
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
        #[doc = "0x30 - repetition counter register"]
        pub rcr: RCR,
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: CCR1,
        #[doc = "0x38 - capture/compare register 2"]
        pub ccr2: CCR2,
        #[doc = "0x3c - capture/compare register 3"]
        pub ccr3: CCR3,
        #[doc = "0x40 - capture/compare register 4"]
        pub ccr4: CCR4,
        #[doc = "0x44 - break and dead-time register"]
        pub bdtr: BDTR,
        #[doc = "0x48 - DMA control register"]
        pub dcr: DCR,
        #[doc = "0x4c - DMA address for full transfer"]
        pub dmar: DMAR,
    }
    #[doc = "control register 1"]
    pub struct CR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CKDR {
            bits: u8,
        }
        impl CKDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `ARPE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPER {
            #[doc = "TIMx_APRR register is not buffered"]
            DISABLED,
            #[doc = "TIMx_APRR register is buffered"]
            ENABLED,
        }
        impl ARPER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ARPER::DISABLED => false,
                    ARPER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ARPER {
                match value {
                    false => ARPER::DISABLED,
                    true => ARPER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ARPER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ARPER::ENABLED
            }
        }
        #[doc = r" Value of the field"]
        pub struct CMSR {
            bits: u8,
        }
        impl CMSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIRR {
            bits: bool,
        }
        impl DIRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `OPM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPMR {
            #[doc = "Counter is not stopped at update event"]
            DISABLED,
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            ENABLED,
        }
        impl OPMR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OPMR::DISABLED => false,
                    OPMR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OPMR {
                match value {
                    false => OPMR::DISABLED,
                    true => OPMR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == OPMR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == OPMR::ENABLED
            }
        }
        #[doc = "Possible values of the field `URS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URSR {
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT,
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY,
        }
        impl URSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    URSR::ANYEVENT => false,
                    URSR::COUNTERONLY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> URSR {
                match value {
                    false => URSR::ANYEVENT,
                    true => URSR::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline]
            pub fn is_any_event(&self) -> bool {
                *self == URSR::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline]
            pub fn is_counter_only(&self) -> bool {
                *self == URSR::COUNTERONLY
            }
        }
        #[doc = "Possible values of the field `UDIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDISR {
            #[doc = "Update event enabled"]
            ENABLED,
            #[doc = "Update event disabled"]
            DISABLED,
        }
        impl UDISR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UDISR::ENABLED => false,
                    UDISR::DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UDISR {
                match value {
                    false => UDISR::ENABLED,
                    true => UDISR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UDISR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UDISR::DISABLED
            }
        }
        #[doc = "Possible values of the field `CEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CENR {
            #[doc = "Counter disabled"]
            DISABLED,
            #[doc = "Counter enabled"]
            ENABLED,
        }
        impl CENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CENR::DISABLED => false,
                    CENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CENR {
                match value {
                    false => CENR::DISABLED,
                    true => CENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CENR::ENABLED
            }
        }
        #[doc = r" Proxy"]
        pub struct _CKDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CKDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ARPE`"]
        pub enum ARPEW {
            #[doc = "TIMx_APRR register is not buffered"]
            DISABLED,
            #[doc = "TIMx_APRR register is buffered"]
            ENABLED,
        }
        impl ARPEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ARPEW::DISABLED => false,
                    ARPEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ARPEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ARPEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ARPEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPEW::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OPM`"]
        pub enum OPMW {
            #[doc = "Counter is not stopped at update event"]
            DISABLED,
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            ENABLED,
        }
        impl OPMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OPMW::DISABLED => false,
                    OPMW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OPMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OPMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OPMW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Counter is not stopped at update event"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OPMW::DISABLED)
            }
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OPMW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `URS`"]
        pub enum URSW {
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT,
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY,
        }
        impl URSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    URSW::ANYEVENT => false,
                    URSW::COUNTERONLY => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _URSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _URSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: URSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URSW::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URSW::COUNTERONLY)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UDIS`"]
        pub enum UDISW {
            #[doc = "Update event enabled"]
            ENABLED,
            #[doc = "Update event disabled"]
            DISABLED,
        }
        impl UDISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UDISW::ENABLED => false,
                    UDISW::DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UDISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UDISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UDISW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Update event enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDISW::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDISW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CEN`"]
        pub enum CENW {
            #[doc = "Counter disabled"]
            DISABLED,
            #[doc = "Counter enabled"]
            ENABLED,
        }
        impl CENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CENW::DISABLED => false,
                    CENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Counter disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CENW::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline]
            pub fn ckd(&self) -> CKDR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CKDR { bits }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline]
            pub fn arpe(&self) -> ARPER {
                ARPER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline]
            pub fn cms(&self) -> CMSR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CMSR { bits }
            }
            #[doc = "Bit 4 - Direction"]
            #[inline]
            pub fn dir(&self) -> DIRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DIRR { bits }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline]
            pub fn opm(&self) -> OPMR {
                OPMR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline]
            pub fn urs(&self) -> URSR {
                URSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline]
            pub fn udis(&self) -> UDISR {
                UDISR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline]
            pub fn cen(&self) -> CENR {
                CENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline]
            pub fn ckd(&mut self) -> _CKDW {
                _CKDW { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline]
            pub fn arpe(&mut self) -> _ARPEW {
                _ARPEW { w: self }
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline]
            pub fn cms(&mut self) -> _CMSW {
                _CMSW { w: self }
            }
            #[doc = "Bit 4 - Direction"]
            #[inline]
            pub fn dir(&mut self) -> _DIRW {
                _DIRW { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline]
            pub fn opm(&mut self) -> _OPMW {
                _OPMW { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline]
            pub fn urs(&mut self) -> _URSW {
                _URSW { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline]
            pub fn udis(&mut self) -> _UDISW {
                _UDISW { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline]
            pub fn cen(&mut self) -> _CENW {
                _CENW { w: self }
            }
        }
    }
    #[doc = "control register 2"]
    pub struct CR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OIS4R {
            bits: bool,
        }
        impl OIS4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OIS3NR {
            bits: bool,
        }
        impl OIS3NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OIS3R {
            bits: bool,
        }
        impl OIS3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OIS2NR {
            bits: bool,
        }
        impl OIS2NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OIS2R {
            bits: bool,
        }
        impl OIS2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OIS1NR {
            bits: bool,
        }
        impl OIS1NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OIS1R {
            bits: bool,
        }
        impl OIS1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TI1SR {
            bits: bool,
        }
        impl TI1SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MMSR {
            bits: u8,
        }
        impl MMSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCDSR {
            bits: bool,
        }
        impl CCDSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCUSR {
            bits: bool,
        }
        impl CCUSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCPCR {
            bits: bool,
        }
        impl CCPCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _OIS4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OIS4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OIS3NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OIS3NW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OIS3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OIS3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OIS2NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OIS2NW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OIS2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OIS2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OIS1NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OIS1NW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OIS1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OIS1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TI1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TI1SW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MMSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MMSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCDSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCDSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCUSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCUSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCPCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCPCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 14 - Output Idle state 4"]
            #[inline]
            pub fn ois4(&self) -> OIS4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OIS4R { bits }
            }
            #[doc = "Bit 13 - Output Idle state 3"]
            #[inline]
            pub fn ois3n(&self) -> OIS3NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OIS3NR { bits }
            }
            #[doc = "Bit 12 - Output Idle state 3"]
            #[inline]
            pub fn ois3(&self) -> OIS3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OIS3R { bits }
            }
            #[doc = "Bit 11 - Output Idle state 2"]
            #[inline]
            pub fn ois2n(&self) -> OIS2NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OIS2NR { bits }
            }
            #[doc = "Bit 10 - Output Idle state 2"]
            #[inline]
            pub fn ois2(&self) -> OIS2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OIS2R { bits }
            }
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline]
            pub fn ois1n(&self) -> OIS1NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OIS1NR { bits }
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline]
            pub fn ois1(&self) -> OIS1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OIS1R { bits }
            }
            #[doc = "Bit 7 - TI1 selection"]
            #[inline]
            pub fn ti1s(&self) -> TI1SR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TI1SR { bits }
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline]
            pub fn mms(&self) -> MMSR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MMSR { bits }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline]
            pub fn ccds(&self) -> CCDSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CCDSR { bits }
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline]
            pub fn ccus(&self) -> CCUSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CCUSR { bits }
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline]
            pub fn ccpc(&self) -> CCPCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CCPCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 14 - Output Idle state 4"]
            #[inline]
            pub fn ois4(&mut self) -> _OIS4W {
                _OIS4W { w: self }
            }
            #[doc = "Bit 13 - Output Idle state 3"]
            #[inline]
            pub fn ois3n(&mut self) -> _OIS3NW {
                _OIS3NW { w: self }
            }
            #[doc = "Bit 12 - Output Idle state 3"]
            #[inline]
            pub fn ois3(&mut self) -> _OIS3W {
                _OIS3W { w: self }
            }
            #[doc = "Bit 11 - Output Idle state 2"]
            #[inline]
            pub fn ois2n(&mut self) -> _OIS2NW {
                _OIS2NW { w: self }
            }
            #[doc = "Bit 10 - Output Idle state 2"]
            #[inline]
            pub fn ois2(&mut self) -> _OIS2W {
                _OIS2W { w: self }
            }
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline]
            pub fn ois1n(&mut self) -> _OIS1NW {
                _OIS1NW { w: self }
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline]
            pub fn ois1(&mut self) -> _OIS1W {
                _OIS1W { w: self }
            }
            #[doc = "Bit 7 - TI1 selection"]
            #[inline]
            pub fn ti1s(&mut self) -> _TI1SW {
                _TI1SW { w: self }
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline]
            pub fn mms(&mut self) -> _MMSW {
                _MMSW { w: self }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline]
            pub fn ccds(&mut self) -> _CCDSW {
                _CCDSW { w: self }
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline]
            pub fn ccus(&mut self) -> _CCUSW {
                _CCUSW { w: self }
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline]
            pub fn ccpc(&mut self) -> _CCPCW {
                _CCPCW { w: self }
            }
        }
    }
    #[doc = "slave mode control register"]
    pub struct SMCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "slave mode control register"]
    pub mod smcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SMCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ETPR {
            bits: bool,
        }
        impl ETPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ECER {
            bits: bool,
        }
        impl ECER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ETPSR {
            bits: u8,
        }
        impl ETPSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ETFR {
            bits: u8,
        }
        impl ETFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSMR {
            bits: bool,
        }
        impl MSMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TSR {
            bits: u8,
        }
        impl TSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMSR {
            bits: u8,
        }
        impl SMSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ETPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ETPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ECEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ECEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ETPSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ETPSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ETFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ETFW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline]
            pub fn etp(&self) -> ETPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ETPR { bits }
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline]
            pub fn ece(&self) -> ECER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ECER { bits }
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline]
            pub fn etps(&self) -> ETPSR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ETPSR { bits }
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline]
            pub fn etf(&self) -> ETFR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ETFR { bits }
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline]
            pub fn msm(&self) -> MSMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MSMR { bits }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline]
            pub fn ts(&self) -> TSR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TSR { bits }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline]
            pub fn sms(&self) -> SMSR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline]
            pub fn etp(&mut self) -> _ETPW {
                _ETPW { w: self }
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline]
            pub fn ece(&mut self) -> _ECEW {
                _ECEW { w: self }
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline]
            pub fn etps(&mut self) -> _ETPSW {
                _ETPSW { w: self }
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline]
            pub fn etf(&mut self) -> _ETFW {
                _ETFW { w: self }
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline]
            pub fn msm(&mut self) -> _MSMW {
                _MSMW { w: self }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline]
            pub fn ts(&mut self) -> _TSW {
                _TSW { w: self }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline]
            pub fn sms(&mut self) -> _SMSW {
                _SMSW { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register"]
    pub struct DIER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIER {
            #[doc = "Update interrupt disabled"]
            DISABLED,
            #[doc = "Update interrupt enabled"]
            ENABLED,
        }
        impl UIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UIER::DISABLED => false,
                    UIER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UIER {
                match value {
                    false => UIER::DISABLED,
                    true => UIER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UIER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UIER::ENABLED
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1IER {
            bits: bool,
        }
        impl CC1IER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2IER {
            bits: bool,
        }
        impl CC2IER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC3IER {
            bits: bool,
        }
        impl CC3IER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC4IER {
            bits: bool,
        }
        impl CC4IER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMIER {
            bits: bool,
        }
        impl COMIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIER {
            bits: bool,
        }
        impl TIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BIER {
            bits: bool,
        }
        impl BIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct UDER {
            bits: bool,
        }
        impl UDER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1DER {
            bits: bool,
        }
        impl CC1DER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2DER {
            bits: bool,
        }
        impl CC2DER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC3DER {
            bits: bool,
        }
        impl CC3DER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC4DER {
            bits: bool,
        }
        impl CC4DER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMDER {
            bits: bool,
        }
        impl COMDER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TDER {
            bits: bool,
        }
        impl TDER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `UIE`"]
        pub enum UIEW {
            #[doc = "Update interrupt disabled"]
            DISABLED,
            #[doc = "Update interrupt enabled"]
            ENABLED,
        }
        impl UIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UIEW::DISABLED => false,
                    UIEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIEW::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1IEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1IEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2IEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2IEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC3IEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3IEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4IEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4IEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UDEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UDEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1DEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1DEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2DEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2DEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC3DEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3DEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4DEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4DEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMDEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMDEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TDEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TDEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline]
            pub fn uie(&self) -> UIER {
                UIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline]
            pub fn cc1ie(&self) -> CC1IER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1IER { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline]
            pub fn cc2ie(&self) -> CC2IER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2IER { bits }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
            #[inline]
            pub fn cc3ie(&self) -> CC3IER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC3IER { bits }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
            #[inline]
            pub fn cc4ie(&self) -> CC4IER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC4IER { bits }
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline]
            pub fn comie(&self) -> COMIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                COMIER { bits }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline]
            pub fn tie(&self) -> TIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIER { bits }
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline]
            pub fn bie(&self) -> BIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BIER { bits }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline]
            pub fn ude(&self) -> UDER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                UDER { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline]
            pub fn cc1de(&self) -> CC1DER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1DER { bits }
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline]
            pub fn cc2de(&self) -> CC2DER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2DER { bits }
            }
            #[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
            #[inline]
            pub fn cc3de(&self) -> CC3DER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC3DER { bits }
            }
            #[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
            #[inline]
            pub fn cc4de(&self) -> CC4DER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC4DER { bits }
            }
            #[doc = "Bit 13 - COM DMA request enable"]
            #[inline]
            pub fn comde(&self) -> COMDER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                COMDER { bits }
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline]
            pub fn tde(&self) -> TDER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TDER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline]
            pub fn uie(&mut self) -> _UIEW {
                _UIEW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline]
            pub fn cc1ie(&mut self) -> _CC1IEW {
                _CC1IEW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline]
            pub fn cc2ie(&mut self) -> _CC2IEW {
                _CC2IEW { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
            #[inline]
            pub fn cc3ie(&mut self) -> _CC3IEW {
                _CC3IEW { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
            #[inline]
            pub fn cc4ie(&mut self) -> _CC4IEW {
                _CC4IEW { w: self }
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline]
            pub fn comie(&mut self) -> _COMIEW {
                _COMIEW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline]
            pub fn tie(&mut self) -> _TIEW {
                _TIEW { w: self }
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline]
            pub fn bie(&mut self) -> _BIEW {
                _BIEW { w: self }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline]
            pub fn ude(&mut self) -> _UDEW {
                _UDEW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline]
            pub fn cc1de(&mut self) -> _CC1DEW {
                _CC1DEW { w: self }
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline]
            pub fn cc2de(&mut self) -> _CC2DEW {
                _CC2DEW { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
            #[inline]
            pub fn cc3de(&mut self) -> _CC3DEW {
                _CC3DEW { w: self }
            }
            #[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
            #[inline]
            pub fn cc4de(&mut self) -> _CC4DEW {
                _CC4DEW { w: self }
            }
            #[doc = "Bit 13 - COM DMA request enable"]
            #[inline]
            pub fn comde(&mut self) -> _COMDEW {
                _COMDEW { w: self }
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline]
            pub fn tde(&mut self) -> _TDEW {
                _TDEW { w: self }
            }
        }
    }
    #[doc = "status register"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC4OFR {
            bits: bool,
        }
        impl CC4OFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC3OFR {
            bits: bool,
        }
        impl CC3OFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2OFR {
            bits: bool,
        }
        impl CC2OFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1OFR {
            bits: bool,
        }
        impl CC1OFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BIFR {
            bits: bool,
        }
        impl BIFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIFR {
            bits: bool,
        }
        impl TIFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMIFR {
            bits: bool,
        }
        impl COMIFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC4IFR {
            bits: bool,
        }
        impl CC4IFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC3IFR {
            bits: bool,
        }
        impl CC3IFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2IFR {
            bits: bool,
        }
        impl CC2IFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1IFR {
            bits: bool,
        }
        impl CC1IFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `UIF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIFR {
            #[doc = "No update occurred"]
            CLEAR,
            #[doc = "Update interrupt pending."]
            UPDATEPENDING,
        }
        impl UIFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UIFR::CLEAR => false,
                    UIFR::UPDATEPENDING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UIFR {
                match value {
                    false => UIFR::CLEAR,
                    true => UIFR::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline]
            pub fn is_clear(&self) -> bool {
                *self == UIFR::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline]
            pub fn is_update_pending(&self) -> bool {
                *self == UIFR::UPDATEPENDING
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4OFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4OFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC3OFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3OFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2OFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2OFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1OFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1OFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMIFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4IFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4IFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC3IFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3IFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2IFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2IFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1IFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1IFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UIF`"]
        pub enum UIFW {
            #[doc = "No update occurred"]
            CLEAR,
            #[doc = "Update interrupt pending."]
            UPDATEPENDING,
        }
        impl UIFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UIFW::CLEAR => false,
                    UIFW::UPDATEPENDING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UIFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UIFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No update occurred"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIFW::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIFW::UPDATEPENDING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
            #[inline]
            pub fn cc4of(&self) -> CC4OFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC4OFR { bits }
            }
            #[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
            #[inline]
            pub fn cc3of(&self) -> CC3OFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC3OFR { bits }
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline]
            pub fn cc2of(&self) -> CC2OFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2OFR { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline]
            pub fn cc1of(&self) -> CC1OFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1OFR { bits }
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline]
            pub fn bif(&self) -> BIFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BIFR { bits }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline]
            pub fn tif(&self) -> TIFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIFR { bits }
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline]
            pub fn comif(&self) -> COMIFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                COMIFR { bits }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
            #[inline]
            pub fn cc4if(&self) -> CC4IFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC4IFR { bits }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
            #[inline]
            pub fn cc3if(&self) -> CC3IFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC3IFR { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline]
            pub fn cc2if(&self) -> CC2IFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2IFR { bits }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline]
            pub fn cc1if(&self) -> CC1IFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1IFR { bits }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline]
            pub fn uif(&self) -> UIFR {
                UIFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
            #[inline]
            pub fn cc4of(&mut self) -> _CC4OFW {
                _CC4OFW { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
            #[inline]
            pub fn cc3of(&mut self) -> _CC3OFW {
                _CC3OFW { w: self }
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline]
            pub fn cc2of(&mut self) -> _CC2OFW {
                _CC2OFW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline]
            pub fn cc1of(&mut self) -> _CC1OFW {
                _CC1OFW { w: self }
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline]
            pub fn bif(&mut self) -> _BIFW {
                _BIFW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline]
            pub fn tif(&mut self) -> _TIFW {
                _TIFW { w: self }
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline]
            pub fn comif(&mut self) -> _COMIFW {
                _COMIFW { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
            #[inline]
            pub fn cc4if(&mut self) -> _CC4IFW {
                _CC4IFW { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
            #[inline]
            pub fn cc3if(&mut self) -> _CC3IFW {
                _CC3IFW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline]
            pub fn cc2if(&mut self) -> _CC2IFW {
                _CC2IFW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline]
            pub fn cc1if(&mut self) -> _CC1IFW {
                _CC1IFW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline]
            pub fn uif(&mut self) -> _UIFW {
                _UIFW { w: self }
            }
        }
    }
    #[doc = "event generation register"]
    pub struct EGR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EGR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _BGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4GW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4GW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC3GW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3GW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2GW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2GW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1GW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1GW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UG`"]
        pub enum UGW {
            #[doc = "Re-initializes the timer counter and generates an update of the reigsters."]
            UPDATE,
        }
        impl UGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UGW::UPDATE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the reigsters."]
            #[inline]
            pub fn update(self) -> &'a mut W {
                self.variant(UGW::UPDATE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Break generation"]
            #[inline]
            pub fn bg(&mut self) -> _BGW {
                _BGW { w: self }
            }
            #[doc = "Bit 6 - Trigger generation"]
            #[inline]
            pub fn tg(&mut self) -> _TGW {
                _TGW { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare control update generation"]
            #[inline]
            pub fn comg(&mut self) -> _COMGW {
                _COMGW { w: self }
            }
            #[doc = "Bit 4 - Capture/compare 4 generation"]
            #[inline]
            pub fn cc4g(&mut self) -> _CC4GW {
                _CC4GW { w: self }
            }
            #[doc = "Bit 3 - Capture/compare 3 generation"]
            #[inline]
            pub fn cc3g(&mut self) -> _CC3GW {
                _CC3GW { w: self }
            }
            #[doc = "Bit 2 - Capture/compare 2 generation"]
            #[inline]
            pub fn cc2g(&mut self) -> _CC2GW {
                _CC2GW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline]
            pub fn cc1g(&mut self) -> _CC1GW {
                _CC1GW { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline]
            pub fn ug(&mut self) -> _UGW {
                _UGW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub struct CCMR1_OUTPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr1_output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCMR1_OUTPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC2CER {
            bits: bool,
        }
        impl OC2CER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC2MR {
            bits: u8,
        }
        impl OC2MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC2PER {
            bits: bool,
        }
        impl OC2PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC2FER {
            bits: bool,
        }
        impl OC2FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2SR {
            bits: u8,
        }
        impl CC2SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1CER {
            bits: bool,
        }
        impl OC1CER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1MR {
            bits: u8,
        }
        impl OC1MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1PER {
            bits: bool,
        }
        impl OC1PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1FER {
            bits: bool,
        }
        impl OC1FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1SR {
            bits: u8,
        }
        impl CC1SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC2CEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC2CEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC2MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC2MW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC2PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC2PEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC2FEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC2FEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1CEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1CEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1MW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1PEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1FEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1FEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Output Compare 2 clear enable"]
            #[inline]
            pub fn oc2ce(&self) -> OC2CER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC2CER { bits }
            }
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline]
            pub fn oc2m(&self) -> OC2MR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OC2MR { bits }
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline]
            pub fn oc2pe(&self) -> OC2PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC2PER { bits }
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline]
            pub fn oc2fe(&self) -> OC2FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC2FER { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline]
            pub fn cc2s(&self) -> CC2SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC2SR { bits }
            }
            #[doc = "Bit 7 - Output Compare 1 clear enable"]
            #[inline]
            pub fn oc1ce(&self) -> OC1CER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC1CER { bits }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline]
            pub fn oc1m(&self) -> OC1MR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OC1MR { bits }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline]
            pub fn oc1pe(&self) -> OC1PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC1PER { bits }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline]
            pub fn oc1fe(&self) -> OC1FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC1FER { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&self) -> CC1SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC1SR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Output Compare 2 clear enable"]
            #[inline]
            pub fn oc2ce(&mut self) -> _OC2CEW {
                _OC2CEW { w: self }
            }
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline]
            pub fn oc2m(&mut self) -> _OC2MW {
                _OC2MW { w: self }
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline]
            pub fn oc2pe(&mut self) -> _OC2PEW {
                _OC2PEW { w: self }
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline]
            pub fn oc2fe(&mut self) -> _OC2FEW {
                _OC2FEW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline]
            pub fn cc2s(&mut self) -> _CC2SW {
                _CC2SW { w: self }
            }
            #[doc = "Bit 7 - Output Compare 1 clear enable"]
            #[inline]
            pub fn oc1ce(&mut self) -> _OC1CEW {
                _OC1CEW { w: self }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline]
            pub fn oc1m(&mut self) -> _OC1MW {
                _OC1MW { w: self }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline]
            pub fn oc1pe(&mut self) -> _OC1PEW {
                _OC1PEW { w: self }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline]
            pub fn oc1fe(&mut self) -> _OC1FEW {
                _OC1FEW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&mut self) -> _CC1SW {
                _CC1SW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub struct CCMR1_INPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCMR1_INPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC2FR {
            bits: u8,
        }
        impl IC2FR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC2PSCR {
            bits: u8,
        }
        impl IC2PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2SR {
            bits: u8,
        }
        impl CC2SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC1FR {
            bits: u8,
        }
        impl IC1FR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC1PSCR {
            bits: u8,
        }
        impl IC1PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1SR {
            bits: u8,
        }
        impl CC1SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC2FW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC2FW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC2PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC2PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC1FW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC1FW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC1PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC1PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 15:18 - Input capture 2 filter"]
            #[inline]
            pub fn ic2f(&self) -> IC2FR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC2FR { bits }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline]
            pub fn ic2psc(&self) -> IC2PSCR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC2PSCR { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline]
            pub fn cc2s(&self) -> CC2SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC2SR { bits }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline]
            pub fn ic1f(&self) -> IC1FR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC1FR { bits }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline]
            pub fn ic1psc(&self) -> IC1PSCR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC1PSCR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&self) -> CC1SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC1SR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 15:18 - Input capture 2 filter"]
            #[inline]
            pub fn ic2f(&mut self) -> _IC2FW {
                _IC2FW { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline]
            pub fn ic2psc(&mut self) -> _IC2PSCW {
                _IC2PSCW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline]
            pub fn cc2s(&mut self) -> _CC2SW {
                _CC2SW { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline]
            pub fn ic1f(&mut self) -> _IC1FW {
                _IC1FW { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline]
            pub fn ic1psc(&mut self) -> _IC1PSCW {
                _IC1PSCW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&mut self) -> _CC1SW {
                _CC1SW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub struct CCMR2_OUTPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr2_output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCMR2_OUTPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC4CER {
            bits: bool,
        }
        impl OC4CER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC4MR {
            bits: u8,
        }
        impl OC4MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC4PER {
            bits: bool,
        }
        impl OC4PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC4FER {
            bits: bool,
        }
        impl OC4FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC4SR {
            bits: u8,
        }
        impl CC4SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC3CER {
            bits: bool,
        }
        impl OC3CER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC3MR {
            bits: u8,
        }
        impl OC3MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC3PER {
            bits: bool,
        }
        impl OC3PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC3FER {
            bits: bool,
        }
        impl OC3FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC3SR {
            bits: u8,
        }
        impl CC3SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC4CEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC4CEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC4MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC4MW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC4PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC4PEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC4FEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC4FEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC3CEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC3CEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC3MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC3MW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC3PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC3PEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC3FEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC3FEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC3SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Output compare 4 clear enable"]
            #[inline]
            pub fn oc4ce(&self) -> OC4CER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC4CER { bits }
            }
            #[doc = "Bits 12:14 - Output compare 4 mode"]
            #[inline]
            pub fn oc4m(&self) -> OC4MR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OC4MR { bits }
            }
            #[doc = "Bit 11 - Output compare 4 preload enable"]
            #[inline]
            pub fn oc4pe(&self) -> OC4PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC4PER { bits }
            }
            #[doc = "Bit 10 - Output compare 4 fast enable"]
            #[inline]
            pub fn oc4fe(&self) -> OC4FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC4FER { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline]
            pub fn cc4s(&self) -> CC4SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC4SR { bits }
            }
            #[doc = "Bit 7 - Output compare 3 clear enable"]
            #[inline]
            pub fn oc3ce(&self) -> OC3CER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC3CER { bits }
            }
            #[doc = "Bits 4:6 - Output compare 3 mode"]
            #[inline]
            pub fn oc3m(&self) -> OC3MR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OC3MR { bits }
            }
            #[doc = "Bit 3 - Output compare 3 preload enable"]
            #[inline]
            pub fn oc3pe(&self) -> OC3PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC3PER { bits }
            }
            #[doc = "Bit 2 - Output compare 3 fast enable"]
            #[inline]
            pub fn oc3fe(&self) -> OC3FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC3FER { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline]
            pub fn cc3s(&self) -> CC3SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC3SR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Output compare 4 clear enable"]
            #[inline]
            pub fn oc4ce(&mut self) -> _OC4CEW {
                _OC4CEW { w: self }
            }
            #[doc = "Bits 12:14 - Output compare 4 mode"]
            #[inline]
            pub fn oc4m(&mut self) -> _OC4MW {
                _OC4MW { w: self }
            }
            #[doc = "Bit 11 - Output compare 4 preload enable"]
            #[inline]
            pub fn oc4pe(&mut self) -> _OC4PEW {
                _OC4PEW { w: self }
            }
            #[doc = "Bit 10 - Output compare 4 fast enable"]
            #[inline]
            pub fn oc4fe(&mut self) -> _OC4FEW {
                _OC4FEW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline]
            pub fn cc4s(&mut self) -> _CC4SW {
                _CC4SW { w: self }
            }
            #[doc = "Bit 7 - Output compare 3 clear enable"]
            #[inline]
            pub fn oc3ce(&mut self) -> _OC3CEW {
                _OC3CEW { w: self }
            }
            #[doc = "Bits 4:6 - Output compare 3 mode"]
            #[inline]
            pub fn oc3m(&mut self) -> _OC3MW {
                _OC3MW { w: self }
            }
            #[doc = "Bit 3 - Output compare 3 preload enable"]
            #[inline]
            pub fn oc3pe(&mut self) -> _OC3PEW {
                _OC3PEW { w: self }
            }
            #[doc = "Bit 2 - Output compare 3 fast enable"]
            #[inline]
            pub fn oc3fe(&mut self) -> _OC3FEW {
                _OC3FEW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline]
            pub fn cc3s(&mut self) -> _CC3SW {
                _CC3SW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 2 (input mode)"]
    pub struct CCMR2_INPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 2 (input mode)"]
    pub mod ccmr2_input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCMR2_INPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC4FR {
            bits: u8,
        }
        impl IC4FR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC4PSCR {
            bits: u8,
        }
        impl IC4PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC4SR {
            bits: u8,
        }
        impl CC4SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC3FR {
            bits: u8,
        }
        impl IC3FR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC3PSCR {
            bits: u8,
        }
        impl IC3PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC3SR {
            bits: u8,
        }
        impl CC3SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC4FW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC4FW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC4PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC4PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC3FW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC3FW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC3PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC3PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC3SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 15:18 - Input capture 4 filter"]
            #[inline]
            pub fn ic4f(&self) -> IC4FR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC4FR { bits }
            }
            #[doc = "Bits 10:11 - Input capture 4 prescaler"]
            #[inline]
            pub fn ic4psc(&self) -> IC4PSCR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC4PSCR { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline]
            pub fn cc4s(&self) -> CC4SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC4SR { bits }
            }
            #[doc = "Bits 4:7 - Input capture 3 filter"]
            #[inline]
            pub fn ic3f(&self) -> IC3FR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC3FR { bits }
            }
            #[doc = "Bits 2:3 - Input capture 3 prescaler"]
            #[inline]
            pub fn ic3psc(&self) -> IC3PSCR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC3PSCR { bits }
            }
            #[doc = "Bits 0:1 - Capture/compare 3 selection"]
            #[inline]
            pub fn cc3s(&self) -> CC3SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC3SR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 15:18 - Input capture 4 filter"]
            #[inline]
            pub fn ic4f(&mut self) -> _IC4FW {
                _IC4FW { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 4 prescaler"]
            #[inline]
            pub fn ic4psc(&mut self) -> _IC4PSCW {
                _IC4PSCW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline]
            pub fn cc4s(&mut self) -> _CC4SW {
                _CC4SW { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 3 filter"]
            #[inline]
            pub fn ic3f(&mut self) -> _IC3FW {
                _IC3FW { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 3 prescaler"]
            #[inline]
            pub fn ic3psc(&mut self) -> _IC3PSCW {
                _IC3PSCW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/compare 3 selection"]
            #[inline]
            pub fn cc3s(&mut self) -> _CC3SW {
                _CC3SW { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register"]
    pub struct CCER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC4PR {
            bits: bool,
        }
        impl CC4PR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC4ER {
            bits: bool,
        }
        impl CC4ER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC3NPR {
            bits: bool,
        }
        impl CC3NPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC3NER {
            bits: bool,
        }
        impl CC3NER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC3PR {
            bits: bool,
        }
        impl CC3PR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC3ER {
            bits: bool,
        }
        impl CC3ER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2NPR {
            bits: bool,
        }
        impl CC2NPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2NER {
            bits: bool,
        }
        impl CC2NER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2PR {
            bits: bool,
        }
        impl CC2PR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2ER {
            bits: bool,
        }
        impl CC2ER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1NPR {
            bits: bool,
        }
        impl CC1NPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1NER {
            bits: bool,
        }
        impl CC1NER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1PR {
            bits: bool,
        }
        impl CC1PR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1ER {
            bits: bool,
        }
        impl CC1ER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4PW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4PW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4EW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4EW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC3NPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3NPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC3NEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3NEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC3PW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3PW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC3EW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3EW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2NPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2NPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2NEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2NEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2PW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2PW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2EW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2EW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1NPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1NPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1NEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1NEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1PW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1PW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1EW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1EW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
            #[inline]
            pub fn cc4p(&self) -> CC4PR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC4PR { bits }
            }
            #[doc = "Bit 12 - Capture/Compare 4 output enable"]
            #[inline]
            pub fn cc4e(&self) -> CC4ER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC4ER { bits }
            }
            #[doc = "Bit 11 - Capture/Compare 3 output Polarity"]
            #[inline]
            pub fn cc3np(&self) -> CC3NPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC3NPR { bits }
            }
            #[doc = "Bit 10 - Capture/Compare 3 complementary output enable"]
            #[inline]
            pub fn cc3ne(&self) -> CC3NER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC3NER { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
            #[inline]
            pub fn cc3p(&self) -> CC3PR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC3PR { bits }
            }
            #[doc = "Bit 8 - Capture/Compare 3 output enable"]
            #[inline]
            pub fn cc3e(&self) -> CC3ER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC3ER { bits }
            }
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline]
            pub fn cc2np(&self) -> CC2NPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2NPR { bits }
            }
            #[doc = "Bit 6 - Capture/Compare 2 complementary output enable"]
            #[inline]
            pub fn cc2ne(&self) -> CC2NER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2NER { bits }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline]
            pub fn cc2p(&self) -> CC2PR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2PR { bits }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline]
            pub fn cc2e(&self) -> CC2ER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2ER { bits }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1np(&self) -> CC1NPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1NPR { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline]
            pub fn cc1ne(&self) -> CC1NER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1NER { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1p(&self) -> CC1PR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1PR { bits }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline]
            pub fn cc1e(&self) -> CC1ER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1ER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
            #[inline]
            pub fn cc4p(&mut self) -> _CC4PW {
                _CC4PW { w: self }
            }
            #[doc = "Bit 12 - Capture/Compare 4 output enable"]
            #[inline]
            pub fn cc4e(&mut self) -> _CC4EW {
                _CC4EW { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 output Polarity"]
            #[inline]
            pub fn cc3np(&mut self) -> _CC3NPW {
                _CC3NPW { w: self }
            }
            #[doc = "Bit 10 - Capture/Compare 3 complementary output enable"]
            #[inline]
            pub fn cc3ne(&mut self) -> _CC3NEW {
                _CC3NEW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
            #[inline]
            pub fn cc3p(&mut self) -> _CC3PW {
                _CC3PW { w: self }
            }
            #[doc = "Bit 8 - Capture/Compare 3 output enable"]
            #[inline]
            pub fn cc3e(&mut self) -> _CC3EW {
                _CC3EW { w: self }
            }
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline]
            pub fn cc2np(&mut self) -> _CC2NPW {
                _CC2NPW { w: self }
            }
            #[doc = "Bit 6 - Capture/Compare 2 complementary output enable"]
            #[inline]
            pub fn cc2ne(&mut self) -> _CC2NEW {
                _CC2NEW { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline]
            pub fn cc2p(&mut self) -> _CC2PW {
                _CC2PW { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline]
            pub fn cc2e(&mut self) -> _CC2EW {
                _CC2EW { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1np(&mut self) -> _CC1NPW {
                _CC1NPW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline]
            pub fn cc1ne(&mut self) -> _CC1NEW {
                _CC1NEW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1p(&mut self) -> _CC1PW {
                _CC1PW { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline]
            pub fn cc1e(&mut self) -> _CC1EW {
                _CC1EW { w: self }
            }
        }
    }
    #[doc = "counter"]
    pub struct CNT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "counter"]
    pub mod cnt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNTR {
            bits: u16,
        }
        impl CNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline]
            pub fn cnt(&self) -> CNTR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline]
            pub fn cnt(&mut self) -> _CNTW {
                _CNTW { w: self }
            }
        }
    }
    #[doc = "prescaler"]
    pub struct PSC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PSCR {
            bits: u16,
        }
        impl PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline]
            pub fn psc(&self) -> PSCR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PSCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline]
            pub fn psc(&mut self) -> _PSCW {
                _PSCW { w: self }
            }
        }
    }
    #[doc = "auto-reload register"]
    pub struct ARR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ARR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ARRR {
            bits: u16,
        }
        impl ARRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ARRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ARRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline]
            pub fn arr(&self) -> ARRR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ARRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline]
            pub fn arr(&mut self) -> _ARRW {
                _ARRW { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1"]
    pub struct CCR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare register 1"]
    pub mod ccr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCR1R {
            bits: u16,
        }
        impl CCR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCR1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline]
            pub fn ccr1(&self) -> CCR1R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CCR1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline]
            pub fn ccr1(&mut self) -> _CCR1W {
                _CCR1W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 2"]
    pub struct CCR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare register 2"]
    pub mod ccr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCR2R {
            bits: u16,
        }
        impl CCR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCR2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 2 value"]
            #[inline]
            pub fn ccr2(&self) -> CCR2R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CCR2R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 2 value"]
            #[inline]
            pub fn ccr2(&mut self) -> _CCR2W {
                _CCR2W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 3"]
    pub struct CCR3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare register 3"]
    pub mod ccr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCR3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCR3R {
            bits: u16,
        }
        impl CCR3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCR3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare value"]
            #[inline]
            pub fn ccr3(&self) -> CCR3R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CCR3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare value"]
            #[inline]
            pub fn ccr3(&mut self) -> _CCR3W {
                _CCR3W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 4"]
    pub struct CCR4 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare register 4"]
    pub mod ccr4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCR4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCR4R {
            bits: u16,
        }
        impl CCR4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCR4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare value"]
            #[inline]
            pub fn ccr4(&self) -> CCR4R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CCR4R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare value"]
            #[inline]
            pub fn ccr4(&mut self) -> _CCR4W {
                _CCR4W { w: self }
            }
        }
    }
    #[doc = "DMA control register"]
    pub struct DCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA control register"]
    pub mod dcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBLR {
            bits: u8,
        }
        impl DBLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBAR {
            bits: u8,
        }
        impl DBAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline]
            pub fn dbl(&self) -> DBLR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DBLR { bits }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline]
            pub fn dba(&self) -> DBAR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DBAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline]
            pub fn dbl(&mut self) -> _DBLW {
                _DBLW { w: self }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline]
            pub fn dba(&mut self) -> _DBAW {
                _DBAW { w: self }
            }
        }
    }
    #[doc = "DMA address for full transfer"]
    pub struct DMAR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA address for full transfer"]
    pub mod dmar {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMAR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMABR {
            bits: u16,
        }
        impl DMABR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMABW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMABW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline]
            pub fn dmab(&self) -> DMABR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DMABR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline]
            pub fn dmab(&mut self) -> _DMABW {
                _DMABW { w: self }
            }
        }
    }
    #[doc = "repetition counter register"]
    pub struct RCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "repetition counter register"]
    pub mod rcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct REPR {
            bits: u8,
        }
        impl REPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _REPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline]
            pub fn rep(&self) -> REPR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                REPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline]
            pub fn rep(&mut self) -> _REPW {
                _REPW { w: self }
            }
        }
    }
    #[doc = "break and dead-time register"]
    pub struct BDTR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "break and dead-time register"]
    pub mod bdtr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BDTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MOER {
            bits: bool,
        }
        impl MOER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AOER {
            bits: bool,
        }
        impl AOER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BKPR {
            bits: bool,
        }
        impl BKPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BKER {
            bits: bool,
        }
        impl BKER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSSRR {
            bits: bool,
        }
        impl OSSRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSSIR {
            bits: bool,
        }
        impl OSSIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LOCKR {
            bits: u8,
        }
        impl LOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DTGR {
            bits: u8,
        }
        impl DTGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MOEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MOEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AOEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AOEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BKPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BKPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BKEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BKEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSSRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSSRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSSIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSSIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOCKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DTGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DTGW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Main output enable"]
            #[inline]
            pub fn moe(&self) -> MOER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MOER { bits }
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline]
            pub fn aoe(&self) -> AOER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AOER { bits }
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline]
            pub fn bkp(&self) -> BKPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BKPR { bits }
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline]
            pub fn bke(&self) -> BKER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BKER { bits }
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline]
            pub fn ossr(&self) -> OSSRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSSRR { bits }
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline]
            pub fn ossi(&self) -> OSSIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSSIR { bits }
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline]
            pub fn lock(&self) -> LOCKR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LOCKR { bits }
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline]
            pub fn dtg(&self) -> DTGR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DTGR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Main output enable"]
            #[inline]
            pub fn moe(&mut self) -> _MOEW {
                _MOEW { w: self }
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline]
            pub fn aoe(&mut self) -> _AOEW {
                _AOEW { w: self }
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline]
            pub fn bkp(&mut self) -> _BKPW {
                _BKPW { w: self }
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline]
            pub fn bke(&mut self) -> _BKEW {
                _BKEW { w: self }
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline]
            pub fn ossr(&mut self) -> _OSSRW {
                _OSSRW { w: self }
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline]
            pub fn ossi(&mut self) -> _OSSIW {
                _OSSIW { w: self }
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline]
            pub fn lock(&mut self) -> _LOCKW {
                _LOCKW { w: self }
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline]
            pub fn dtg(&mut self) -> _DTGW {
                _DTGW { w: self }
            }
        }
    }
}
#[doc = "General purpose timer"]
#[cfg(feature = "tim2")]
pub struct TIM2 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "tim2")]
unsafe impl Send for TIM2 {}
#[cfg(feature = "tim2")]
impl TIM2 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const tim2::RegisterBlock {
        0x4000_0000 as *const _
    }
}
#[cfg(feature = "tim2")]
impl Deref for TIM2 {
    type Target = tim2::RegisterBlock;
    fn deref(&self) -> &tim2::RegisterBlock {
        unsafe { &*TIM2::ptr() }
    }
}
#[doc = "General purpose timer"]
#[cfg(feature = "tim2")]
pub mod tim2 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - slave mode control register"]
        pub smcr: SMCR,
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        #[doc = "0x18 - capture/compare mode register 1 (output mode)"]
        pub ccmr1_output: CCMR1_OUTPUT,
        #[doc = "0x1c - capture/compare mode register 2 (output mode)"]
        pub ccmr2_output: CCMR2_OUTPUT,
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: CCER,
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
        _reserved0: [u8; 4usize],
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: CCR1,
        #[doc = "0x38 - capture/compare register 2"]
        pub ccr2: CCR2,
        #[doc = "0x3c - capture/compare register 3"]
        pub ccr3: CCR3,
        #[doc = "0x40 - capture/compare register 4"]
        pub ccr4: CCR4,
        _reserved1: [u8; 4usize],
        #[doc = "0x48 - DMA control register"]
        pub dcr: DCR,
        #[doc = "0x4c - DMA address for full transfer"]
        pub dmar: DMAR,
    }
    #[doc = "control register 1"]
    pub struct CR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CKD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CKDR {
            #[doc = "CK_INT not divided"]
            NOTDIVIDED,
            #[doc = "CK_INT divided by 2"]
            DIVIDEDBY2,
            #[doc = "CK_INT divided by 4"]
            DIVIDEDBY4,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CKDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CKDR::NOTDIVIDED => 0,
                    CKDR::DIVIDEDBY2 => 0x01,
                    CKDR::DIVIDEDBY4 => 0x02,
                    CKDR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CKDR {
                match value {
                    0 => CKDR::NOTDIVIDED,
                    1 => CKDR::DIVIDEDBY2,
                    2 => CKDR::DIVIDEDBY4,
                    i => CKDR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NOTDIVIDED`"]
            #[inline]
            pub fn is_not_divided(&self) -> bool {
                *self == CKDR::NOTDIVIDED
            }
            #[doc = "Checks if the value of the field is `DIVIDEDBY2`"]
            #[inline]
            pub fn is_divided_by2(&self) -> bool {
                *self == CKDR::DIVIDEDBY2
            }
            #[doc = "Checks if the value of the field is `DIVIDEDBY4`"]
            #[inline]
            pub fn is_divided_by4(&self) -> bool {
                *self == CKDR::DIVIDEDBY4
            }
        }
        #[doc = "Possible values of the field `ARPE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPER {
            #[doc = "TIMx_APRR register is not buffered"]
            DISABLED,
            #[doc = "TIMx_APRR register is buffered"]
            ENABLED,
        }
        impl ARPER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ARPER::DISABLED => false,
                    ARPER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ARPER {
                match value {
                    false => ARPER::DISABLED,
                    true => ARPER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ARPER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ARPER::ENABLED
            }
        }
        #[doc = r" Value of the field"]
        pub struct CMSR {
            bits: u8,
        }
        impl CMSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIRR {
            bits: bool,
        }
        impl DIRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `OPM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPMR {
            #[doc = "Counter is not stopped at update event"]
            DISABLED,
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            ENABLED,
        }
        impl OPMR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OPMR::DISABLED => false,
                    OPMR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OPMR {
                match value {
                    false => OPMR::DISABLED,
                    true => OPMR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == OPMR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == OPMR::ENABLED
            }
        }
        #[doc = "Possible values of the field `URS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URSR {
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT,
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY,
        }
        impl URSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    URSR::ANYEVENT => false,
                    URSR::COUNTERONLY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> URSR {
                match value {
                    false => URSR::ANYEVENT,
                    true => URSR::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline]
            pub fn is_any_event(&self) -> bool {
                *self == URSR::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline]
            pub fn is_counter_only(&self) -> bool {
                *self == URSR::COUNTERONLY
            }
        }
        #[doc = "Possible values of the field `UDIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDISR {
            #[doc = "Update event enabled"]
            ENABLED,
            #[doc = "Update event disabled"]
            DISABLED,
        }
        impl UDISR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UDISR::ENABLED => false,
                    UDISR::DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UDISR {
                match value {
                    false => UDISR::ENABLED,
                    true => UDISR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UDISR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UDISR::DISABLED
            }
        }
        #[doc = "Possible values of the field `CEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CENR {
            #[doc = "Counter disabled"]
            DISABLED,
            #[doc = "Counter enabled"]
            ENABLED,
        }
        impl CENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CENR::DISABLED => false,
                    CENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CENR {
                match value {
                    false => CENR::DISABLED,
                    true => CENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CENR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `CKD`"]
        pub enum CKDW {
            #[doc = "CK_INT not divided"]
            NOTDIVIDED,
            #[doc = "CK_INT divided by 2"]
            DIVIDEDBY2,
            #[doc = "CK_INT divided by 4"]
            DIVIDEDBY4,
        }
        impl CKDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CKDW::NOTDIVIDED => 0,
                    CKDW::DIVIDEDBY2 => 1,
                    CKDW::DIVIDEDBY4 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CKDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CKDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CKDW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "CK_INT not divided"]
            #[inline]
            pub fn not_divided(self) -> &'a mut W {
                self.variant(CKDW::NOTDIVIDED)
            }
            #[doc = "CK_INT divided by 2"]
            #[inline]
            pub fn divided_by2(self) -> &'a mut W {
                self.variant(CKDW::DIVIDEDBY2)
            }
            #[doc = "CK_INT divided by 4"]
            #[inline]
            pub fn divided_by4(self) -> &'a mut W {
                self.variant(CKDW::DIVIDEDBY4)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ARPE`"]
        pub enum ARPEW {
            #[doc = "TIMx_APRR register is not buffered"]
            DISABLED,
            #[doc = "TIMx_APRR register is buffered"]
            ENABLED,
        }
        impl ARPEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ARPEW::DISABLED => false,
                    ARPEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ARPEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ARPEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ARPEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPEW::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OPM`"]
        pub enum OPMW {
            #[doc = "Counter is not stopped at update event"]
            DISABLED,
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            ENABLED,
        }
        impl OPMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OPMW::DISABLED => false,
                    OPMW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OPMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OPMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OPMW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Counter is not stopped at update event"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OPMW::DISABLED)
            }
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OPMW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `URS`"]
        pub enum URSW {
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT,
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY,
        }
        impl URSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    URSW::ANYEVENT => false,
                    URSW::COUNTERONLY => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _URSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _URSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: URSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URSW::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URSW::COUNTERONLY)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UDIS`"]
        pub enum UDISW {
            #[doc = "Update event enabled"]
            ENABLED,
            #[doc = "Update event disabled"]
            DISABLED,
        }
        impl UDISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UDISW::ENABLED => false,
                    UDISW::DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UDISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UDISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UDISW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Update event enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDISW::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDISW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CEN`"]
        pub enum CENW {
            #[doc = "Counter disabled"]
            DISABLED,
            #[doc = "Counter enabled"]
            ENABLED,
        }
        impl CENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CENW::DISABLED => false,
                    CENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Counter disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CENW::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline]
            pub fn ckd(&self) -> CKDR {
                CKDR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline]
            pub fn arpe(&self) -> ARPER {
                ARPER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline]
            pub fn cms(&self) -> CMSR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CMSR { bits }
            }
            #[doc = "Bit 4 - Direction"]
            #[inline]
            pub fn dir(&self) -> DIRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DIRR { bits }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline]
            pub fn opm(&self) -> OPMR {
                OPMR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline]
            pub fn urs(&self) -> URSR {
                URSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline]
            pub fn udis(&self) -> UDISR {
                UDISR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline]
            pub fn cen(&self) -> CENR {
                CENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline]
            pub fn ckd(&mut self) -> _CKDW {
                _CKDW { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline]
            pub fn arpe(&mut self) -> _ARPEW {
                _ARPEW { w: self }
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline]
            pub fn cms(&mut self) -> _CMSW {
                _CMSW { w: self }
            }
            #[doc = "Bit 4 - Direction"]
            #[inline]
            pub fn dir(&mut self) -> _DIRW {
                _DIRW { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline]
            pub fn opm(&mut self) -> _OPMW {
                _OPMW { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline]
            pub fn urs(&mut self) -> _URSW {
                _URSW { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline]
            pub fn udis(&mut self) -> _UDISW {
                _UDISW { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline]
            pub fn cen(&mut self) -> _CENW {
                _CENW { w: self }
            }
        }
    }
    #[doc = "control register 2"]
    pub struct CR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `TI1S`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TI1SR {
            #[doc = "The TIMx_CH1 pin is connected to TI1 input"]
            NORMAL,
            #[doc = "The TIMx_CH1, CH2, CH3 pins are connected to TI1 input"]
            XOR,
        }
        impl TI1SR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TI1SR::NORMAL => false,
                    TI1SR::XOR => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TI1SR {
                match value {
                    false => TI1SR::NORMAL,
                    true => TI1SR::XOR,
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL`"]
            #[inline]
            pub fn is_normal(&self) -> bool {
                *self == TI1SR::NORMAL
            }
            #[doc = "Checks if the value of the field is `XOR`"]
            #[inline]
            pub fn is_xor(&self) -> bool {
                *self == TI1SR::XOR
            }
        }
        #[doc = "Possible values of the field `MMS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MMSR {
            #[doc = "The UG bit from the TIMx_EGR register is used as trigger output"]
            RESET,
            #[doc = "The counter enable signal, CNT_EN, is used as trigger output"]
            ENABLE,
            #[doc = "The update event is selected as trigger output"]
            UPDATE,
            #[doc = "The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred"]
            COMPAREPULSE,
            #[doc = "OC1REF signal is used as trigger output"]
            COMPAREOC1,
            #[doc = "OC2REF signal is used as trigger output"]
            COMPAREOC2,
            #[doc = "OC3REF signal is used as trigger output"]
            COMPAREOC3,
            #[doc = "OC4REF signal is used as trigger output"]
            COMPAREOC4,
        }
        impl MMSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MMSR::RESET => 0,
                    MMSR::ENABLE => 0x01,
                    MMSR::UPDATE => 0x02,
                    MMSR::COMPAREPULSE => 0x03,
                    MMSR::COMPAREOC1 => 0x04,
                    MMSR::COMPAREOC2 => 0x05,
                    MMSR::COMPAREOC3 => 0x06,
                    MMSR::COMPAREOC4 => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MMSR {
                match value {
                    0 => MMSR::RESET,
                    1 => MMSR::ENABLE,
                    2 => MMSR::UPDATE,
                    3 => MMSR::COMPAREPULSE,
                    4 => MMSR::COMPAREOC1,
                    5 => MMSR::COMPAREOC2,
                    6 => MMSR::COMPAREOC3,
                    7 => MMSR::COMPAREOC4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline]
            pub fn is_reset(&self) -> bool {
                *self == MMSR::RESET
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == MMSR::ENABLE
            }
            #[doc = "Checks if the value of the field is `UPDATE`"]
            #[inline]
            pub fn is_update(&self) -> bool {
                *self == MMSR::UPDATE
            }
            #[doc = "Checks if the value of the field is `COMPAREPULSE`"]
            #[inline]
            pub fn is_compare_pulse(&self) -> bool {
                *self == MMSR::COMPAREPULSE
            }
            #[doc = "Checks if the value of the field is `COMPAREOC1`"]
            #[inline]
            pub fn is_compare_oc1(&self) -> bool {
                *self == MMSR::COMPAREOC1
            }
            #[doc = "Checks if the value of the field is `COMPAREOC2`"]
            #[inline]
            pub fn is_compare_oc2(&self) -> bool {
                *self == MMSR::COMPAREOC2
            }
            #[doc = "Checks if the value of the field is `COMPAREOC3`"]
            #[inline]
            pub fn is_compare_oc3(&self) -> bool {
                *self == MMSR::COMPAREOC3
            }
            #[doc = "Checks if the value of the field is `COMPAREOC4`"]
            #[inline]
            pub fn is_compare_oc4(&self) -> bool {
                *self == MMSR::COMPAREOC4
            }
        }
        #[doc = "Possible values of the field `CCDS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCDSR {
            #[doc = "CCx DMA request sent when CCx event occurs"]
            ONCOMPARE,
            #[doc = "CCx DMA request sent when update event occurs"]
            ONUPDATE,
        }
        impl CCDSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CCDSR::ONCOMPARE => false,
                    CCDSR::ONUPDATE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CCDSR {
                match value {
                    false => CCDSR::ONCOMPARE,
                    true => CCDSR::ONUPDATE,
                }
            }
            #[doc = "Checks if the value of the field is `ONCOMPARE`"]
            #[inline]
            pub fn is_on_compare(&self) -> bool {
                *self == CCDSR::ONCOMPARE
            }
            #[doc = "Checks if the value of the field is `ONUPDATE`"]
            #[inline]
            pub fn is_on_update(&self) -> bool {
                *self == CCDSR::ONUPDATE
            }
        }
        #[doc = "Values that can be written to the field `TI1S`"]
        pub enum TI1SW {
            #[doc = "The TIMx_CH1 pin is connected to TI1 input"]
            NORMAL,
            #[doc = "The TIMx_CH1, CH2, CH3 pins are connected to TI1 input"]
            XOR,
        }
        impl TI1SW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TI1SW::NORMAL => false,
                    TI1SW::XOR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TI1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TI1SW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TI1SW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The TIMx_CH1 pin is connected to TI1 input"]
            #[inline]
            pub fn normal(self) -> &'a mut W {
                self.variant(TI1SW::NORMAL)
            }
            #[doc = "The TIMx_CH1, CH2, CH3 pins are connected to TI1 input"]
            #[inline]
            pub fn xor(self) -> &'a mut W {
                self.variant(TI1SW::XOR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MMS`"]
        pub enum MMSW {
            #[doc = "The UG bit from the TIMx_EGR register is used as trigger output"]
            RESET,
            #[doc = "The counter enable signal, CNT_EN, is used as trigger output"]
            ENABLE,
            #[doc = "The update event is selected as trigger output"]
            UPDATE,
            #[doc = "The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred"]
            COMPAREPULSE,
            #[doc = "OC1REF signal is used as trigger output"]
            COMPAREOC1,
            #[doc = "OC2REF signal is used as trigger output"]
            COMPAREOC2,
            #[doc = "OC3REF signal is used as trigger output"]
            COMPAREOC3,
            #[doc = "OC4REF signal is used as trigger output"]
            COMPAREOC4,
        }
        impl MMSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MMSW::RESET => 0,
                    MMSW::ENABLE => 1,
                    MMSW::UPDATE => 2,
                    MMSW::COMPAREPULSE => 3,
                    MMSW::COMPAREOC1 => 4,
                    MMSW::COMPAREOC2 => 5,
                    MMSW::COMPAREOC3 => 6,
                    MMSW::COMPAREOC4 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MMSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MMSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MMSW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "The UG bit from the TIMx_EGR register is used as trigger output"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(MMSW::RESET)
            }
            #[doc = "The counter enable signal, CNT_EN, is used as trigger output"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(MMSW::ENABLE)
            }
            #[doc = "The update event is selected as trigger output"]
            #[inline]
            pub fn update(self) -> &'a mut W {
                self.variant(MMSW::UPDATE)
            }
            #[doc = "The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred"]
            #[inline]
            pub fn compare_pulse(self) -> &'a mut W {
                self.variant(MMSW::COMPAREPULSE)
            }
            #[doc = "OC1REF signal is used as trigger output"]
            #[inline]
            pub fn compare_oc1(self) -> &'a mut W {
                self.variant(MMSW::COMPAREOC1)
            }
            #[doc = "OC2REF signal is used as trigger output"]
            #[inline]
            pub fn compare_oc2(self) -> &'a mut W {
                self.variant(MMSW::COMPAREOC2)
            }
            #[doc = "OC3REF signal is used as trigger output"]
            #[inline]
            pub fn compare_oc3(self) -> &'a mut W {
                self.variant(MMSW::COMPAREOC3)
            }
            #[doc = "OC4REF signal is used as trigger output"]
            #[inline]
            pub fn compare_oc4(self) -> &'a mut W {
                self.variant(MMSW::COMPAREOC4)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCDS`"]
        pub enum CCDSW {
            #[doc = "CCx DMA request sent when CCx event occurs"]
            ONCOMPARE,
            #[doc = "CCx DMA request sent when update event occurs"]
            ONUPDATE,
        }
        impl CCDSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CCDSW::ONCOMPARE => false,
                    CCDSW::ONUPDATE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCDSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCDSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CCDSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CCx DMA request sent when CCx event occurs"]
            #[inline]
            pub fn on_compare(self) -> &'a mut W {
                self.variant(CCDSW::ONCOMPARE)
            }
            #[doc = "CCx DMA request sent when update event occurs"]
            #[inline]
            pub fn on_update(self) -> &'a mut W {
                self.variant(CCDSW::ONUPDATE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 7 - TI1 selection"]
            #[inline]
            pub fn ti1s(&self) -> TI1SR {
                TI1SR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline]
            pub fn mms(&self) -> MMSR {
                MMSR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline]
            pub fn ccds(&self) -> CCDSR {
                CCDSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - TI1 selection"]
            #[inline]
            pub fn ti1s(&mut self) -> _TI1SW {
                _TI1SW { w: self }
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline]
            pub fn mms(&mut self) -> _MMSW {
                _MMSW { w: self }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline]
            pub fn ccds(&mut self) -> _CCDSW {
                _CCDSW { w: self }
            }
        }
    }
    #[doc = "slave mode control register"]
    pub struct SMCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "slave mode control register"]
    pub mod smcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SMCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ETP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ETPR {
            #[doc = "ETR is noninverted, active at high level or rising edge"]
            NOTINVERTED,
            #[doc = "ETR is inverted, active at low level or falling edge"]
            INVERTED,
        }
        impl ETPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ETPR::NOTINVERTED => false,
                    ETPR::INVERTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ETPR {
                match value {
                    false => ETPR::NOTINVERTED,
                    true => ETPR::INVERTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTINVERTED`"]
            #[inline]
            pub fn is_not_inverted(&self) -> bool {
                *self == ETPR::NOTINVERTED
            }
            #[doc = "Checks if the value of the field is `INVERTED`"]
            #[inline]
            pub fn is_inverted(&self) -> bool {
                *self == ETPR::INVERTED
            }
        }
        #[doc = "Possible values of the field `ECE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ECER {
            #[doc = "External clock mode 2 disabled"]
            DISABLED,
            #[doc = "External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal."]
            ENABLED,
        }
        impl ECER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ECER::DISABLED => false,
                    ECER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ECER {
                match value {
                    false => ECER::DISABLED,
                    true => ECER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ECER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ECER::ENABLED
            }
        }
        #[doc = "Possible values of the field `ETPS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ETPSR {
            #[doc = "Prescaler OFF"]
            NODIV,
            #[doc = "ETRP frequency divided by 2"]
            DIV2,
            #[doc = "ETRP frequency divided by 4"]
            DIV4,
            #[doc = "ETRP frequency divided by 8"]
            DIV8,
        }
        impl ETPSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ETPSR::NODIV => 0,
                    ETPSR::DIV2 => 0x01,
                    ETPSR::DIV4 => 0x02,
                    ETPSR::DIV8 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ETPSR {
                match value {
                    0 => ETPSR::NODIV,
                    1 => ETPSR::DIV2,
                    2 => ETPSR::DIV4,
                    3 => ETPSR::DIV8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NODIV`"]
            #[inline]
            pub fn is_no_div(&self) -> bool {
                *self == ETPSR::NODIV
            }
            #[doc = "Checks if the value of the field is `DIV2`"]
            #[inline]
            pub fn is_div2(&self) -> bool {
                *self == ETPSR::DIV2
            }
            #[doc = "Checks if the value of the field is `DIV4`"]
            #[inline]
            pub fn is_div4(&self) -> bool {
                *self == ETPSR::DIV4
            }
            #[doc = "Checks if the value of the field is `DIV8`"]
            #[inline]
            pub fn is_div8(&self) -> bool {
                *self == ETPSR::DIV8
            }
        }
        #[doc = "Possible values of the field `ETF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ETFR {
            #[doc = "No filter, sampling is done at fDTS"]
            NOFILTER,
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            FCK_INT_N2,
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            FCK_INT_N4,
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            FCK_INT_N8,
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            FDTS_DIV2_N6,
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            FDTS_DIV2_N8,
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            FDTS_DIV4_N6,
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            FDTS_DIV4_N8,
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            FDTS_DIV8_N6,
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            FDTS_DIV8_N8,
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            FDTS_DIV16_N5,
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            FDTS_DIV16_N6,
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            FDTS_DIV16_N8,
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            FDTS_DIV32_N5,
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            FDTS_DIV32_N6,
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            FDTS_DIV32_N8,
        }
        impl ETFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ETFR::NOFILTER => 0,
                    ETFR::FCK_INT_N2 => 0x01,
                    ETFR::FCK_INT_N4 => 0x02,
                    ETFR::FCK_INT_N8 => 0x03,
                    ETFR::FDTS_DIV2_N6 => 0x04,
                    ETFR::FDTS_DIV2_N8 => 0x05,
                    ETFR::FDTS_DIV4_N6 => 0x06,
                    ETFR::FDTS_DIV4_N8 => 0x07,
                    ETFR::FDTS_DIV8_N6 => 0x08,
                    ETFR::FDTS_DIV8_N8 => 0x09,
                    ETFR::FDTS_DIV16_N5 => 0x0a,
                    ETFR::FDTS_DIV16_N6 => 0x0b,
                    ETFR::FDTS_DIV16_N8 => 0x0c,
                    ETFR::FDTS_DIV32_N5 => 0x0d,
                    ETFR::FDTS_DIV32_N6 => 0x0e,
                    ETFR::FDTS_DIV32_N8 => 0x0f,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ETFR {
                match value {
                    0 => ETFR::NOFILTER,
                    1 => ETFR::FCK_INT_N2,
                    2 => ETFR::FCK_INT_N4,
                    3 => ETFR::FCK_INT_N8,
                    4 => ETFR::FDTS_DIV2_N6,
                    5 => ETFR::FDTS_DIV2_N8,
                    6 => ETFR::FDTS_DIV4_N6,
                    7 => ETFR::FDTS_DIV4_N8,
                    8 => ETFR::FDTS_DIV8_N6,
                    9 => ETFR::FDTS_DIV8_N8,
                    10 => ETFR::FDTS_DIV16_N5,
                    11 => ETFR::FDTS_DIV16_N6,
                    12 => ETFR::FDTS_DIV16_N8,
                    13 => ETFR::FDTS_DIV32_N5,
                    14 => ETFR::FDTS_DIV32_N6,
                    15 => ETFR::FDTS_DIV32_N8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOFILTER`"]
            #[inline]
            pub fn is_no_filter(&self) -> bool {
                *self == ETFR::NOFILTER
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N2`"]
            #[inline]
            pub fn is_fck_int_n2(&self) -> bool {
                *self == ETFR::FCK_INT_N2
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N4`"]
            #[inline]
            pub fn is_fck_int_n4(&self) -> bool {
                *self == ETFR::FCK_INT_N4
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N8`"]
            #[inline]
            pub fn is_fck_int_n8(&self) -> bool {
                *self == ETFR::FCK_INT_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N6`"]
            #[inline]
            pub fn is_fdts_div2_n6(&self) -> bool {
                *self == ETFR::FDTS_DIV2_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N8`"]
            #[inline]
            pub fn is_fdts_div2_n8(&self) -> bool {
                *self == ETFR::FDTS_DIV2_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N6`"]
            #[inline]
            pub fn is_fdts_div4_n6(&self) -> bool {
                *self == ETFR::FDTS_DIV4_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N8`"]
            #[inline]
            pub fn is_fdts_div4_n8(&self) -> bool {
                *self == ETFR::FDTS_DIV4_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N6`"]
            #[inline]
            pub fn is_fdts_div8_n6(&self) -> bool {
                *self == ETFR::FDTS_DIV8_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N8`"]
            #[inline]
            pub fn is_fdts_div8_n8(&self) -> bool {
                *self == ETFR::FDTS_DIV8_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N5`"]
            #[inline]
            pub fn is_fdts_div16_n5(&self) -> bool {
                *self == ETFR::FDTS_DIV16_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N6`"]
            #[inline]
            pub fn is_fdts_div16_n6(&self) -> bool {
                *self == ETFR::FDTS_DIV16_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N8`"]
            #[inline]
            pub fn is_fdts_div16_n8(&self) -> bool {
                *self == ETFR::FDTS_DIV16_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N5`"]
            #[inline]
            pub fn is_fdts_div32_n5(&self) -> bool {
                *self == ETFR::FDTS_DIV32_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N6`"]
            #[inline]
            pub fn is_fdts_div32_n6(&self) -> bool {
                *self == ETFR::FDTS_DIV32_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N8`"]
            #[inline]
            pub fn is_fdts_div32_n8(&self) -> bool {
                *self == ETFR::FDTS_DIV32_N8
            }
        }
        #[doc = "Possible values of the field `MSM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSMR {
            #[doc = "No action"]
            NOSYNC,
            #[doc = "The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event."]
            SYNC,
        }
        impl MSMR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MSMR::NOSYNC => false,
                    MSMR::SYNC => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MSMR {
                match value {
                    false => MSMR::NOSYNC,
                    true => MSMR::SYNC,
                }
            }
            #[doc = "Checks if the value of the field is `NOSYNC`"]
            #[inline]
            pub fn is_no_sync(&self) -> bool {
                *self == MSMR::NOSYNC
            }
            #[doc = "Checks if the value of the field is `SYNC`"]
            #[inline]
            pub fn is_sync(&self) -> bool {
                *self == MSMR::SYNC
            }
        }
        #[doc = "Possible values of the field `TS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TSR {
            #[doc = "Internal Trigger 0 (ITR0)"]
            ITR0,
            #[doc = "Internal Trigger 1 (ITR1)"]
            ITR1,
            #[doc = "Internal Trigger 2 (ITR2)"]
            ITR2,
            #[doc = "TI1 Edge Detector (TI1F_ED)"]
            TI1F_ED,
            #[doc = "Filtered Timer Input 1 (TI1FP1)"]
            TI1FP1,
            #[doc = "Filtered Timer Input 2 (TI2FP2)"]
            TI2FP2,
            #[doc = "External Trigger input (ETRF)"]
            ETRF,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl TSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    TSR::ITR0 => 0,
                    TSR::ITR1 => 0x01,
                    TSR::ITR2 => 0x02,
                    TSR::TI1F_ED => 0x04,
                    TSR::TI1FP1 => 0x05,
                    TSR::TI2FP2 => 0x06,
                    TSR::ETRF => 0x07,
                    TSR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> TSR {
                match value {
                    0 => TSR::ITR0,
                    1 => TSR::ITR1,
                    2 => TSR::ITR2,
                    4 => TSR::TI1F_ED,
                    5 => TSR::TI1FP1,
                    6 => TSR::TI2FP2,
                    7 => TSR::ETRF,
                    i => TSR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `ITR0`"]
            #[inline]
            pub fn is_itr0(&self) -> bool {
                *self == TSR::ITR0
            }
            #[doc = "Checks if the value of the field is `ITR1`"]
            #[inline]
            pub fn is_itr1(&self) -> bool {
                *self == TSR::ITR1
            }
            #[doc = "Checks if the value of the field is `ITR2`"]
            #[inline]
            pub fn is_itr2(&self) -> bool {
                *self == TSR::ITR2
            }
            #[doc = "Checks if the value of the field is `TI1F_ED`"]
            #[inline]
            pub fn is_ti1f_ed(&self) -> bool {
                *self == TSR::TI1F_ED
            }
            #[doc = "Checks if the value of the field is `TI1FP1`"]
            #[inline]
            pub fn is_ti1fp1(&self) -> bool {
                *self == TSR::TI1FP1
            }
            #[doc = "Checks if the value of the field is `TI2FP2`"]
            #[inline]
            pub fn is_ti2fp2(&self) -> bool {
                *self == TSR::TI2FP2
            }
            #[doc = "Checks if the value of the field is `ETRF`"]
            #[inline]
            pub fn is_etrf(&self) -> bool {
                *self == TSR::ETRF
            }
        }
        #[doc = "Possible values of the field `SMS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SMSR {
            #[doc = "Slave mode disabled - if CEN = \u{2018}1 then the prescaler is clocked directly by the internal clock."]
            DISABLED,
            #[doc = "Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level."]
            ENCODER_MODE_1,
            #[doc = "Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level."]
            ENCODER_MODE_2,
            #[doc = "Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input."]
            ENCODER_MODE_3,
            #[doc = "Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers."]
            RESET_MODE,
            #[doc = "Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled."]
            GATED_MODE,
            #[doc = "Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled."]
            TRIGGER_MODE,
            #[doc = "External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter."]
            EXT_CLOCK_MODE,
        }
        impl SMSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SMSR::DISABLED => 0,
                    SMSR::ENCODER_MODE_1 => 0x01,
                    SMSR::ENCODER_MODE_2 => 0x02,
                    SMSR::ENCODER_MODE_3 => 0x03,
                    SMSR::RESET_MODE => 0x04,
                    SMSR::GATED_MODE => 0x05,
                    SMSR::TRIGGER_MODE => 0x06,
                    SMSR::EXT_CLOCK_MODE => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SMSR {
                match value {
                    0 => SMSR::DISABLED,
                    1 => SMSR::ENCODER_MODE_1,
                    2 => SMSR::ENCODER_MODE_2,
                    3 => SMSR::ENCODER_MODE_3,
                    4 => SMSR::RESET_MODE,
                    5 => SMSR::GATED_MODE,
                    6 => SMSR::TRIGGER_MODE,
                    7 => SMSR::EXT_CLOCK_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SMSR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_1`"]
            #[inline]
            pub fn is_encoder_mode_1(&self) -> bool {
                *self == SMSR::ENCODER_MODE_1
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_2`"]
            #[inline]
            pub fn is_encoder_mode_2(&self) -> bool {
                *self == SMSR::ENCODER_MODE_2
            }
            #[doc = "Checks if the value of the field is `ENCODER_MODE_3`"]
            #[inline]
            pub fn is_encoder_mode_3(&self) -> bool {
                *self == SMSR::ENCODER_MODE_3
            }
            #[doc = "Checks if the value of the field is `RESET_MODE`"]
            #[inline]
            pub fn is_reset_mode(&self) -> bool {
                *self == SMSR::RESET_MODE
            }
            #[doc = "Checks if the value of the field is `GATED_MODE`"]
            #[inline]
            pub fn is_gated_mode(&self) -> bool {
                *self == SMSR::GATED_MODE
            }
            #[doc = "Checks if the value of the field is `TRIGGER_MODE`"]
            #[inline]
            pub fn is_trigger_mode(&self) -> bool {
                *self == SMSR::TRIGGER_MODE
            }
            #[doc = "Checks if the value of the field is `EXT_CLOCK_MODE`"]
            #[inline]
            pub fn is_ext_clock_mode(&self) -> bool {
                *self == SMSR::EXT_CLOCK_MODE
            }
        }
        #[doc = r" Value of the field"]
        pub struct OCCSR {
            bits: bool,
        }
        impl OCCSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `ETP`"]
        pub enum ETPW {
            #[doc = "ETR is noninverted, active at high level or rising edge"]
            NOTINVERTED,
            #[doc = "ETR is inverted, active at low level or falling edge"]
            INVERTED,
        }
        impl ETPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ETPW::NOTINVERTED => false,
                    ETPW::INVERTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ETPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ETPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ETPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ETR is noninverted, active at high level or rising edge"]
            #[inline]
            pub fn not_inverted(self) -> &'a mut W {
                self.variant(ETPW::NOTINVERTED)
            }
            #[doc = "ETR is inverted, active at low level or falling edge"]
            #[inline]
            pub fn inverted(self) -> &'a mut W {
                self.variant(ETPW::INVERTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ECE`"]
        pub enum ECEW {
            #[doc = "External clock mode 2 disabled"]
            DISABLED,
            #[doc = "External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal."]
            ENABLED,
        }
        impl ECEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ECEW::DISABLED => false,
                    ECEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ECEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ECEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ECEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "External clock mode 2 disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ECEW::DISABLED)
            }
            #[doc = "External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ECEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ETPS`"]
        pub enum ETPSW {
            #[doc = "Prescaler OFF"]
            NODIV,
            #[doc = "ETRP frequency divided by 2"]
            DIV2,
            #[doc = "ETRP frequency divided by 4"]
            DIV4,
            #[doc = "ETRP frequency divided by 8"]
            DIV8,
        }
        impl ETPSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ETPSW::NODIV => 0,
                    ETPSW::DIV2 => 1,
                    ETPSW::DIV4 => 2,
                    ETPSW::DIV8 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ETPSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ETPSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ETPSW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Prescaler OFF"]
            #[inline]
            pub fn no_div(self) -> &'a mut W {
                self.variant(ETPSW::NODIV)
            }
            #[doc = "ETRP frequency divided by 2"]
            #[inline]
            pub fn div2(self) -> &'a mut W {
                self.variant(ETPSW::DIV2)
            }
            #[doc = "ETRP frequency divided by 4"]
            #[inline]
            pub fn div4(self) -> &'a mut W {
                self.variant(ETPSW::DIV4)
            }
            #[doc = "ETRP frequency divided by 8"]
            #[inline]
            pub fn div8(self) -> &'a mut W {
                self.variant(ETPSW::DIV8)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ETF`"]
        pub enum ETFW {
            #[doc = "No filter, sampling is done at fDTS"]
            NOFILTER,
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            FCK_INT_N2,
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            FCK_INT_N4,
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            FCK_INT_N8,
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            FDTS_DIV2_N6,
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            FDTS_DIV2_N8,
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            FDTS_DIV4_N6,
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            FDTS_DIV4_N8,
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            FDTS_DIV8_N6,
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            FDTS_DIV8_N8,
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            FDTS_DIV16_N5,
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            FDTS_DIV16_N6,
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            FDTS_DIV16_N8,
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            FDTS_DIV32_N5,
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            FDTS_DIV32_N6,
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            FDTS_DIV32_N8,
        }
        impl ETFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ETFW::NOFILTER => 0,
                    ETFW::FCK_INT_N2 => 1,
                    ETFW::FCK_INT_N4 => 2,
                    ETFW::FCK_INT_N8 => 3,
                    ETFW::FDTS_DIV2_N6 => 4,
                    ETFW::FDTS_DIV2_N8 => 5,
                    ETFW::FDTS_DIV4_N6 => 6,
                    ETFW::FDTS_DIV4_N8 => 7,
                    ETFW::FDTS_DIV8_N6 => 8,
                    ETFW::FDTS_DIV8_N8 => 9,
                    ETFW::FDTS_DIV16_N5 => 10,
                    ETFW::FDTS_DIV16_N6 => 11,
                    ETFW::FDTS_DIV16_N8 => 12,
                    ETFW::FDTS_DIV32_N5 => 13,
                    ETFW::FDTS_DIV32_N6 => 14,
                    ETFW::FDTS_DIV32_N8 => 15,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ETFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ETFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ETFW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No filter, sampling is done at fDTS"]
            #[inline]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(ETFW::NOFILTER)
            }
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            #[inline]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(ETFW::FCK_INT_N2)
            }
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            #[inline]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(ETFW::FCK_INT_N4)
            }
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            #[inline]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(ETFW::FCK_INT_N8)
            }
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            #[inline]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(ETFW::FDTS_DIV2_N6)
            }
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            #[inline]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(ETFW::FDTS_DIV2_N8)
            }
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            #[inline]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(ETFW::FDTS_DIV4_N6)
            }
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            #[inline]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(ETFW::FDTS_DIV4_N8)
            }
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            #[inline]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(ETFW::FDTS_DIV8_N6)
            }
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            #[inline]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(ETFW::FDTS_DIV8_N8)
            }
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            #[inline]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(ETFW::FDTS_DIV16_N5)
            }
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            #[inline]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(ETFW::FDTS_DIV16_N6)
            }
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            #[inline]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(ETFW::FDTS_DIV16_N8)
            }
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            #[inline]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(ETFW::FDTS_DIV32_N5)
            }
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            #[inline]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(ETFW::FDTS_DIV32_N6)
            }
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            #[inline]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(ETFW::FDTS_DIV32_N8)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSM`"]
        pub enum MSMW {
            #[doc = "No action"]
            NOSYNC,
            #[doc = "The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event."]
            SYNC,
        }
        impl MSMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSMW::NOSYNC => false,
                    MSMW::SYNC => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MSMW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No action"]
            #[inline]
            pub fn no_sync(self) -> &'a mut W {
                self.variant(MSMW::NOSYNC)
            }
            #[doc = "The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event."]
            #[inline]
            pub fn sync(self) -> &'a mut W {
                self.variant(MSMW::SYNC)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TS`"]
        pub enum TSW {
            #[doc = "Internal Trigger 0 (ITR0)"]
            ITR0,
            #[doc = "Internal Trigger 1 (ITR1)"]
            ITR1,
            #[doc = "Internal Trigger 2 (ITR2)"]
            ITR2,
            #[doc = "TI1 Edge Detector (TI1F_ED)"]
            TI1F_ED,
            #[doc = "Filtered Timer Input 1 (TI1FP1)"]
            TI1FP1,
            #[doc = "Filtered Timer Input 2 (TI2FP2)"]
            TI2FP2,
            #[doc = "External Trigger input (ETRF)"]
            ETRF,
        }
        impl TSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TSW::ITR0 => 0,
                    TSW::ITR1 => 1,
                    TSW::ITR2 => 2,
                    TSW::TI1F_ED => 4,
                    TSW::TI1FP1 => 5,
                    TSW::TI2FP2 => 6,
                    TSW::ETRF => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TSW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Internal Trigger 0 (ITR0)"]
            #[inline]
            pub fn itr0(self) -> &'a mut W {
                self.variant(TSW::ITR0)
            }
            #[doc = "Internal Trigger 1 (ITR1)"]
            #[inline]
            pub fn itr1(self) -> &'a mut W {
                self.variant(TSW::ITR1)
            }
            #[doc = "Internal Trigger 2 (ITR2)"]
            #[inline]
            pub fn itr2(self) -> &'a mut W {
                self.variant(TSW::ITR2)
            }
            #[doc = "TI1 Edge Detector (TI1F_ED)"]
            #[inline]
            pub fn ti1f_ed(self) -> &'a mut W {
                self.variant(TSW::TI1F_ED)
            }
            #[doc = "Filtered Timer Input 1 (TI1FP1)"]
            #[inline]
            pub fn ti1fp1(self) -> &'a mut W {
                self.variant(TSW::TI1FP1)
            }
            #[doc = "Filtered Timer Input 2 (TI2FP2)"]
            #[inline]
            pub fn ti2fp2(self) -> &'a mut W {
                self.variant(TSW::TI2FP2)
            }
            #[doc = "External Trigger input (ETRF)"]
            #[inline]
            pub fn etrf(self) -> &'a mut W {
                self.variant(TSW::ETRF)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SMS`"]
        pub enum SMSW {
            #[doc = "Slave mode disabled - if CEN = \u{2018}1 then the prescaler is clocked directly by the internal clock."]
            DISABLED,
            #[doc = "Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level."]
            ENCODER_MODE_1,
            #[doc = "Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level."]
            ENCODER_MODE_2,
            #[doc = "Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input."]
            ENCODER_MODE_3,
            #[doc = "Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers."]
            RESET_MODE,
            #[doc = "Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled."]
            GATED_MODE,
            #[doc = "Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled."]
            TRIGGER_MODE,
            #[doc = "External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter."]
            EXT_CLOCK_MODE,
        }
        impl SMSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SMSW::DISABLED => 0,
                    SMSW::ENCODER_MODE_1 => 1,
                    SMSW::ENCODER_MODE_2 => 2,
                    SMSW::ENCODER_MODE_3 => 3,
                    SMSW::RESET_MODE => 4,
                    SMSW::GATED_MODE => 5,
                    SMSW::TRIGGER_MODE => 6,
                    SMSW::EXT_CLOCK_MODE => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SMSW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Slave mode disabled - if CEN = \u{2018}1 then the prescaler is clocked directly by the internal clock."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SMSW::DISABLED)
            }
            #[doc = "Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level."]
            #[inline]
            pub fn encoder_mode_1(self) -> &'a mut W {
                self.variant(SMSW::ENCODER_MODE_1)
            }
            #[doc = "Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level."]
            #[inline]
            pub fn encoder_mode_2(self) -> &'a mut W {
                self.variant(SMSW::ENCODER_MODE_2)
            }
            #[doc = "Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input."]
            #[inline]
            pub fn encoder_mode_3(self) -> &'a mut W {
                self.variant(SMSW::ENCODER_MODE_3)
            }
            #[doc = "Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers."]
            #[inline]
            pub fn reset_mode(self) -> &'a mut W {
                self.variant(SMSW::RESET_MODE)
            }
            #[doc = "Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled."]
            #[inline]
            pub fn gated_mode(self) -> &'a mut W {
                self.variant(SMSW::GATED_MODE)
            }
            #[doc = "Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled."]
            #[inline]
            pub fn trigger_mode(self) -> &'a mut W {
                self.variant(SMSW::TRIGGER_MODE)
            }
            #[doc = "External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter."]
            #[inline]
            pub fn ext_clock_mode(self) -> &'a mut W {
                self.variant(SMSW::EXT_CLOCK_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OCCSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OCCSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline]
            pub fn etp(&self) -> ETPR {
                ETPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline]
            pub fn ece(&self) -> ECER {
                ECER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline]
            pub fn etps(&self) -> ETPSR {
                ETPSR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline]
            pub fn etf(&self) -> ETFR {
                ETFR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline]
            pub fn msm(&self) -> MSMR {
                MSMR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline]
            pub fn ts(&self) -> TSR {
                TSR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline]
            pub fn sms(&self) -> SMSR {
                SMSR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 3 - OCREF clear selection"]
            #[inline]
            pub fn occs(&self) -> OCCSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OCCSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline]
            pub fn etp(&mut self) -> _ETPW {
                _ETPW { w: self }
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline]
            pub fn ece(&mut self) -> _ECEW {
                _ECEW { w: self }
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline]
            pub fn etps(&mut self) -> _ETPSW {
                _ETPSW { w: self }
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline]
            pub fn etf(&mut self) -> _ETFW {
                _ETFW { w: self }
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline]
            pub fn msm(&mut self) -> _MSMW {
                _MSMW { w: self }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline]
            pub fn ts(&mut self) -> _TSW {
                _TSW { w: self }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline]
            pub fn sms(&mut self) -> _SMSW {
                _SMSW { w: self }
            }
            #[doc = "Bit 3 - OCREF clear selection"]
            #[inline]
            pub fn occs(&mut self) -> _OCCSW {
                _OCCSW { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register"]
    pub struct DIER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `TDE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TDER {
            #[doc = "Trigger DMA request disabled"]
            DISABLED,
            #[doc = "Trigger DMA request enabled"]
            ENABLED,
        }
        impl TDER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TDER::DISABLED => false,
                    TDER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TDER {
                match value {
                    false => TDER::DISABLED,
                    true => TDER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TDER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TDER::ENABLED
            }
        }
        #[doc = "Possible values of the field `CC4DE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4DER {
            #[doc = "CCx DMA request disabled"]
            DISABLED,
            #[doc = "CCx DMA request enabled"]
            ENABLED,
        }
        impl CC4DER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CC4DER::DISABLED => false,
                    CC4DER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CC4DER {
                match value {
                    false => CC4DER::DISABLED,
                    true => CC4DER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CC4DER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CC4DER::ENABLED
            }
        }
        #[doc = "Possible values of the field `CC3DE`"]
        pub type CC3DER = CC4DER;
        #[doc = "Possible values of the field `CC2DE`"]
        pub type CC2DER = CC4DER;
        #[doc = "Possible values of the field `CC1DE`"]
        pub type CC1DER = CC4DER;
        #[doc = "Possible values of the field `UDE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDER {
            #[doc = "Update DMA request disabled"]
            DISABLED,
            #[doc = "Update DMA request enabled"]
            ENABLED,
        }
        impl UDER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UDER::DISABLED => false,
                    UDER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UDER {
                match value {
                    false => UDER::DISABLED,
                    true => UDER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UDER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UDER::ENABLED
            }
        }
        #[doc = "Possible values of the field `TIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIER {
            #[doc = "Trigger interrupt disabled"]
            DISABLED,
            #[doc = "Trigger interrupt enabled"]
            ENABLED,
        }
        impl TIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TIER::DISABLED => false,
                    TIER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TIER {
                match value {
                    false => TIER::DISABLED,
                    true => TIER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TIER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TIER::ENABLED
            }
        }
        #[doc = "Possible values of the field `CC4IE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4IER {
            #[doc = "CCx interrupt disabled"]
            DISABLED,
            #[doc = "CCx interrupt enabled"]
            ENABLED,
        }
        impl CC4IER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CC4IER::DISABLED => false,
                    CC4IER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CC4IER {
                match value {
                    false => CC4IER::DISABLED,
                    true => CC4IER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CC4IER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CC4IER::ENABLED
            }
        }
        #[doc = "Possible values of the field `CC3IE`"]
        pub type CC3IER = CC4IER;
        #[doc = "Possible values of the field `CC2IE`"]
        pub type CC2IER = CC4IER;
        #[doc = "Possible values of the field `CC1IE`"]
        pub type CC1IER = CC4IER;
        #[doc = "Possible values of the field `UIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIER {
            #[doc = "Update interrupt disabled"]
            DISABLED,
            #[doc = "Update interrupt enabled"]
            ENABLED,
        }
        impl UIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UIER::DISABLED => false,
                    UIER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UIER {
                match value {
                    false => UIER::DISABLED,
                    true => UIER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UIER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UIER::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `TDE`"]
        pub enum TDEW {
            #[doc = "Trigger DMA request disabled"]
            DISABLED,
            #[doc = "Trigger DMA request enabled"]
            ENABLED,
        }
        impl TDEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TDEW::DISABLED => false,
                    TDEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TDEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TDEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TDEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Trigger DMA request disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TDEW::DISABLED)
            }
            #[doc = "Trigger DMA request enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TDEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC4DE`"]
        pub enum CC4DEW {
            #[doc = "CCx DMA request disabled"]
            DISABLED,
            #[doc = "CCx DMA request enabled"]
            ENABLED,
        }
        impl CC4DEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CC4DEW::DISABLED => false,
                    CC4DEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4DEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4DEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC4DEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CCx DMA request disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4DEW::DISABLED)
            }
            #[doc = "CCx DMA request enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4DEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC3DE`"]
        pub type CC3DEW = CC4DEW;
        #[doc = r" Proxy"]
        pub struct _CC3DEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3DEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC3DEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CCx DMA request disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4DEW::DISABLED)
            }
            #[doc = "CCx DMA request enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4DEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC2DE`"]
        pub type CC2DEW = CC4DEW;
        #[doc = r" Proxy"]
        pub struct _CC2DEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2DEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC2DEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CCx DMA request disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4DEW::DISABLED)
            }
            #[doc = "CCx DMA request enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4DEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC1DE`"]
        pub type CC1DEW = CC4DEW;
        #[doc = r" Proxy"]
        pub struct _CC1DEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1DEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC1DEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CCx DMA request disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4DEW::DISABLED)
            }
            #[doc = "CCx DMA request enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4DEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UDE`"]
        pub enum UDEW {
            #[doc = "Update DMA request disabled"]
            DISABLED,
            #[doc = "Update DMA request enabled"]
            ENABLED,
        }
        impl UDEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UDEW::DISABLED => false,
                    UDEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UDEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UDEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UDEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Update DMA request disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDEW::DISABLED)
            }
            #[doc = "Update DMA request enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIE`"]
        pub enum TIEW {
            #[doc = "Trigger interrupt disabled"]
            DISABLED,
            #[doc = "Trigger interrupt enabled"]
            ENABLED,
        }
        impl TIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TIEW::DISABLED => false,
                    TIEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Trigger interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIEW::DISABLED)
            }
            #[doc = "Trigger interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC4IE`"]
        pub enum CC4IEW {
            #[doc = "CCx interrupt disabled"]
            DISABLED,
            #[doc = "CCx interrupt enabled"]
            ENABLED,
        }
        impl CC4IEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CC4IEW::DISABLED => false,
                    CC4IEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4IEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4IEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC4IEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4IEW::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4IEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC3IE`"]
        pub type CC3IEW = CC4IEW;
        #[doc = r" Proxy"]
        pub struct _CC3IEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3IEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC3IEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4IEW::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4IEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC2IE`"]
        pub type CC2IEW = CC4IEW;
        #[doc = r" Proxy"]
        pub struct _CC2IEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2IEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC2IEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4IEW::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4IEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC1IE`"]
        pub type CC1IEW = CC4IEW;
        #[doc = r" Proxy"]
        pub struct _CC1IEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1IEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC1IEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CCx interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4IEW::DISABLED)
            }
            #[doc = "CCx interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4IEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UIE`"]
        pub enum UIEW {
            #[doc = "Update interrupt disabled"]
            DISABLED,
            #[doc = "Update interrupt enabled"]
            ENABLED,
        }
        impl UIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UIEW::DISABLED => false,
                    UIEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIEW::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline]
            pub fn tde(&self) -> TDER {
                TDER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
            #[inline]
            pub fn cc4de(&self) -> CC4DER {
                CC4DER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
            #[inline]
            pub fn cc3de(&self) -> CC3DER {
                CC3DER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline]
            pub fn cc2de(&self) -> CC2DER {
                CC2DER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline]
            pub fn cc1de(&self) -> CC1DER {
                CC1DER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline]
            pub fn ude(&self) -> UDER {
                UDER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline]
            pub fn tie(&self) -> TIER {
                TIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
            #[inline]
            pub fn cc4ie(&self) -> CC4IER {
                CC4IER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
            #[inline]
            pub fn cc3ie(&self) -> CC3IER {
                CC3IER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline]
            pub fn cc2ie(&self) -> CC2IER {
                CC2IER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline]
            pub fn cc1ie(&self) -> CC1IER {
                CC1IER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline]
            pub fn uie(&self) -> UIER {
                UIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline]
            pub fn tde(&mut self) -> _TDEW {
                _TDEW { w: self }
            }
            #[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
            #[inline]
            pub fn cc4de(&mut self) -> _CC4DEW {
                _CC4DEW { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
            #[inline]
            pub fn cc3de(&mut self) -> _CC3DEW {
                _CC3DEW { w: self }
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline]
            pub fn cc2de(&mut self) -> _CC2DEW {
                _CC2DEW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline]
            pub fn cc1de(&mut self) -> _CC1DEW {
                _CC1DEW { w: self }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline]
            pub fn ude(&mut self) -> _UDEW {
                _UDEW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline]
            pub fn tie(&mut self) -> _TIEW {
                _TIEW { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
            #[inline]
            pub fn cc4ie(&mut self) -> _CC4IEW {
                _CC4IEW { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
            #[inline]
            pub fn cc3ie(&mut self) -> _CC3IEW {
                _CC3IEW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline]
            pub fn cc2ie(&mut self) -> _CC2IEW {
                _CC2IEW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline]
            pub fn cc1ie(&mut self) -> _CC1IEW {
                _CC1IEW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline]
            pub fn uie(&mut self) -> _UIEW {
                _UIEW { w: self }
            }
        }
    }
    #[doc = "status register"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CC4OF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4OFR {
            #[doc = "The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set"]
            OVERCAPTURE,
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CC4OFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CC4OFR::OVERCAPTURE => true,
                    CC4OFR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CC4OFR {
                match value {
                    true => CC4OFR::OVERCAPTURE,
                    i => CC4OFR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `OVERCAPTURE`"]
            #[inline]
            pub fn is_overcapture(&self) -> bool {
                *self == CC4OFR::OVERCAPTURE
            }
        }
        #[doc = "Possible values of the field `CC3OF`"]
        pub type CC3OFR = CC4OFR;
        #[doc = "Possible values of the field `CC2OF`"]
        pub type CC2OFR = CC4OFR;
        #[doc = "Possible values of the field `CC1OF`"]
        pub type CC1OFR = CC4OFR;
        #[doc = "Possible values of the field `TIF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIFR {
            #[doc = "No trigger event occurred"]
            NOTRIGGER,
            #[doc = "Trigger interrupt pending"]
            TRIGGER,
        }
        impl TIFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TIFR::NOTRIGGER => false,
                    TIFR::TRIGGER => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TIFR {
                match value {
                    false => TIFR::NOTRIGGER,
                    true => TIFR::TRIGGER,
                }
            }
            #[doc = "Checks if the value of the field is `NOTRIGGER`"]
            #[inline]
            pub fn is_no_trigger(&self) -> bool {
                *self == TIFR::NOTRIGGER
            }
            #[doc = "Checks if the value of the field is `TRIGGER`"]
            #[inline]
            pub fn is_trigger(&self) -> bool {
                *self == TIFR::TRIGGER
            }
        }
        #[doc = "Possible values of the field `CC4IF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4IFR {
            #[doc = "If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register."]
            MATCH,
            #[doc = r" Reserved"]
            _Reserved(bool),
        }
        impl CC4IFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CC4IFR::MATCH => true,
                    CC4IFR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CC4IFR {
                match value {
                    true => CC4IFR::MATCH,
                    i => CC4IFR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline]
            pub fn is_match_(&self) -> bool {
                *self == CC4IFR::MATCH
            }
        }
        #[doc = "Possible values of the field `CC3IF`"]
        pub type CC3IFR = CC4IFR;
        #[doc = "Possible values of the field `CC2IF`"]
        pub type CC2IFR = CC4IFR;
        #[doc = "Possible values of the field `CC1IF`"]
        pub type CC1IFR = CC4IFR;
        #[doc = "Possible values of the field `UIF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIFR {
            #[doc = "No update occurred"]
            CLEAR,
            #[doc = "Update interrupt pending."]
            UPDATEPENDING,
        }
        impl UIFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UIFR::CLEAR => false,
                    UIFR::UPDATEPENDING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UIFR {
                match value {
                    false => UIFR::CLEAR,
                    true => UIFR::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline]
            pub fn is_clear(&self) -> bool {
                *self == UIFR::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline]
            pub fn is_update_pending(&self) -> bool {
                *self == UIFR::UPDATEPENDING
            }
        }
        #[doc = "Values that can be written to the field `CC4OF`"]
        pub enum CC4OFW {
            #[doc = "Clear flag"]
            CLEAR,
        }
        impl CC4OFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CC4OFW::CLEAR => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4OFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4OFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC4OFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear flag"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OFW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC3OF`"]
        pub type CC3OFW = CC4OFW;
        #[doc = r" Proxy"]
        pub struct _CC3OFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3OFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC3OFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear flag"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OFW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC2OF`"]
        pub type CC2OFW = CC4OFW;
        #[doc = r" Proxy"]
        pub struct _CC2OFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2OFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC2OFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear flag"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OFW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC1OF`"]
        pub type CC1OFW = CC4OFW;
        #[doc = r" Proxy"]
        pub struct _CC1OFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1OFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC1OFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear flag"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OFW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIF`"]
        pub enum TIFW {
            #[doc = "Clear flag"]
            CLEAR,
        }
        impl TIFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TIFW::CLEAR => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear flag"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(TIFW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC4IF`"]
        pub enum CC4IFW {
            #[doc = "Clear flag"]
            CLEAR,
        }
        impl CC4IFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CC4IFW::CLEAR => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4IFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4IFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC4IFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear flag"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IFW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC3IF`"]
        pub type CC3IFW = CC4IFW;
        #[doc = r" Proxy"]
        pub struct _CC3IFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3IFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC3IFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear flag"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IFW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC2IF`"]
        pub type CC2IFW = CC4IFW;
        #[doc = r" Proxy"]
        pub struct _CC2IFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2IFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC2IFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear flag"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IFW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC1IF`"]
        pub type CC1IFW = CC4IFW;
        #[doc = r" Proxy"]
        pub struct _CC1IFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1IFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC1IFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear flag"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IFW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UIF`"]
        pub enum UIFW {
            #[doc = "No update occurred"]
            CLEAR,
            #[doc = "Update interrupt pending."]
            UPDATEPENDING,
        }
        impl UIFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UIFW::CLEAR => false,
                    UIFW::UPDATEPENDING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UIFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UIFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No update occurred"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIFW::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIFW::UPDATEPENDING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
            #[inline]
            pub fn cc4of(&self) -> CC4OFR {
                CC4OFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
            #[inline]
            pub fn cc3of(&self) -> CC3OFR {
                CC3OFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline]
            pub fn cc2of(&self) -> CC2OFR {
                CC2OFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline]
            pub fn cc1of(&self) -> CC1OFR {
                CC1OFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline]
            pub fn tif(&self) -> TIFR {
                TIFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
            #[inline]
            pub fn cc4if(&self) -> CC4IFR {
                CC4IFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
            #[inline]
            pub fn cc3if(&self) -> CC3IFR {
                CC3IFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline]
            pub fn cc2if(&self) -> CC2IFR {
                CC2IFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline]
            pub fn cc1if(&self) -> CC1IFR {
                CC1IFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline]
            pub fn uif(&self) -> UIFR {
                UIFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
            #[inline]
            pub fn cc4of(&mut self) -> _CC4OFW {
                _CC4OFW { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
            #[inline]
            pub fn cc3of(&mut self) -> _CC3OFW {
                _CC3OFW { w: self }
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline]
            pub fn cc2of(&mut self) -> _CC2OFW {
                _CC2OFW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline]
            pub fn cc1of(&mut self) -> _CC1OFW {
                _CC1OFW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline]
            pub fn tif(&mut self) -> _TIFW {
                _TIFW { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
            #[inline]
            pub fn cc4if(&mut self) -> _CC4IFW {
                _CC4IFW { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
            #[inline]
            pub fn cc3if(&mut self) -> _CC3IFW {
                _CC3IFW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline]
            pub fn cc2if(&mut self) -> _CC2IFW {
                _CC2IFW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline]
            pub fn cc1if(&mut self) -> _CC1IFW {
                _CC1IFW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline]
            pub fn uif(&mut self) -> _UIFW {
                _UIFW { w: self }
            }
        }
    }
    #[doc = "event generation register"]
    pub struct EGR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EGR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Values that can be written to the field `TG`"]
        pub enum TGW {
            #[doc = "The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled."]
            TRIGGER,
        }
        impl TGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TGW::TRIGGER => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled."]
            #[inline]
            pub fn trigger(self) -> &'a mut W {
                self.variant(TGW::TRIGGER)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC4G`"]
        pub enum CC4GW {
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            TRIGGER,
        }
        impl CC4GW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CC4GW::TRIGGER => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4GW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4GW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC4GW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4GW::TRIGGER)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC3G`"]
        pub type CC3GW = CC4GW;
        #[doc = r" Proxy"]
        pub struct _CC3GW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3GW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC3GW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4GW::TRIGGER)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC2G`"]
        pub type CC2GW = CC4GW;
        #[doc = r" Proxy"]
        pub struct _CC2GW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2GW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC2GW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4GW::TRIGGER)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC1G`"]
        pub type CC1GW = CC4GW;
        #[doc = r" Proxy"]
        pub struct _CC1GW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1GW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC1GW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register."]
            #[inline]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4GW::TRIGGER)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UG`"]
        pub enum UGW {
            #[doc = "Re-initializes the timer counter and generates an update of the reigsters."]
            UPDATE,
        }
        impl UGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UGW::UPDATE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the reigsters."]
            #[inline]
            pub fn update(self) -> &'a mut W {
                self.variant(UGW::UPDATE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 6 - Trigger generation"]
            #[inline]
            pub fn tg(&mut self) -> _TGW {
                _TGW { w: self }
            }
            #[doc = "Bit 4 - Capture/compare 4 generation"]
            #[inline]
            pub fn cc4g(&mut self) -> _CC4GW {
                _CC4GW { w: self }
            }
            #[doc = "Bit 3 - Capture/compare 3 generation"]
            #[inline]
            pub fn cc3g(&mut self) -> _CC3GW {
                _CC3GW { w: self }
            }
            #[doc = "Bit 2 - Capture/compare 2 generation"]
            #[inline]
            pub fn cc2g(&mut self) -> _CC2GW {
                _CC2GW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline]
            pub fn cc1g(&mut self) -> _CC1GW {
                _CC1GW { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline]
            pub fn ug(&mut self) -> _UGW {
                _UGW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (output mode)"]
    pub struct CCMR1_OUTPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 1 (output mode)"]
    pub mod ccmr1_output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCMR1_OUTPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC2CER {
            bits: bool,
        }
        impl OC2CER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC2MR {
            bits: u8,
        }
        impl OC2MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC2PER {
            bits: bool,
        }
        impl OC2PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC2FER {
            bits: bool,
        }
        impl OC2FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2SR {
            bits: u8,
        }
        impl CC2SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1CER {
            bits: bool,
        }
        impl OC1CER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1MR {
            bits: u8,
        }
        impl OC1MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1PER {
            bits: bool,
        }
        impl OC1PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1FER {
            bits: bool,
        }
        impl OC1FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1SR {
            bits: u8,
        }
        impl CC1SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC2CEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC2CEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC2MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC2MW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC2PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC2PEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC2FEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC2FEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1CEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1CEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1MW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1PEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1FEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1FEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Output compare 2 clear enable"]
            #[inline]
            pub fn oc2ce(&self) -> OC2CER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC2CER { bits }
            }
            #[doc = "Bits 12:14 - Output compare 2 mode"]
            #[inline]
            pub fn oc2m(&self) -> OC2MR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OC2MR { bits }
            }
            #[doc = "Bit 11 - Output compare 2 preload enable"]
            #[inline]
            pub fn oc2pe(&self) -> OC2PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC2PER { bits }
            }
            #[doc = "Bit 10 - Output compare 2 fast enable"]
            #[inline]
            pub fn oc2fe(&self) -> OC2FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC2FER { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline]
            pub fn cc2s(&self) -> CC2SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC2SR { bits }
            }
            #[doc = "Bit 7 - Output compare 1 clear enable"]
            #[inline]
            pub fn oc1ce(&self) -> OC1CER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC1CER { bits }
            }
            #[doc = "Bits 4:6 - Output compare 1 mode"]
            #[inline]
            pub fn oc1m(&self) -> OC1MR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OC1MR { bits }
            }
            #[doc = "Bit 3 - Output compare 1 preload enable"]
            #[inline]
            pub fn oc1pe(&self) -> OC1PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC1PER { bits }
            }
            #[doc = "Bit 2 - Output compare 1 fast enable"]
            #[inline]
            pub fn oc1fe(&self) -> OC1FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC1FER { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&self) -> CC1SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC1SR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Output compare 2 clear enable"]
            #[inline]
            pub fn oc2ce(&mut self) -> _OC2CEW {
                _OC2CEW { w: self }
            }
            #[doc = "Bits 12:14 - Output compare 2 mode"]
            #[inline]
            pub fn oc2m(&mut self) -> _OC2MW {
                _OC2MW { w: self }
            }
            #[doc = "Bit 11 - Output compare 2 preload enable"]
            #[inline]
            pub fn oc2pe(&mut self) -> _OC2PEW {
                _OC2PEW { w: self }
            }
            #[doc = "Bit 10 - Output compare 2 fast enable"]
            #[inline]
            pub fn oc2fe(&mut self) -> _OC2FEW {
                _OC2FEW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline]
            pub fn cc2s(&mut self) -> _CC2SW {
                _CC2SW { w: self }
            }
            #[doc = "Bit 7 - Output compare 1 clear enable"]
            #[inline]
            pub fn oc1ce(&mut self) -> _OC1CEW {
                _OC1CEW { w: self }
            }
            #[doc = "Bits 4:6 - Output compare 1 mode"]
            #[inline]
            pub fn oc1m(&mut self) -> _OC1MW {
                _OC1MW { w: self }
            }
            #[doc = "Bit 3 - Output compare 1 preload enable"]
            #[inline]
            pub fn oc1pe(&mut self) -> _OC1PEW {
                _OC1PEW { w: self }
            }
            #[doc = "Bit 2 - Output compare 1 fast enable"]
            #[inline]
            pub fn oc1fe(&mut self) -> _OC1FEW {
                _OC1FEW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&mut self) -> _CC1SW {
                _CC1SW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub struct CCMR1_INPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCMR1_INPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC2FR {
            bits: u8,
        }
        impl IC2FR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC2PSCR {
            bits: u8,
        }
        impl IC2PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `CC2S`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC2SR {
            #[doc = "CC2 channel is configured as output"]
            OUTPUT,
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TI2"]
            TI2,
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TI1"]
            TI1,
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TRC"]
            TRC,
        }
        impl CC2SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CC2SR::OUTPUT => 0,
                    CC2SR::TI2 => 0x01,
                    CC2SR::TI1 => 0x02,
                    CC2SR::TRC => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CC2SR {
                match value {
                    0 => CC2SR::OUTPUT,
                    1 => CC2SR::TI2,
                    2 => CC2SR::TI1,
                    3 => CC2SR::TRC,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == CC2SR::OUTPUT
            }
            #[doc = "Checks if the value of the field is `TI2`"]
            #[inline]
            pub fn is_ti2(&self) -> bool {
                *self == CC2SR::TI2
            }
            #[doc = "Checks if the value of the field is `TI1`"]
            #[inline]
            pub fn is_ti1(&self) -> bool {
                *self == CC2SR::TI1
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline]
            pub fn is_trc(&self) -> bool {
                *self == CC2SR::TRC
            }
        }
        #[doc = "Possible values of the field `IC1F`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IC1FR {
            #[doc = "No filter, sampling is done at fDTS"]
            NOFILTER,
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            FCK_INT_N2,
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            FCK_INT_N4,
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            FCK_INT_N8,
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            FDTS_DIV2_N6,
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            FDTS_DIV2_N8,
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            FDTS_DIV4_N6,
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            FDTS_DIV4_N8,
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            FDTS_DIV8_N6,
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            FDTS_DIV8_N8,
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            FDTS_DIV16_N5,
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            FDTS_DIV16_N6,
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            FDTS_DIV16_N8,
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            FDTS_DIV32_N5,
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            FDTS_DIV32_N6,
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            FDTS_DIV32_N8,
        }
        impl IC1FR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    IC1FR::NOFILTER => 0,
                    IC1FR::FCK_INT_N2 => 0x01,
                    IC1FR::FCK_INT_N4 => 0x02,
                    IC1FR::FCK_INT_N8 => 0x03,
                    IC1FR::FDTS_DIV2_N6 => 0x04,
                    IC1FR::FDTS_DIV2_N8 => 0x05,
                    IC1FR::FDTS_DIV4_N6 => 0x06,
                    IC1FR::FDTS_DIV4_N8 => 0x07,
                    IC1FR::FDTS_DIV8_N6 => 0x08,
                    IC1FR::FDTS_DIV8_N8 => 0x09,
                    IC1FR::FDTS_DIV16_N5 => 0x0a,
                    IC1FR::FDTS_DIV16_N6 => 0x0b,
                    IC1FR::FDTS_DIV16_N8 => 0x0c,
                    IC1FR::FDTS_DIV32_N5 => 0x0d,
                    IC1FR::FDTS_DIV32_N6 => 0x0e,
                    IC1FR::FDTS_DIV32_N8 => 0x0f,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> IC1FR {
                match value {
                    0 => IC1FR::NOFILTER,
                    1 => IC1FR::FCK_INT_N2,
                    2 => IC1FR::FCK_INT_N4,
                    3 => IC1FR::FCK_INT_N8,
                    4 => IC1FR::FDTS_DIV2_N6,
                    5 => IC1FR::FDTS_DIV2_N8,
                    6 => IC1FR::FDTS_DIV4_N6,
                    7 => IC1FR::FDTS_DIV4_N8,
                    8 => IC1FR::FDTS_DIV8_N6,
                    9 => IC1FR::FDTS_DIV8_N8,
                    10 => IC1FR::FDTS_DIV16_N5,
                    11 => IC1FR::FDTS_DIV16_N6,
                    12 => IC1FR::FDTS_DIV16_N8,
                    13 => IC1FR::FDTS_DIV32_N5,
                    14 => IC1FR::FDTS_DIV32_N6,
                    15 => IC1FR::FDTS_DIV32_N8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NOFILTER`"]
            #[inline]
            pub fn is_no_filter(&self) -> bool {
                *self == IC1FR::NOFILTER
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N2`"]
            #[inline]
            pub fn is_fck_int_n2(&self) -> bool {
                *self == IC1FR::FCK_INT_N2
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N4`"]
            #[inline]
            pub fn is_fck_int_n4(&self) -> bool {
                *self == IC1FR::FCK_INT_N4
            }
            #[doc = "Checks if the value of the field is `FCK_INT_N8`"]
            #[inline]
            pub fn is_fck_int_n8(&self) -> bool {
                *self == IC1FR::FCK_INT_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N6`"]
            #[inline]
            pub fn is_fdts_div2_n6(&self) -> bool {
                *self == IC1FR::FDTS_DIV2_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV2_N8`"]
            #[inline]
            pub fn is_fdts_div2_n8(&self) -> bool {
                *self == IC1FR::FDTS_DIV2_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N6`"]
            #[inline]
            pub fn is_fdts_div4_n6(&self) -> bool {
                *self == IC1FR::FDTS_DIV4_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV4_N8`"]
            #[inline]
            pub fn is_fdts_div4_n8(&self) -> bool {
                *self == IC1FR::FDTS_DIV4_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N6`"]
            #[inline]
            pub fn is_fdts_div8_n6(&self) -> bool {
                *self == IC1FR::FDTS_DIV8_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV8_N8`"]
            #[inline]
            pub fn is_fdts_div8_n8(&self) -> bool {
                *self == IC1FR::FDTS_DIV8_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N5`"]
            #[inline]
            pub fn is_fdts_div16_n5(&self) -> bool {
                *self == IC1FR::FDTS_DIV16_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N6`"]
            #[inline]
            pub fn is_fdts_div16_n6(&self) -> bool {
                *self == IC1FR::FDTS_DIV16_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV16_N8`"]
            #[inline]
            pub fn is_fdts_div16_n8(&self) -> bool {
                *self == IC1FR::FDTS_DIV16_N8
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N5`"]
            #[inline]
            pub fn is_fdts_div32_n5(&self) -> bool {
                *self == IC1FR::FDTS_DIV32_N5
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N6`"]
            #[inline]
            pub fn is_fdts_div32_n6(&self) -> bool {
                *self == IC1FR::FDTS_DIV32_N6
            }
            #[doc = "Checks if the value of the field is `FDTS_DIV32_N8`"]
            #[inline]
            pub fn is_fdts_div32_n8(&self) -> bool {
                *self == IC1FR::FDTS_DIV32_N8
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC1PSCR {
            bits: u8,
        }
        impl IC1PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `CC1S`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC1SR {
            #[doc = "CC1 channel is configured as output"]
            OUTPUT,
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TI1"]
            TI1,
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TI2"]
            TI2,
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TRC"]
            TRC,
        }
        impl CC1SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CC1SR::OUTPUT => 0,
                    CC1SR::TI1 => 0x01,
                    CC1SR::TI2 => 0x02,
                    CC1SR::TRC => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CC1SR {
                match value {
                    0 => CC1SR::OUTPUT,
                    1 => CC1SR::TI1,
                    2 => CC1SR::TI2,
                    3 => CC1SR::TRC,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == CC1SR::OUTPUT
            }
            #[doc = "Checks if the value of the field is `TI1`"]
            #[inline]
            pub fn is_ti1(&self) -> bool {
                *self == CC1SR::TI1
            }
            #[doc = "Checks if the value of the field is `TI2`"]
            #[inline]
            pub fn is_ti2(&self) -> bool {
                *self == CC1SR::TI2
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline]
            pub fn is_trc(&self) -> bool {
                *self == CC1SR::TRC
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC2FW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC2FW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC2PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC2PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC2S`"]
        pub enum CC2SW {
            #[doc = "CC2 channel is configured as output"]
            OUTPUT,
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TI2"]
            TI2,
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TI1"]
            TI1,
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TRC"]
            TRC,
        }
        impl CC2SW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CC2SW::OUTPUT => 0,
                    CC2SW::TI2 => 1,
                    CC2SW::TI1 => 2,
                    CC2SW::TRC => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2SW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC2SW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "CC2 channel is configured as output"]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(CC2SW::OUTPUT)
            }
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TI2"]
            #[inline]
            pub fn ti2(self) -> &'a mut W {
                self.variant(CC2SW::TI2)
            }
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TI1"]
            #[inline]
            pub fn ti1(self) -> &'a mut W {
                self.variant(CC2SW::TI1)
            }
            #[doc = "CC2 channel is configured as input, IC2 is mapped on TRC"]
            #[inline]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC2SW::TRC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IC1F`"]
        pub enum IC1FW {
            #[doc = "No filter, sampling is done at fDTS"]
            NOFILTER,
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            FCK_INT_N2,
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            FCK_INT_N4,
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            FCK_INT_N8,
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            FDTS_DIV2_N6,
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            FDTS_DIV2_N8,
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            FDTS_DIV4_N6,
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            FDTS_DIV4_N8,
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            FDTS_DIV8_N6,
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            FDTS_DIV8_N8,
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            FDTS_DIV16_N5,
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            FDTS_DIV16_N6,
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            FDTS_DIV16_N8,
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            FDTS_DIV32_N5,
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            FDTS_DIV32_N6,
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            FDTS_DIV32_N8,
        }
        impl IC1FW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IC1FW::NOFILTER => 0,
                    IC1FW::FCK_INT_N2 => 1,
                    IC1FW::FCK_INT_N4 => 2,
                    IC1FW::FCK_INT_N8 => 3,
                    IC1FW::FDTS_DIV2_N6 => 4,
                    IC1FW::FDTS_DIV2_N8 => 5,
                    IC1FW::FDTS_DIV4_N6 => 6,
                    IC1FW::FDTS_DIV4_N8 => 7,
                    IC1FW::FDTS_DIV8_N6 => 8,
                    IC1FW::FDTS_DIV8_N8 => 9,
                    IC1FW::FDTS_DIV16_N5 => 10,
                    IC1FW::FDTS_DIV16_N6 => 11,
                    IC1FW::FDTS_DIV16_N8 => 12,
                    IC1FW::FDTS_DIV32_N5 => 13,
                    IC1FW::FDTS_DIV32_N6 => 14,
                    IC1FW::FDTS_DIV32_N8 => 15,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC1FW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC1FW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IC1FW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No filter, sampling is done at fDTS"]
            #[inline]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(IC1FW::NOFILTER)
            }
            #[doc = "fSAMPLING=fCK_INT, N=2"]
            #[inline]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(IC1FW::FCK_INT_N2)
            }
            #[doc = "fSAMPLING=fCK_INT, N=4"]
            #[inline]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(IC1FW::FCK_INT_N4)
            }
            #[doc = "fSAMPLING=fCK_INT, N=8"]
            #[inline]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(IC1FW::FCK_INT_N8)
            }
            #[doc = "fSAMPLING=fDTS/2, N=6"]
            #[inline]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(IC1FW::FDTS_DIV2_N6)
            }
            #[doc = "fSAMPLING=fDTS/2, N=8"]
            #[inline]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(IC1FW::FDTS_DIV2_N8)
            }
            #[doc = "fSAMPLING=fDTS/4, N=6"]
            #[inline]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(IC1FW::FDTS_DIV4_N6)
            }
            #[doc = "fSAMPLING=fDTS/4, N=8"]
            #[inline]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(IC1FW::FDTS_DIV4_N8)
            }
            #[doc = "fSAMPLING=fDTS/8, N=6"]
            #[inline]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(IC1FW::FDTS_DIV8_N6)
            }
            #[doc = "fSAMPLING=fDTS/8, N=8"]
            #[inline]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(IC1FW::FDTS_DIV8_N8)
            }
            #[doc = "fSAMPLING=fDTS/16, N=5"]
            #[inline]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(IC1FW::FDTS_DIV16_N5)
            }
            #[doc = "fSAMPLING=fDTS/16, N=6"]
            #[inline]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(IC1FW::FDTS_DIV16_N6)
            }
            #[doc = "fSAMPLING=fDTS/16, N=8"]
            #[inline]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(IC1FW::FDTS_DIV16_N8)
            }
            #[doc = "fSAMPLING=fDTS/32, N=5"]
            #[inline]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(IC1FW::FDTS_DIV32_N5)
            }
            #[doc = "fSAMPLING=fDTS/32, N=6"]
            #[inline]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(IC1FW::FDTS_DIV32_N6)
            }
            #[doc = "fSAMPLING=fDTS/32, N=8"]
            #[inline]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(IC1FW::FDTS_DIV32_N8)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC1PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC1PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC1S`"]
        pub enum CC1SW {
            #[doc = "CC1 channel is configured as output"]
            OUTPUT,
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TI1"]
            TI1,
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TI2"]
            TI2,
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TRC"]
            TRC,
        }
        impl CC1SW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CC1SW::OUTPUT => 0,
                    CC1SW::TI1 => 1,
                    CC1SW::TI2 => 2,
                    CC1SW::TRC => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1SW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC1SW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "CC1 channel is configured as output"]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(CC1SW::OUTPUT)
            }
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TI1"]
            #[inline]
            pub fn ti1(self) -> &'a mut W {
                self.variant(CC1SW::TI1)
            }
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TI2"]
            #[inline]
            pub fn ti2(self) -> &'a mut W {
                self.variant(CC1SW::TI2)
            }
            #[doc = "CC1 channel is configured as input, IC1 is mapped on TRC"]
            #[inline]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC1SW::TRC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline]
            pub fn ic2f(&self) -> IC2FR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC2FR { bits }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline]
            pub fn ic2psc(&self) -> IC2PSCR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC2PSCR { bits }
            }
            #[doc = "Bits 8:9 - Capture/compare 2 selection"]
            #[inline]
            pub fn cc2s(&self) -> CC2SR {
                CC2SR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline]
            pub fn ic1f(&self) -> IC1FR {
                IC1FR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline]
            pub fn ic1psc(&self) -> IC1PSCR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC1PSCR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&self) -> CC1SR {
                CC1SR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline]
            pub fn ic2f(&mut self) -> _IC2FW {
                _IC2FW { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline]
            pub fn ic2psc(&mut self) -> _IC2PSCW {
                _IC2PSCW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/compare 2 selection"]
            #[inline]
            pub fn cc2s(&mut self) -> _CC2SW {
                _CC2SW { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline]
            pub fn ic1f(&mut self) -> _IC1FW {
                _IC1FW { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline]
            pub fn ic1psc(&mut self) -> _IC1PSCW {
                _IC1PSCW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&mut self) -> _CC1SW {
                _CC1SW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 2 (output mode)"]
    pub struct CCMR2_OUTPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 2 (output mode)"]
    pub mod ccmr2_output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCMR2_OUTPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC4CER {
            bits: bool,
        }
        impl OC4CER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC4MR {
            bits: u8,
        }
        impl OC4MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC4PER {
            bits: bool,
        }
        impl OC4PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC4FER {
            bits: bool,
        }
        impl OC4FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC4SR {
            bits: u8,
        }
        impl CC4SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC3CER {
            bits: bool,
        }
        impl OC3CER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC3MR {
            bits: u8,
        }
        impl OC3MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC3PER {
            bits: bool,
        }
        impl OC3PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC3FER {
            bits: bool,
        }
        impl OC3FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC3SR {
            bits: u8,
        }
        impl CC3SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC4CEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC4CEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC4MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC4MW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC4PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC4PEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC4FEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC4FEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC3CEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC3CEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC3MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC3MW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC3PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC3PEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC3FEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC3FEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC3SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Output compare 4 clear enable"]
            #[inline]
            pub fn oc4ce(&self) -> OC4CER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC4CER { bits }
            }
            #[doc = "Bits 12:14 - Output compare 4 mode"]
            #[inline]
            pub fn oc4m(&self) -> OC4MR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OC4MR { bits }
            }
            #[doc = "Bit 11 - Output compare 4 preload enable"]
            #[inline]
            pub fn oc4pe(&self) -> OC4PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC4PER { bits }
            }
            #[doc = "Bit 10 - Output compare 4 fast enable"]
            #[inline]
            pub fn oc4fe(&self) -> OC4FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC4FER { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline]
            pub fn cc4s(&self) -> CC4SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC4SR { bits }
            }
            #[doc = "Bit 7 - Output compare 3 clear enable"]
            #[inline]
            pub fn oc3ce(&self) -> OC3CER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC3CER { bits }
            }
            #[doc = "Bits 4:6 - Output compare 3 mode"]
            #[inline]
            pub fn oc3m(&self) -> OC3MR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OC3MR { bits }
            }
            #[doc = "Bit 3 - Output compare 3 preload enable"]
            #[inline]
            pub fn oc3pe(&self) -> OC3PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC3PER { bits }
            }
            #[doc = "Bit 2 - Output compare 3 fast enable"]
            #[inline]
            pub fn oc3fe(&self) -> OC3FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC3FER { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline]
            pub fn cc3s(&self) -> CC3SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC3SR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Output compare 4 clear enable"]
            #[inline]
            pub fn oc4ce(&mut self) -> _OC4CEW {
                _OC4CEW { w: self }
            }
            #[doc = "Bits 12:14 - Output compare 4 mode"]
            #[inline]
            pub fn oc4m(&mut self) -> _OC4MW {
                _OC4MW { w: self }
            }
            #[doc = "Bit 11 - Output compare 4 preload enable"]
            #[inline]
            pub fn oc4pe(&mut self) -> _OC4PEW {
                _OC4PEW { w: self }
            }
            #[doc = "Bit 10 - Output compare 4 fast enable"]
            #[inline]
            pub fn oc4fe(&mut self) -> _OC4FEW {
                _OC4FEW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline]
            pub fn cc4s(&mut self) -> _CC4SW {
                _CC4SW { w: self }
            }
            #[doc = "Bit 7 - Output compare 3 clear enable"]
            #[inline]
            pub fn oc3ce(&mut self) -> _OC3CEW {
                _OC3CEW { w: self }
            }
            #[doc = "Bits 4:6 - Output compare 3 mode"]
            #[inline]
            pub fn oc3m(&mut self) -> _OC3MW {
                _OC3MW { w: self }
            }
            #[doc = "Bit 3 - Output compare 3 preload enable"]
            #[inline]
            pub fn oc3pe(&mut self) -> _OC3PEW {
                _OC3PEW { w: self }
            }
            #[doc = "Bit 2 - Output compare 3 fast enable"]
            #[inline]
            pub fn oc3fe(&mut self) -> _OC3FEW {
                _OC3FEW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline]
            pub fn cc3s(&mut self) -> _CC3SW {
                _CC3SW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 2 (input mode)"]
    pub struct CCMR2_INPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 2 (input mode)"]
    pub mod ccmr2_input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCMR2_INPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC4FR {
            bits: u8,
        }
        impl IC4FR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC4PSCR {
            bits: u8,
        }
        impl IC4PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `CC4S`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4SR {
            #[doc = "CC4 channel is configured as output"]
            OUTPUT,
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TI4"]
            TI4,
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TI3"]
            TI3,
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TRC"]
            TRC,
        }
        impl CC4SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CC4SR::OUTPUT => 0,
                    CC4SR::TI4 => 0x01,
                    CC4SR::TI3 => 0x02,
                    CC4SR::TRC => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CC4SR {
                match value {
                    0 => CC4SR::OUTPUT,
                    1 => CC4SR::TI4,
                    2 => CC4SR::TI3,
                    3 => CC4SR::TRC,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == CC4SR::OUTPUT
            }
            #[doc = "Checks if the value of the field is `TI4`"]
            #[inline]
            pub fn is_ti4(&self) -> bool {
                *self == CC4SR::TI4
            }
            #[doc = "Checks if the value of the field is `TI3`"]
            #[inline]
            pub fn is_ti3(&self) -> bool {
                *self == CC4SR::TI3
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline]
            pub fn is_trc(&self) -> bool {
                *self == CC4SR::TRC
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC3FR {
            bits: u8,
        }
        impl IC3FR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC3PSCR {
            bits: u8,
        }
        impl IC3PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `CC3S`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC3SR {
            #[doc = "CC3 channel is configured as output"]
            OUTPUT,
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TI3"]
            TI3,
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TI4"]
            TI4,
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TRC"]
            TRC,
        }
        impl CC3SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CC3SR::OUTPUT => 0,
                    CC3SR::TI3 => 0x01,
                    CC3SR::TI4 => 0x02,
                    CC3SR::TRC => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CC3SR {
                match value {
                    0 => CC3SR::OUTPUT,
                    1 => CC3SR::TI3,
                    2 => CC3SR::TI4,
                    3 => CC3SR::TRC,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == CC3SR::OUTPUT
            }
            #[doc = "Checks if the value of the field is `TI3`"]
            #[inline]
            pub fn is_ti3(&self) -> bool {
                *self == CC3SR::TI3
            }
            #[doc = "Checks if the value of the field is `TI4`"]
            #[inline]
            pub fn is_ti4(&self) -> bool {
                *self == CC3SR::TI4
            }
            #[doc = "Checks if the value of the field is `TRC`"]
            #[inline]
            pub fn is_trc(&self) -> bool {
                *self == CC3SR::TRC
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC4FW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC4FW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC4PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC4PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC4S`"]
        pub enum CC4SW {
            #[doc = "CC4 channel is configured as output"]
            OUTPUT,
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TI4"]
            TI4,
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TI3"]
            TI3,
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TRC"]
            TRC,
        }
        impl CC4SW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CC4SW::OUTPUT => 0,
                    CC4SW::TI4 => 1,
                    CC4SW::TI3 => 2,
                    CC4SW::TRC => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4SW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC4SW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "CC4 channel is configured as output"]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(CC4SW::OUTPUT)
            }
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TI4"]
            #[inline]
            pub fn ti4(self) -> &'a mut W {
                self.variant(CC4SW::TI4)
            }
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TI3"]
            #[inline]
            pub fn ti3(self) -> &'a mut W {
                self.variant(CC4SW::TI3)
            }
            #[doc = "CC4 channel is configured as input, IC4 is mapped on TRC"]
            #[inline]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC4SW::TRC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC3FW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC3FW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC3PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC3PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC3S`"]
        pub enum CC3SW {
            #[doc = "CC3 channel is configured as output"]
            OUTPUT,
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TI3"]
            TI3,
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TI4"]
            TI4,
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TRC"]
            TRC,
        }
        impl CC3SW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CC3SW::OUTPUT => 0,
                    CC3SW::TI3 => 1,
                    CC3SW::TI4 => 2,
                    CC3SW::TRC => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC3SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3SW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC3SW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "CC3 channel is configured as output"]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(CC3SW::OUTPUT)
            }
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TI3"]
            #[inline]
            pub fn ti3(self) -> &'a mut W {
                self.variant(CC3SW::TI3)
            }
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TI4"]
            #[inline]
            pub fn ti4(self) -> &'a mut W {
                self.variant(CC3SW::TI4)
            }
            #[doc = "CC3 channel is configured as input, IC3 is mapped on TRC"]
            #[inline]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC3SW::TRC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 12:15 - Input capture 4 filter"]
            #[inline]
            pub fn ic4f(&self) -> IC4FR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC4FR { bits }
            }
            #[doc = "Bits 10:11 - Input capture 4 prescaler"]
            #[inline]
            pub fn ic4psc(&self) -> IC4PSCR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC4PSCR { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline]
            pub fn cc4s(&self) -> CC4SR {
                CC4SR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 4:7 - Input capture 3 filter"]
            #[inline]
            pub fn ic3f(&self) -> IC3FR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC3FR { bits }
            }
            #[doc = "Bits 2:3 - Input capture 3 prescaler"]
            #[inline]
            pub fn ic3psc(&self) -> IC3PSCR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC3PSCR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline]
            pub fn cc3s(&self) -> CC3SR {
                CC3SR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 12:15 - Input capture 4 filter"]
            #[inline]
            pub fn ic4f(&mut self) -> _IC4FW {
                _IC4FW { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 4 prescaler"]
            #[inline]
            pub fn ic4psc(&mut self) -> _IC4PSCW {
                _IC4PSCW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline]
            pub fn cc4s(&mut self) -> _CC4SW {
                _CC4SW { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 3 filter"]
            #[inline]
            pub fn ic3f(&mut self) -> _IC3FW {
                _IC3FW { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 3 prescaler"]
            #[inline]
            pub fn ic3psc(&mut self) -> _IC3PSCW {
                _IC3PSCW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline]
            pub fn cc3s(&mut self) -> _CC3SW {
                _CC3SW { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register"]
    pub struct CCER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC4PR {
            bits: bool,
        }
        impl CC4PR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC4ER {
            bits: bool,
        }
        impl CC4ER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC3PR {
            bits: bool,
        }
        impl CC3PR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC3ER {
            bits: bool,
        }
        impl CC3ER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2PR {
            bits: bool,
        }
        impl CC2PR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2ER {
            bits: bool,
        }
        impl CC2ER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1PR {
            bits: bool,
        }
        impl CC1PR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1ER {
            bits: bool,
        }
        impl CC1ER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4PW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4PW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC4EW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC4EW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC3PW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3PW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC3EW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC3EW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2PW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2PW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2EW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2EW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1PW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1PW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1EW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1EW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
            #[inline]
            pub fn cc4p(&self) -> CC4PR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC4PR { bits }
            }
            #[doc = "Bit 12 - Capture/Compare 4 output enable"]
            #[inline]
            pub fn cc4e(&self) -> CC4ER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC4ER { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
            #[inline]
            pub fn cc3p(&self) -> CC3PR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC3PR { bits }
            }
            #[doc = "Bit 8 - Capture/Compare 3 output enable"]
            #[inline]
            pub fn cc3e(&self) -> CC3ER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC3ER { bits }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline]
            pub fn cc2p(&self) -> CC2PR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2PR { bits }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline]
            pub fn cc2e(&self) -> CC2ER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2ER { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1p(&self) -> CC1PR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1PR { bits }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline]
            pub fn cc1e(&self) -> CC1ER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1ER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
            #[inline]
            pub fn cc4p(&mut self) -> _CC4PW {
                _CC4PW { w: self }
            }
            #[doc = "Bit 12 - Capture/Compare 4 output enable"]
            #[inline]
            pub fn cc4e(&mut self) -> _CC4EW {
                _CC4EW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
            #[inline]
            pub fn cc3p(&mut self) -> _CC3PW {
                _CC3PW { w: self }
            }
            #[doc = "Bit 8 - Capture/Compare 3 output enable"]
            #[inline]
            pub fn cc3e(&mut self) -> _CC3EW {
                _CC3EW { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline]
            pub fn cc2p(&mut self) -> _CC2PW {
                _CC2PW { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline]
            pub fn cc2e(&mut self) -> _CC2EW {
                _CC2EW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1p(&mut self) -> _CC1PW {
                _CC1PW { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline]
            pub fn cc1e(&mut self) -> _CC1EW {
                _CC1EW { w: self }
            }
        }
    }
    #[doc = "counter"]
    pub struct CNT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "counter"]
    pub mod cnt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNTR {
            bits: u16,
        }
        impl CNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline]
            pub fn cnt(&self) -> CNTR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline]
            pub fn cnt(&mut self) -> _CNTW {
                _CNTW { w: self }
            }
        }
    }
    #[doc = "prescaler"]
    pub struct PSC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PSCR {
            bits: u16,
        }
        impl PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline]
            pub fn psc(&self) -> PSCR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PSCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline]
            pub fn psc(&mut self) -> _PSCW {
                _PSCW { w: self }
            }
        }
    }
    #[doc = "auto-reload register"]
    pub struct ARR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ARR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ARRR {
            bits: u16,
        }
        impl ARRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ARRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ARRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline]
            pub fn arr(&self) -> ARRR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ARRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline]
            pub fn arr(&mut self) -> _ARRW {
                _ARRW { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1"]
    pub struct CCR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare register 1"]
    pub mod ccr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCR1R {
            bits: u16,
        }
        impl CCR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCR1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline]
            pub fn ccr1(&self) -> CCR1R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CCR1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline]
            pub fn ccr1(&mut self) -> _CCR1W {
                _CCR1W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 2"]
    pub struct CCR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare register 2"]
    pub mod ccr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCR2R {
            bits: u16,
        }
        impl CCR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCR2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 2 value"]
            #[inline]
            pub fn ccr2(&self) -> CCR2R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CCR2R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 2 value"]
            #[inline]
            pub fn ccr2(&mut self) -> _CCR2W {
                _CCR2W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 3"]
    pub struct CCR3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare register 3"]
    pub mod ccr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCR3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCR3R {
            bits: u16,
        }
        impl CCR3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCR3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare value"]
            #[inline]
            pub fn ccr3(&self) -> CCR3R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CCR3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare value"]
            #[inline]
            pub fn ccr3(&mut self) -> _CCR3W {
                _CCR3W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 4"]
    pub struct CCR4 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare register 4"]
    pub mod ccr4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCR4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCR4R {
            bits: u16,
        }
        impl CCR4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCR4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare value"]
            #[inline]
            pub fn ccr4(&self) -> CCR4R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CCR4R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare value"]
            #[inline]
            pub fn ccr4(&mut self) -> _CCR4W {
                _CCR4W { w: self }
            }
        }
    }
    #[doc = "DMA control register"]
    pub struct DCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA control register"]
    pub mod dcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBLR {
            bits: u8,
        }
        impl DBLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBAR {
            bits: u8,
        }
        impl DBAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline]
            pub fn dbl(&self) -> DBLR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DBLR { bits }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline]
            pub fn dba(&self) -> DBAR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DBAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline]
            pub fn dbl(&mut self) -> _DBLW {
                _DBLW { w: self }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline]
            pub fn dba(&mut self) -> _DBAW {
                _DBAW { w: self }
            }
        }
    }
    #[doc = "DMA address for full transfer"]
    pub struct DMAR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA address for full transfer"]
    pub mod dmar {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMAR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMABR {
            bits: u16,
        }
        impl DMABR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMABW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMABW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline]
            pub fn dmab(&self) -> DMABR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DMABR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline]
            pub fn dmab(&mut self) -> _DMABW {
                _DMABW { w: self }
            }
        }
    }
}
#[doc = "TIM3"]
#[cfg(feature = "tim3")]
pub struct TIM3 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "tim3")]
unsafe impl Send for TIM3 {}
#[cfg(feature = "tim3")]
impl TIM3 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const tim2::RegisterBlock {
        0x4000_0400 as *const _
    }
}
#[cfg(feature = "tim3")]
impl Deref for TIM3 {
    type Target = tim2::RegisterBlock;
    fn deref(&self) -> &tim2::RegisterBlock {
        unsafe { &*TIM3::ptr() }
    }
}
#[doc = "TIM4"]
#[cfg(feature = "tim4")]
pub struct TIM4 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "tim4")]
unsafe impl Send for TIM4 {}
#[cfg(feature = "tim4")]
impl TIM4 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const tim2::RegisterBlock {
        0x4000_0800 as *const _
    }
}
#[cfg(feature = "tim4")]
impl Deref for TIM4 {
    type Target = tim2::RegisterBlock;
    fn deref(&self) -> &tim2::RegisterBlock {
        unsafe { &*TIM4::ptr() }
    }
}
#[doc = "TIM5"]
#[cfg(feature = "tim5")]
pub struct TIM5 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "tim5")]
unsafe impl Send for TIM5 {}
#[cfg(feature = "tim5")]
impl TIM5 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const tim2::RegisterBlock {
        0x4000_0c00 as *const _
    }
}
#[cfg(feature = "tim5")]
impl Deref for TIM5 {
    type Target = tim2::RegisterBlock;
    fn deref(&self) -> &tim2::RegisterBlock {
        unsafe { &*TIM5::ptr() }
    }
}
#[doc = "General purpose timer"]
#[cfg(feature = "tim12")]
pub struct TIM12 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "tim12")]
unsafe impl Send for TIM12 {}
#[cfg(feature = "tim12")]
impl TIM12 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const tim12::RegisterBlock {
        0x4000_1800 as *const _
    }
}
#[cfg(feature = "tim12")]
impl Deref for TIM12 {
    type Target = tim12::RegisterBlock;
    fn deref(&self) -> &tim12::RegisterBlock {
        unsafe { &*TIM12::ptr() }
    }
}
#[doc = "General purpose timer"]
#[cfg(feature = "tim12")]
pub mod tim12 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - slave mode control register"]
        pub smcr: SMCR,
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        #[doc = "0x18 - capture/compare mode register 1 (output mode)"]
        pub ccmr1_output: CCMR1_OUTPUT,
        _reserved0: [u8; 4usize],
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: CCER,
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
        _reserved1: [u8; 4usize],
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: CCR1,
        #[doc = "0x38 - capture/compare register 2"]
        pub ccr2: CCR2,
    }
    #[doc = "control register 1"]
    pub struct CR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CKDR {
            bits: u8,
        }
        impl CKDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `ARPE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPER {
            #[doc = "TIMx_APRR register is not buffered"]
            DISABLED,
            #[doc = "TIMx_APRR register is buffered"]
            ENABLED,
        }
        impl ARPER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ARPER::DISABLED => false,
                    ARPER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ARPER {
                match value {
                    false => ARPER::DISABLED,
                    true => ARPER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ARPER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ARPER::ENABLED
            }
        }
        #[doc = "Possible values of the field `OPM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPMR {
            #[doc = "Counter is not stopped at update event"]
            DISABLED,
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            ENABLED,
        }
        impl OPMR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OPMR::DISABLED => false,
                    OPMR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OPMR {
                match value {
                    false => OPMR::DISABLED,
                    true => OPMR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == OPMR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == OPMR::ENABLED
            }
        }
        #[doc = "Possible values of the field `URS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URSR {
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT,
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY,
        }
        impl URSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    URSR::ANYEVENT => false,
                    URSR::COUNTERONLY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> URSR {
                match value {
                    false => URSR::ANYEVENT,
                    true => URSR::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline]
            pub fn is_any_event(&self) -> bool {
                *self == URSR::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline]
            pub fn is_counter_only(&self) -> bool {
                *self == URSR::COUNTERONLY
            }
        }
        #[doc = "Possible values of the field `UDIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDISR {
            #[doc = "Update event enabled"]
            ENABLED,
            #[doc = "Update event disabled"]
            DISABLED,
        }
        impl UDISR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UDISR::ENABLED => false,
                    UDISR::DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UDISR {
                match value {
                    false => UDISR::ENABLED,
                    true => UDISR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UDISR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UDISR::DISABLED
            }
        }
        #[doc = "Possible values of the field `CEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CENR {
            #[doc = "Counter disabled"]
            DISABLED,
            #[doc = "Counter enabled"]
            ENABLED,
        }
        impl CENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CENR::DISABLED => false,
                    CENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CENR {
                match value {
                    false => CENR::DISABLED,
                    true => CENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CENR::ENABLED
            }
        }
        #[doc = r" Proxy"]
        pub struct _CKDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CKDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ARPE`"]
        pub enum ARPEW {
            #[doc = "TIMx_APRR register is not buffered"]
            DISABLED,
            #[doc = "TIMx_APRR register is buffered"]
            ENABLED,
        }
        impl ARPEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ARPEW::DISABLED => false,
                    ARPEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ARPEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ARPEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ARPEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPEW::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OPM`"]
        pub enum OPMW {
            #[doc = "Counter is not stopped at update event"]
            DISABLED,
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            ENABLED,
        }
        impl OPMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OPMW::DISABLED => false,
                    OPMW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OPMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OPMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OPMW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Counter is not stopped at update event"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OPMW::DISABLED)
            }
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OPMW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `URS`"]
        pub enum URSW {
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT,
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY,
        }
        impl URSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    URSW::ANYEVENT => false,
                    URSW::COUNTERONLY => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _URSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _URSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: URSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URSW::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URSW::COUNTERONLY)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UDIS`"]
        pub enum UDISW {
            #[doc = "Update event enabled"]
            ENABLED,
            #[doc = "Update event disabled"]
            DISABLED,
        }
        impl UDISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UDISW::ENABLED => false,
                    UDISW::DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UDISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UDISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UDISW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Update event enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDISW::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDISW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CEN`"]
        pub enum CENW {
            #[doc = "Counter disabled"]
            DISABLED,
            #[doc = "Counter enabled"]
            ENABLED,
        }
        impl CENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CENW::DISABLED => false,
                    CENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Counter disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CENW::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline]
            pub fn ckd(&self) -> CKDR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CKDR { bits }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline]
            pub fn arpe(&self) -> ARPER {
                ARPER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline]
            pub fn opm(&self) -> OPMR {
                OPMR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline]
            pub fn urs(&self) -> URSR {
                URSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline]
            pub fn udis(&self) -> UDISR {
                UDISR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline]
            pub fn cen(&self) -> CENR {
                CENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline]
            pub fn ckd(&mut self) -> _CKDW {
                _CKDW { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline]
            pub fn arpe(&mut self) -> _ARPEW {
                _ARPEW { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline]
            pub fn opm(&mut self) -> _OPMW {
                _OPMW { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline]
            pub fn urs(&mut self) -> _URSW {
                _URSW { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline]
            pub fn udis(&mut self) -> _UDISW {
                _UDISW { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline]
            pub fn cen(&mut self) -> _CENW {
                _CENW { w: self }
            }
        }
    }
    #[doc = "control register 2"]
    pub struct CR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MMSR {
            bits: u8,
        }
        impl MMSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MMSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MMSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline]
            pub fn mms(&self) -> MMSR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MMSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline]
            pub fn mms(&mut self) -> _MMSW {
                _MMSW { w: self }
            }
        }
    }
    #[doc = "slave mode control register"]
    pub struct SMCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "slave mode control register"]
    pub mod smcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SMCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSMR {
            bits: bool,
        }
        impl MSMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TSR {
            bits: u8,
        }
        impl TSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMSR {
            bits: u8,
        }
        impl SMSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline]
            pub fn msm(&self) -> MSMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MSMR { bits }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline]
            pub fn ts(&self) -> TSR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TSR { bits }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline]
            pub fn sms(&self) -> SMSR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline]
            pub fn msm(&mut self) -> _MSMW {
                _MSMW { w: self }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline]
            pub fn ts(&mut self) -> _TSW {
                _TSW { w: self }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline]
            pub fn sms(&mut self) -> _SMSW {
                _SMSW { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register"]
    pub struct DIER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIER {
            bits: bool,
        }
        impl TIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2IER {
            bits: bool,
        }
        impl CC2IER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1IER {
            bits: bool,
        }
        impl CC1IER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `UIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIER {
            #[doc = "Update interrupt disabled"]
            DISABLED,
            #[doc = "Update interrupt enabled"]
            ENABLED,
        }
        impl UIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UIER::DISABLED => false,
                    UIER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UIER {
                match value {
                    false => UIER::DISABLED,
                    true => UIER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UIER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UIER::ENABLED
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2IEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2IEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1IEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1IEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UIE`"]
        pub enum UIEW {
            #[doc = "Update interrupt disabled"]
            DISABLED,
            #[doc = "Update interrupt enabled"]
            ENABLED,
        }
        impl UIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UIEW::DISABLED => false,
                    UIEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIEW::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline]
            pub fn tie(&self) -> TIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIER { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline]
            pub fn cc2ie(&self) -> CC2IER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2IER { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline]
            pub fn cc1ie(&self) -> CC1IER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1IER { bits }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline]
            pub fn uie(&self) -> UIER {
                UIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline]
            pub fn tie(&mut self) -> _TIEW {
                _TIEW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline]
            pub fn cc2ie(&mut self) -> _CC2IEW {
                _CC2IEW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline]
            pub fn cc1ie(&mut self) -> _CC1IEW {
                _CC1IEW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline]
            pub fn uie(&mut self) -> _UIEW {
                _UIEW { w: self }
            }
        }
    }
    #[doc = "status register"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2OFR {
            bits: bool,
        }
        impl CC2OFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1OFR {
            bits: bool,
        }
        impl CC1OFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIFR {
            bits: bool,
        }
        impl TIFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2IFR {
            bits: bool,
        }
        impl CC2IFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1IFR {
            bits: bool,
        }
        impl CC1IFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `UIF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIFR {
            #[doc = "No update occurred"]
            CLEAR,
            #[doc = "Update interrupt pending."]
            UPDATEPENDING,
        }
        impl UIFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UIFR::CLEAR => false,
                    UIFR::UPDATEPENDING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UIFR {
                match value {
                    false => UIFR::CLEAR,
                    true => UIFR::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline]
            pub fn is_clear(&self) -> bool {
                *self == UIFR::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline]
            pub fn is_update_pending(&self) -> bool {
                *self == UIFR::UPDATEPENDING
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2OFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2OFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1OFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1OFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2IFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2IFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1IFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1IFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UIF`"]
        pub enum UIFW {
            #[doc = "No update occurred"]
            CLEAR,
            #[doc = "Update interrupt pending."]
            UPDATEPENDING,
        }
        impl UIFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UIFW::CLEAR => false,
                    UIFW::UPDATEPENDING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UIFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UIFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No update occurred"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIFW::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIFW::UPDATEPENDING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline]
            pub fn cc2of(&self) -> CC2OFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2OFR { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline]
            pub fn cc1of(&self) -> CC1OFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1OFR { bits }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline]
            pub fn tif(&self) -> TIFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIFR { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline]
            pub fn cc2if(&self) -> CC2IFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2IFR { bits }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline]
            pub fn cc1if(&self) -> CC1IFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1IFR { bits }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline]
            pub fn uif(&self) -> UIFR {
                UIFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline]
            pub fn cc2of(&mut self) -> _CC2OFW {
                _CC2OFW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline]
            pub fn cc1of(&mut self) -> _CC1OFW {
                _CC1OFW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline]
            pub fn tif(&mut self) -> _TIFW {
                _TIFW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline]
            pub fn cc2if(&mut self) -> _CC2IFW {
                _CC2IFW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline]
            pub fn cc1if(&mut self) -> _CC1IFW {
                _CC1IFW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline]
            pub fn uif(&mut self) -> _UIFW {
                _UIFW { w: self }
            }
        }
    }
    #[doc = "event generation register"]
    pub struct EGR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EGR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _TGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2GW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2GW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1GW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1GW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UG`"]
        pub enum UGW {
            #[doc = "Re-initializes the timer counter and generates an update of the reigsters."]
            UPDATE,
        }
        impl UGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UGW::UPDATE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the reigsters."]
            #[inline]
            pub fn update(self) -> &'a mut W {
                self.variant(UGW::UPDATE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 6 - Trigger generation"]
            #[inline]
            pub fn tg(&mut self) -> _TGW {
                _TGW { w: self }
            }
            #[doc = "Bit 2 - Capture/compare 2 generation"]
            #[inline]
            pub fn cc2g(&mut self) -> _CC2GW {
                _CC2GW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline]
            pub fn cc1g(&mut self) -> _CC1GW {
                _CC1GW { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline]
            pub fn ug(&mut self) -> _UGW {
                _UGW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (output mode)"]
    pub struct CCMR1_OUTPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 1 (output mode)"]
    pub mod ccmr1_output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCMR1_OUTPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC2MR {
            bits: u8,
        }
        impl OC2MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC2PER {
            bits: bool,
        }
        impl OC2PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC2FER {
            bits: bool,
        }
        impl OC2FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2SR {
            bits: u8,
        }
        impl CC2SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1MR {
            bits: u8,
        }
        impl OC1MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1PER {
            bits: bool,
        }
        impl OC1PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1FER {
            bits: bool,
        }
        impl OC1FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1SR {
            bits: u8,
        }
        impl CC1SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC2MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC2MW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC2PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC2PEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC2FEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC2FEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1MW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1PEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1FEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1FEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline]
            pub fn oc2m(&self) -> OC2MR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OC2MR { bits }
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline]
            pub fn oc2pe(&self) -> OC2PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC2PER { bits }
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline]
            pub fn oc2fe(&self) -> OC2FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC2FER { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline]
            pub fn cc2s(&self) -> CC2SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC2SR { bits }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline]
            pub fn oc1m(&self) -> OC1MR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OC1MR { bits }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline]
            pub fn oc1pe(&self) -> OC1PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC1PER { bits }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline]
            pub fn oc1fe(&self) -> OC1FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC1FER { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&self) -> CC1SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC1SR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline]
            pub fn oc2m(&mut self) -> _OC2MW {
                _OC2MW { w: self }
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline]
            pub fn oc2pe(&mut self) -> _OC2PEW {
                _OC2PEW { w: self }
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline]
            pub fn oc2fe(&mut self) -> _OC2FEW {
                _OC2FEW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline]
            pub fn cc2s(&mut self) -> _CC2SW {
                _CC2SW { w: self }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline]
            pub fn oc1m(&mut self) -> _OC1MW {
                _OC1MW { w: self }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline]
            pub fn oc1pe(&mut self) -> _OC1PEW {
                _OC1PEW { w: self }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline]
            pub fn oc1fe(&mut self) -> _OC1FEW {
                _OC1FEW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&mut self) -> _CC1SW {
                _CC1SW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub struct CCMR1_INPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCMR1_INPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC2FR {
            bits: u8,
        }
        impl IC2FR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC2PSCR {
            bits: u8,
        }
        impl IC2PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2SR {
            bits: u8,
        }
        impl CC2SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC1FR {
            bits: u8,
        }
        impl IC1FR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC1PSCR {
            bits: u8,
        }
        impl IC1PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1SR {
            bits: u8,
        }
        impl CC1SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC2FW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC2FW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC2PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC2PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC1FW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC1FW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC1PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC1PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 12:14 - Input capture 2 filter"]
            #[inline]
            pub fn ic2f(&self) -> IC2FR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC2FR { bits }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline]
            pub fn ic2psc(&self) -> IC2PSCR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC2PSCR { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline]
            pub fn cc2s(&self) -> CC2SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC2SR { bits }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline]
            pub fn ic1f(&self) -> IC1FR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC1FR { bits }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline]
            pub fn ic1psc(&self) -> IC1PSCR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC1PSCR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&self) -> CC1SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC1SR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 12:14 - Input capture 2 filter"]
            #[inline]
            pub fn ic2f(&mut self) -> _IC2FW {
                _IC2FW { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline]
            pub fn ic2psc(&mut self) -> _IC2PSCW {
                _IC2PSCW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline]
            pub fn cc2s(&mut self) -> _CC2SW {
                _CC2SW { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline]
            pub fn ic1f(&mut self) -> _IC1FW {
                _IC1FW { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline]
            pub fn ic1psc(&mut self) -> _IC1PSCW {
                _IC1PSCW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&mut self) -> _CC1SW {
                _CC1SW { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register"]
    pub struct CCER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2NPR {
            bits: bool,
        }
        impl CC2NPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2PR {
            bits: bool,
        }
        impl CC2PR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2ER {
            bits: bool,
        }
        impl CC2ER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1NPR {
            bits: bool,
        }
        impl CC1NPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1PR {
            bits: bool,
        }
        impl CC1PR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1ER {
            bits: bool,
        }
        impl CC1ER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2NPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2NPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2PW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2PW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2EW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2EW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1NPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1NPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1PW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1PW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1EW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1EW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline]
            pub fn cc2np(&self) -> CC2NPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2NPR { bits }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline]
            pub fn cc2p(&self) -> CC2PR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2PR { bits }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline]
            pub fn cc2e(&self) -> CC2ER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2ER { bits }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1np(&self) -> CC1NPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1NPR { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1p(&self) -> CC1PR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1PR { bits }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline]
            pub fn cc1e(&self) -> CC1ER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1ER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline]
            pub fn cc2np(&mut self) -> _CC2NPW {
                _CC2NPW { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline]
            pub fn cc2p(&mut self) -> _CC2PW {
                _CC2PW { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline]
            pub fn cc2e(&mut self) -> _CC2EW {
                _CC2EW { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1np(&mut self) -> _CC1NPW {
                _CC1NPW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1p(&mut self) -> _CC1PW {
                _CC1PW { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline]
            pub fn cc1e(&mut self) -> _CC1EW {
                _CC1EW { w: self }
            }
        }
    }
    #[doc = "counter"]
    pub struct CNT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "counter"]
    pub mod cnt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNTR {
            bits: u16,
        }
        impl CNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline]
            pub fn cnt(&self) -> CNTR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline]
            pub fn cnt(&mut self) -> _CNTW {
                _CNTW { w: self }
            }
        }
    }
    #[doc = "prescaler"]
    pub struct PSC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PSCR {
            bits: u16,
        }
        impl PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline]
            pub fn psc(&self) -> PSCR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PSCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline]
            pub fn psc(&mut self) -> _PSCW {
                _PSCW { w: self }
            }
        }
    }
    #[doc = "auto-reload register"]
    pub struct ARR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ARR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ARRR {
            bits: u16,
        }
        impl ARRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ARRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ARRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline]
            pub fn arr(&self) -> ARRR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ARRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline]
            pub fn arr(&mut self) -> _ARRW {
                _ARRW { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1"]
    pub struct CCR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare register 1"]
    pub mod ccr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCR1R {
            bits: u16,
        }
        impl CCR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCR1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline]
            pub fn ccr1(&self) -> CCR1R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CCR1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline]
            pub fn ccr1(&mut self) -> _CCR1W {
                _CCR1W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 2"]
    pub struct CCR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare register 2"]
    pub mod ccr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCR2R {
            bits: u16,
        }
        impl CCR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCR2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 2 value"]
            #[inline]
            pub fn ccr2(&self) -> CCR2R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CCR2R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 2 value"]
            #[inline]
            pub fn ccr2(&mut self) -> _CCR2W {
                _CCR2W { w: self }
            }
        }
    }
}
#[doc = "General purpose timer"]
#[cfg(feature = "tim13")]
pub struct TIM13 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "tim13")]
unsafe impl Send for TIM13 {}
#[cfg(feature = "tim13")]
impl TIM13 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const tim13::RegisterBlock {
        0x4000_1c00 as *const _
    }
}
#[cfg(feature = "tim13")]
impl Deref for TIM13 {
    type Target = tim13::RegisterBlock;
    fn deref(&self) -> &tim13::RegisterBlock {
        unsafe { &*TIM13::ptr() }
    }
}
#[doc = "General purpose timer"]
#[cfg(feature = "tim13")]
pub mod tim13 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        _reserved0: [u8; 8usize],
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        pub ccmr1_output: CCMR1_OUTPUT,
        _reserved1: [u8; 4usize],
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: CCER,
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
        _reserved2: [u8; 4usize],
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: CCR1,
    }
    #[doc = "control register 1"]
    pub struct CR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CKDR {
            bits: u8,
        }
        impl CKDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `ARPE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPER {
            #[doc = "TIMx_APRR register is not buffered"]
            DISABLED,
            #[doc = "TIMx_APRR register is buffered"]
            ENABLED,
        }
        impl ARPER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ARPER::DISABLED => false,
                    ARPER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ARPER {
                match value {
                    false => ARPER::DISABLED,
                    true => ARPER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ARPER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ARPER::ENABLED
            }
        }
        #[doc = "Possible values of the field `URS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URSR {
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT,
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY,
        }
        impl URSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    URSR::ANYEVENT => false,
                    URSR::COUNTERONLY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> URSR {
                match value {
                    false => URSR::ANYEVENT,
                    true => URSR::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline]
            pub fn is_any_event(&self) -> bool {
                *self == URSR::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline]
            pub fn is_counter_only(&self) -> bool {
                *self == URSR::COUNTERONLY
            }
        }
        #[doc = "Possible values of the field `UDIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDISR {
            #[doc = "Update event enabled"]
            ENABLED,
            #[doc = "Update event disabled"]
            DISABLED,
        }
        impl UDISR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UDISR::ENABLED => false,
                    UDISR::DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UDISR {
                match value {
                    false => UDISR::ENABLED,
                    true => UDISR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UDISR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UDISR::DISABLED
            }
        }
        #[doc = "Possible values of the field `CEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CENR {
            #[doc = "Counter disabled"]
            DISABLED,
            #[doc = "Counter enabled"]
            ENABLED,
        }
        impl CENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CENR::DISABLED => false,
                    CENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CENR {
                match value {
                    false => CENR::DISABLED,
                    true => CENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CENR::ENABLED
            }
        }
        #[doc = r" Proxy"]
        pub struct _CKDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CKDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ARPE`"]
        pub enum ARPEW {
            #[doc = "TIMx_APRR register is not buffered"]
            DISABLED,
            #[doc = "TIMx_APRR register is buffered"]
            ENABLED,
        }
        impl ARPEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ARPEW::DISABLED => false,
                    ARPEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ARPEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ARPEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ARPEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPEW::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `URS`"]
        pub enum URSW {
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT,
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY,
        }
        impl URSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    URSW::ANYEVENT => false,
                    URSW::COUNTERONLY => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _URSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _URSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: URSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URSW::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URSW::COUNTERONLY)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UDIS`"]
        pub enum UDISW {
            #[doc = "Update event enabled"]
            ENABLED,
            #[doc = "Update event disabled"]
            DISABLED,
        }
        impl UDISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UDISW::ENABLED => false,
                    UDISW::DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UDISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UDISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UDISW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Update event enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDISW::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDISW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CEN`"]
        pub enum CENW {
            #[doc = "Counter disabled"]
            DISABLED,
            #[doc = "Counter enabled"]
            ENABLED,
        }
        impl CENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CENW::DISABLED => false,
                    CENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Counter disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CENW::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline]
            pub fn ckd(&self) -> CKDR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CKDR { bits }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline]
            pub fn arpe(&self) -> ARPER {
                ARPER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline]
            pub fn urs(&self) -> URSR {
                URSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline]
            pub fn udis(&self) -> UDISR {
                UDISR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline]
            pub fn cen(&self) -> CENR {
                CENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline]
            pub fn ckd(&mut self) -> _CKDW {
                _CKDW { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline]
            pub fn arpe(&mut self) -> _ARPEW {
                _ARPEW { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline]
            pub fn urs(&mut self) -> _URSW {
                _URSW { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline]
            pub fn udis(&mut self) -> _UDISW {
                _UDISW { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline]
            pub fn cen(&mut self) -> _CENW {
                _CENW { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register"]
    pub struct DIER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1IER {
            bits: bool,
        }
        impl CC1IER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `UIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIER {
            #[doc = "Update interrupt disabled"]
            DISABLED,
            #[doc = "Update interrupt enabled"]
            ENABLED,
        }
        impl UIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UIER::DISABLED => false,
                    UIER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UIER {
                match value {
                    false => UIER::DISABLED,
                    true => UIER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UIER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UIER::ENABLED
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1IEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1IEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UIE`"]
        pub enum UIEW {
            #[doc = "Update interrupt disabled"]
            DISABLED,
            #[doc = "Update interrupt enabled"]
            ENABLED,
        }
        impl UIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UIEW::DISABLED => false,
                    UIEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIEW::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline]
            pub fn cc1ie(&self) -> CC1IER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1IER { bits }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline]
            pub fn uie(&self) -> UIER {
                UIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline]
            pub fn cc1ie(&mut self) -> _CC1IEW {
                _CC1IEW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline]
            pub fn uie(&mut self) -> _UIEW {
                _UIEW { w: self }
            }
        }
    }
    #[doc = "status register"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1OFR {
            bits: bool,
        }
        impl CC1OFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1IFR {
            bits: bool,
        }
        impl CC1IFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `UIF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIFR {
            #[doc = "No update occurred"]
            CLEAR,
            #[doc = "Update interrupt pending."]
            UPDATEPENDING,
        }
        impl UIFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UIFR::CLEAR => false,
                    UIFR::UPDATEPENDING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UIFR {
                match value {
                    false => UIFR::CLEAR,
                    true => UIFR::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline]
            pub fn is_clear(&self) -> bool {
                *self == UIFR::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline]
            pub fn is_update_pending(&self) -> bool {
                *self == UIFR::UPDATEPENDING
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1OFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1OFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1IFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1IFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UIF`"]
        pub enum UIFW {
            #[doc = "No update occurred"]
            CLEAR,
            #[doc = "Update interrupt pending."]
            UPDATEPENDING,
        }
        impl UIFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UIFW::CLEAR => false,
                    UIFW::UPDATEPENDING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UIFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UIFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No update occurred"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIFW::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIFW::UPDATEPENDING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline]
            pub fn cc1of(&self) -> CC1OFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1OFR { bits }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline]
            pub fn cc1if(&self) -> CC1IFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1IFR { bits }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline]
            pub fn uif(&self) -> UIFR {
                UIFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline]
            pub fn cc1of(&mut self) -> _CC1OFW {
                _CC1OFW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline]
            pub fn cc1if(&mut self) -> _CC1IFW {
                _CC1IFW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline]
            pub fn uif(&mut self) -> _UIFW {
                _UIFW { w: self }
            }
        }
    }
    #[doc = "event generation register"]
    pub struct EGR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EGR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1GW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1GW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UG`"]
        pub enum UGW {
            #[doc = "Re-initializes the timer counter and generates an update of the reigsters."]
            UPDATE,
        }
        impl UGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UGW::UPDATE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the reigsters."]
            #[inline]
            pub fn update(self) -> &'a mut W {
                self.variant(UGW::UPDATE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline]
            pub fn cc1g(&mut self) -> _CC1GW {
                _CC1GW { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline]
            pub fn ug(&mut self) -> _UGW {
                _UGW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub struct CCMR1_OUTPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr1_output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCMR1_OUTPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1SR {
            bits: u8,
        }
        impl CC1SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1FER {
            bits: bool,
        }
        impl OC1FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1PER {
            bits: bool,
        }
        impl OC1PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1MR {
            bits: u8,
        }
        impl OC1MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1FEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1FEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1PEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1MW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&self) -> CC1SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC1SR { bits }
            }
            #[doc = "Bit 2 - Output compare 1 fast enable"]
            #[inline]
            pub fn oc1fe(&self) -> OC1FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC1FER { bits }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline]
            pub fn oc1pe(&self) -> OC1PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC1PER { bits }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline]
            pub fn oc1m(&self) -> OC1MR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OC1MR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&mut self) -> _CC1SW {
                _CC1SW { w: self }
            }
            #[doc = "Bit 2 - Output compare 1 fast enable"]
            #[inline]
            pub fn oc1fe(&mut self) -> _OC1FEW {
                _OC1FEW { w: self }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline]
            pub fn oc1pe(&mut self) -> _OC1PEW {
                _OC1PEW { w: self }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline]
            pub fn oc1m(&mut self) -> _OC1MW {
                _OC1MW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (input mode)"]
    pub struct CCMR1_INPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register (input mode)"]
    pub mod ccmr1_input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCMR1_INPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC1FR {
            bits: u8,
        }
        impl IC1FR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC1PSCR {
            bits: u8,
        }
        impl IC1PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1SR {
            bits: u8,
        }
        impl CC1SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC1FW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC1FW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC1PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC1PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline]
            pub fn ic1f(&self) -> IC1FR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC1FR { bits }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline]
            pub fn ic1psc(&self) -> IC1PSCR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC1PSCR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&self) -> CC1SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC1SR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline]
            pub fn ic1f(&mut self) -> _IC1FW {
                _IC1FW { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline]
            pub fn ic1psc(&mut self) -> _IC1PSCW {
                _IC1PSCW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&mut self) -> _CC1SW {
                _CC1SW { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register"]
    pub struct CCER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1NPR {
            bits: bool,
        }
        impl CC1NPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1PR {
            bits: bool,
        }
        impl CC1PR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1ER {
            bits: bool,
        }
        impl CC1ER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1NPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1NPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1PW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1PW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1EW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1EW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1np(&self) -> CC1NPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1NPR { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1p(&self) -> CC1PR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1PR { bits }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline]
            pub fn cc1e(&self) -> CC1ER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1ER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1np(&mut self) -> _CC1NPW {
                _CC1NPW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1p(&mut self) -> _CC1PW {
                _CC1PW { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline]
            pub fn cc1e(&mut self) -> _CC1EW {
                _CC1EW { w: self }
            }
        }
    }
    #[doc = "counter"]
    pub struct CNT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "counter"]
    pub mod cnt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNTR {
            bits: u16,
        }
        impl CNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline]
            pub fn cnt(&self) -> CNTR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline]
            pub fn cnt(&mut self) -> _CNTW {
                _CNTW { w: self }
            }
        }
    }
    #[doc = "prescaler"]
    pub struct PSC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PSCR {
            bits: u16,
        }
        impl PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline]
            pub fn psc(&self) -> PSCR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PSCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline]
            pub fn psc(&mut self) -> _PSCW {
                _PSCW { w: self }
            }
        }
    }
    #[doc = "auto-reload register"]
    pub struct ARR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ARR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ARRR {
            bits: u16,
        }
        impl ARRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ARRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ARRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline]
            pub fn arr(&self) -> ARRR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ARRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline]
            pub fn arr(&mut self) -> _ARRW {
                _ARRW { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1"]
    pub struct CCR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare register 1"]
    pub mod ccr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCR1R {
            bits: u16,
        }
        impl CCR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCR1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline]
            pub fn ccr1(&self) -> CCR1R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CCR1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline]
            pub fn ccr1(&mut self) -> _CCR1W {
                _CCR1W { w: self }
            }
        }
    }
}
#[doc = "TIM14"]
#[cfg(feature = "tim14")]
pub struct TIM14 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "tim14")]
unsafe impl Send for TIM14 {}
#[cfg(feature = "tim14")]
impl TIM14 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const tim13::RegisterBlock {
        0x4000_2000 as *const _
    }
}
#[cfg(feature = "tim14")]
impl Deref for TIM14 {
    type Target = tim13::RegisterBlock;
    fn deref(&self) -> &tim13::RegisterBlock {
        unsafe { &*TIM14::ptr() }
    }
}
#[doc = "Basic timer"]
#[cfg(feature = "tim6")]
pub struct TIM6 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "tim6")]
unsafe impl Send for TIM6 {}
#[cfg(feature = "tim6")]
impl TIM6 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const tim6::RegisterBlock {
        0x4000_1000 as *const _
    }
}
#[cfg(feature = "tim6")]
impl Deref for TIM6 {
    type Target = tim6::RegisterBlock;
    fn deref(&self) -> &tim6::RegisterBlock {
        unsafe { &*TIM6::ptr() }
    }
}
#[doc = "Basic timer"]
#[cfg(feature = "tim6")]
pub mod tim6 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        _reserved0: [u8; 4usize],
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        _reserved1: [u8; 12usize],
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
    }
    #[doc = "control register 1"]
    pub struct CR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ARPE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPER {
            #[doc = "TIMx_APRR register is not buffered"]
            DISABLED,
            #[doc = "TIMx_APRR register is buffered"]
            ENABLED,
        }
        impl ARPER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ARPER::DISABLED => false,
                    ARPER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ARPER {
                match value {
                    false => ARPER::DISABLED,
                    true => ARPER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ARPER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ARPER::ENABLED
            }
        }
        #[doc = "Possible values of the field `OPM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPMR {
            #[doc = "Counter is not stopped at update event"]
            DISABLED,
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            ENABLED,
        }
        impl OPMR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OPMR::DISABLED => false,
                    OPMR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OPMR {
                match value {
                    false => OPMR::DISABLED,
                    true => OPMR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == OPMR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == OPMR::ENABLED
            }
        }
        #[doc = "Possible values of the field `URS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URSR {
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT,
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY,
        }
        impl URSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    URSR::ANYEVENT => false,
                    URSR::COUNTERONLY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> URSR {
                match value {
                    false => URSR::ANYEVENT,
                    true => URSR::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline]
            pub fn is_any_event(&self) -> bool {
                *self == URSR::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline]
            pub fn is_counter_only(&self) -> bool {
                *self == URSR::COUNTERONLY
            }
        }
        #[doc = "Possible values of the field `UDIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDISR {
            #[doc = "Update event enabled"]
            ENABLED,
            #[doc = "Update event disabled"]
            DISABLED,
        }
        impl UDISR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UDISR::ENABLED => false,
                    UDISR::DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UDISR {
                match value {
                    false => UDISR::ENABLED,
                    true => UDISR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UDISR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UDISR::DISABLED
            }
        }
        #[doc = "Possible values of the field `CEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CENR {
            #[doc = "Counter disabled"]
            DISABLED,
            #[doc = "Counter enabled"]
            ENABLED,
        }
        impl CENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CENR::DISABLED => false,
                    CENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CENR {
                match value {
                    false => CENR::DISABLED,
                    true => CENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CENR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ARPE`"]
        pub enum ARPEW {
            #[doc = "TIMx_APRR register is not buffered"]
            DISABLED,
            #[doc = "TIMx_APRR register is buffered"]
            ENABLED,
        }
        impl ARPEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ARPEW::DISABLED => false,
                    ARPEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ARPEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ARPEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ARPEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPEW::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OPM`"]
        pub enum OPMW {
            #[doc = "Counter is not stopped at update event"]
            DISABLED,
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            ENABLED,
        }
        impl OPMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OPMW::DISABLED => false,
                    OPMW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OPMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OPMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OPMW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Counter is not stopped at update event"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OPMW::DISABLED)
            }
            #[doc = "Counter stops counting at the next update event (clearing the CEN bit)"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OPMW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `URS`"]
        pub enum URSW {
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT,
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY,
        }
        impl URSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    URSW::ANYEVENT => false,
                    URSW::COUNTERONLY => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _URSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _URSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: URSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URSW::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URSW::COUNTERONLY)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UDIS`"]
        pub enum UDISW {
            #[doc = "Update event enabled"]
            ENABLED,
            #[doc = "Update event disabled"]
            DISABLED,
        }
        impl UDISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UDISW::ENABLED => false,
                    UDISW::DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UDISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UDISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UDISW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Update event enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDISW::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDISW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CEN`"]
        pub enum CENW {
            #[doc = "Counter disabled"]
            DISABLED,
            #[doc = "Counter enabled"]
            ENABLED,
        }
        impl CENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CENW::DISABLED => false,
                    CENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Counter disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CENW::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline]
            pub fn arpe(&self) -> ARPER {
                ARPER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline]
            pub fn opm(&self) -> OPMR {
                OPMR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline]
            pub fn urs(&self) -> URSR {
                URSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline]
            pub fn udis(&self) -> UDISR {
                UDISR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline]
            pub fn cen(&self) -> CENR {
                CENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline]
            pub fn arpe(&mut self) -> _ARPEW {
                _ARPEW { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline]
            pub fn opm(&mut self) -> _OPMW {
                _OPMW { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline]
            pub fn urs(&mut self) -> _URSW {
                _URSW { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline]
            pub fn udis(&mut self) -> _UDISW {
                _UDISW { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline]
            pub fn cen(&mut self) -> _CENW {
                _CENW { w: self }
            }
        }
    }
    #[doc = "control register 2"]
    pub struct CR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MMS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MMSR {
            #[doc = "Use UG bit from TIMx_EGR register"]
            RESET,
            #[doc = "Use CNT bit from TIMx_CEN register"]
            ENABLE,
            #[doc = "Use the update event"]
            UPDATE,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl MMSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MMSR::RESET => 0,
                    MMSR::ENABLE => 0x01,
                    MMSR::UPDATE => 0x02,
                    MMSR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MMSR {
                match value {
                    0 => MMSR::RESET,
                    1 => MMSR::ENABLE,
                    2 => MMSR::UPDATE,
                    i => MMSR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline]
            pub fn is_reset(&self) -> bool {
                *self == MMSR::RESET
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == MMSR::ENABLE
            }
            #[doc = "Checks if the value of the field is `UPDATE`"]
            #[inline]
            pub fn is_update(&self) -> bool {
                *self == MMSR::UPDATE
            }
        }
        #[doc = "Values that can be written to the field `MMS`"]
        pub enum MMSW {
            #[doc = "Use UG bit from TIMx_EGR register"]
            RESET,
            #[doc = "Use CNT bit from TIMx_CEN register"]
            ENABLE,
            #[doc = "Use the update event"]
            UPDATE,
        }
        impl MMSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MMSW::RESET => 0,
                    MMSW::ENABLE => 1,
                    MMSW::UPDATE => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MMSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MMSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MMSW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Use UG bit from TIMx_EGR register"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(MMSW::RESET)
            }
            #[doc = "Use CNT bit from TIMx_CEN register"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(MMSW::ENABLE)
            }
            #[doc = "Use the update event"]
            #[inline]
            pub fn update(self) -> &'a mut W {
                self.variant(MMSW::UPDATE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline]
            pub fn mms(&self) -> MMSR {
                MMSR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline]
            pub fn mms(&mut self) -> _MMSW {
                _MMSW { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register"]
    pub struct DIER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UDE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDER {
            #[doc = "Update DMA request disabled"]
            DISABLED,
            #[doc = "Update DMA request enabled"]
            ENABLED,
        }
        impl UDER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UDER::DISABLED => false,
                    UDER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UDER {
                match value {
                    false => UDER::DISABLED,
                    true => UDER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UDER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UDER::ENABLED
            }
        }
        #[doc = "Possible values of the field `UIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIER {
            #[doc = "Update interrupt disabled"]
            DISABLED,
            #[doc = "Update interrupt enabled"]
            ENABLED,
        }
        impl UIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UIER::DISABLED => false,
                    UIER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UIER {
                match value {
                    false => UIER::DISABLED,
                    true => UIER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UIER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UIER::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `UDE`"]
        pub enum UDEW {
            #[doc = "Update DMA request disabled"]
            DISABLED,
            #[doc = "Update DMA request enabled"]
            ENABLED,
        }
        impl UDEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UDEW::DISABLED => false,
                    UDEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UDEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UDEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UDEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Update DMA request disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDEW::DISABLED)
            }
            #[doc = "Update DMA request enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UIE`"]
        pub enum UIEW {
            #[doc = "Update interrupt disabled"]
            DISABLED,
            #[doc = "Update interrupt enabled"]
            ENABLED,
        }
        impl UIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UIEW::DISABLED => false,
                    UIEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIEW::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline]
            pub fn ude(&self) -> UDER {
                UDER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline]
            pub fn uie(&self) -> UIER {
                UIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline]
            pub fn ude(&mut self) -> _UDEW {
                _UDEW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline]
            pub fn uie(&mut self) -> _UIEW {
                _UIEW { w: self }
            }
        }
    }
    #[doc = "status register"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UIF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIFR {
            #[doc = "No update occurred"]
            CLEAR,
            #[doc = "Update interrupt pending."]
            UPDATEPENDING,
        }
        impl UIFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UIFR::CLEAR => false,
                    UIFR::UPDATEPENDING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UIFR {
                match value {
                    false => UIFR::CLEAR,
                    true => UIFR::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline]
            pub fn is_clear(&self) -> bool {
                *self == UIFR::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline]
            pub fn is_update_pending(&self) -> bool {
                *self == UIFR::UPDATEPENDING
            }
        }
        #[doc = "Values that can be written to the field `UIF`"]
        pub enum UIFW {
            #[doc = "No update occurred"]
            CLEAR,
            #[doc = "Update interrupt pending."]
            UPDATEPENDING,
        }
        impl UIFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UIFW::CLEAR => false,
                    UIFW::UPDATEPENDING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UIFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UIFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No update occurred"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIFW::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIFW::UPDATEPENDING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline]
            pub fn uif(&self) -> UIFR {
                UIFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline]
            pub fn uif(&mut self) -> _UIFW {
                _UIFW { w: self }
            }
        }
    }
    #[doc = "event generation register"]
    pub struct EGR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EGR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Values that can be written to the field `UG`"]
        pub enum UGW {
            #[doc = "Re-initializes the timer counter and generates an update of the reigsters."]
            UPDATE,
        }
        impl UGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UGW::UPDATE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the reigsters."]
            #[inline]
            pub fn update(self) -> &'a mut W {
                self.variant(UGW::UPDATE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline]
            pub fn ug(&mut self) -> _UGW {
                _UGW { w: self }
            }
        }
    }
    #[doc = "counter"]
    pub struct CNT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "counter"]
    pub mod cnt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNTR {
            bits: u16,
        }
        impl CNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Low counter value"]
            #[inline]
            pub fn cnt(&self) -> CNTR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Low counter value"]
            #[inline]
            pub fn cnt(&mut self) -> _CNTW {
                _CNTW { w: self }
            }
        }
    }
    #[doc = "prescaler"]
    pub struct PSC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PSCR {
            bits: u16,
        }
        impl PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline]
            pub fn psc(&self) -> PSCR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PSCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline]
            pub fn psc(&mut self) -> _PSCW {
                _PSCW { w: self }
            }
        }
    }
    #[doc = "auto-reload register"]
    pub struct ARR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ARR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ARRR {
            bits: u16,
        }
        impl ARRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ARRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ARRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Low Auto-reload value"]
            #[inline]
            pub fn arr(&self) -> ARRR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ARRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Low Auto-reload value"]
            #[inline]
            pub fn arr(&mut self) -> _ARRW {
                _ARRW { w: self }
            }
        }
    }
}
#[doc = "TIM7"]
#[cfg(feature = "tim7")]
pub struct TIM7 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "tim7")]
unsafe impl Send for TIM7 {}
#[cfg(feature = "tim7")]
impl TIM7 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const tim6::RegisterBlock {
        0x4000_1400 as *const _
    }
}
#[cfg(feature = "tim7")]
impl Deref for TIM7 {
    type Target = tim6::RegisterBlock;
    fn deref(&self) -> &tim6::RegisterBlock {
        unsafe { &*TIM7::ptr() }
    }
}
#[doc = "Inter integrated circuit"]
#[cfg(feature = "i2c1")]
pub struct I2C1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "i2c1")]
unsafe impl Send for I2C1 {}
#[cfg(feature = "i2c1")]
impl I2C1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const i2c1::RegisterBlock {
        0x4000_5400 as *const _
    }
}
#[cfg(feature = "i2c1")]
impl Deref for I2C1 {
    type Target = i2c1::RegisterBlock;
    fn deref(&self) -> &i2c1::RegisterBlock {
        unsafe { &*I2C1::ptr() }
    }
}
#[doc = "Inter integrated circuit"]
#[cfg(feature = "i2c1")]
pub mod i2c1 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - Control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - Own address register 1"]
        pub oar1: OAR1,
        #[doc = "0x0c - Own address register 2"]
        pub oar2: OAR2,
        #[doc = "0x10 - Data register"]
        pub dr: DR,
        #[doc = "0x14 - Status register 1"]
        pub sr1: SR1,
        #[doc = "0x18 - Status register 2"]
        pub sr2: SR2,
        #[doc = "0x1c - Clock control register"]
        pub ccr: CCR,
        #[doc = "0x20 - TRISE register"]
        pub trise: TRISE,
    }
    #[doc = "Control register 1"]
    pub struct CR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SWRST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWRSTR {
            #[doc = "I2C peripheral not under reset"]
            NOTRESET,
            #[doc = "I2C peripheral under reset"]
            RESET,
        }
        impl SWRSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SWRSTR::NOTRESET => false,
                    SWRSTR::RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SWRSTR {
                match value {
                    false => SWRSTR::NOTRESET,
                    true => SWRSTR::RESET,
                }
            }
            #[doc = "Checks if the value of the field is `NOTRESET`"]
            #[inline]
            pub fn is_not_reset(&self) -> bool {
                *self == SWRSTR::NOTRESET
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline]
            pub fn is_reset(&self) -> bool {
                *self == SWRSTR::RESET
            }
        }
        #[doc = "Possible values of the field `ALERT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALERTR {
            #[doc = "SMBA pin released high"]
            RELEASE,
            #[doc = "SMBA pin driven low"]
            DRIVE,
        }
        impl ALERTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ALERTR::RELEASE => false,
                    ALERTR::DRIVE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ALERTR {
                match value {
                    false => ALERTR::RELEASE,
                    true => ALERTR::DRIVE,
                }
            }
            #[doc = "Checks if the value of the field is `RELEASE`"]
            #[inline]
            pub fn is_release(&self) -> bool {
                *self == ALERTR::RELEASE
            }
            #[doc = "Checks if the value of the field is `DRIVE`"]
            #[inline]
            pub fn is_drive(&self) -> bool {
                *self == ALERTR::DRIVE
            }
        }
        #[doc = "Possible values of the field `PEC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PECR {
            #[doc = "No PEC transfer"]
            DISABLED,
            #[doc = "PEC transfer"]
            ENABLED,
        }
        impl PECR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PECR::DISABLED => false,
                    PECR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PECR {
                match value {
                    false => PECR::DISABLED,
                    true => PECR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PECR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PECR::ENABLED
            }
        }
        #[doc = "Possible values of the field `POS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POSR {
            #[doc = "ACK bit controls the (N)ACK of the current byte being received"]
            CURRENT,
            #[doc = "ACK bit controls the (N)ACK of the next byte to be received"]
            NEXT,
        }
        impl POSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POSR::CURRENT => false,
                    POSR::NEXT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POSR {
                match value {
                    false => POSR::CURRENT,
                    true => POSR::NEXT,
                }
            }
            #[doc = "Checks if the value of the field is `CURRENT`"]
            #[inline]
            pub fn is_current(&self) -> bool {
                *self == POSR::CURRENT
            }
            #[doc = "Checks if the value of the field is `NEXT`"]
            #[inline]
            pub fn is_next(&self) -> bool {
                *self == POSR::NEXT
            }
        }
        #[doc = "Possible values of the field `ACK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACKR {
            #[doc = "No acknowledge returned"]
            NAK,
            #[doc = "Acknowledge returned after a byte is received"]
            ACK,
        }
        impl ACKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ACKR::NAK => false,
                    ACKR::ACK => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ACKR {
                match value {
                    false => ACKR::NAK,
                    true => ACKR::ACK,
                }
            }
            #[doc = "Checks if the value of the field is `NAK`"]
            #[inline]
            pub fn is_nak(&self) -> bool {
                *self == ACKR::NAK
            }
            #[doc = "Checks if the value of the field is `ACK`"]
            #[inline]
            pub fn is_ack(&self) -> bool {
                *self == ACKR::ACK
            }
        }
        #[doc = "Possible values of the field `STOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOPR {
            #[doc = "No Stop generation"]
            NOSTOP,
            #[doc = "In master mode: stop generation after current byte/start, in slave mode: release SCL and SDA after current byte"]
            STOP,
        }
        impl STOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    STOPR::NOSTOP => false,
                    STOPR::STOP => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> STOPR {
                match value {
                    false => STOPR::NOSTOP,
                    true => STOPR::STOP,
                }
            }
            #[doc = "Checks if the value of the field is `NOSTOP`"]
            #[inline]
            pub fn is_no_stop(&self) -> bool {
                *self == STOPR::NOSTOP
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline]
            pub fn is_stop(&self) -> bool {
                *self == STOPR::STOP
            }
        }
        #[doc = "Possible values of the field `START`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STARTR {
            #[doc = "No Start generation"]
            NOSTART,
            #[doc = "In master mode: repeated start generation, in slave mode: start generation when bus is free"]
            START,
        }
        impl STARTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    STARTR::NOSTART => false,
                    STARTR::START => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> STARTR {
                match value {
                    false => STARTR::NOSTART,
                    true => STARTR::START,
                }
            }
            #[doc = "Checks if the value of the field is `NOSTART`"]
            #[inline]
            pub fn is_no_start(&self) -> bool {
                *self == STARTR::NOSTART
            }
            #[doc = "Checks if the value of the field is `START`"]
            #[inline]
            pub fn is_start(&self) -> bool {
                *self == STARTR::START
            }
        }
        #[doc = "Possible values of the field `NOSTRETCH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NOSTRETCHR {
            #[doc = "Clock stretching enabled"]
            ENABLED,
            #[doc = "Clock stretching disabled"]
            DISABLED,
        }
        impl NOSTRETCHR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    NOSTRETCHR::ENABLED => false,
                    NOSTRETCHR::DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> NOSTRETCHR {
                match value {
                    false => NOSTRETCHR::ENABLED,
                    true => NOSTRETCHR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == NOSTRETCHR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == NOSTRETCHR::DISABLED
            }
        }
        #[doc = "Possible values of the field `ENGC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENGCR {
            #[doc = "General call disabled"]
            DISABLED,
            #[doc = "General call enabled"]
            ENABLED,
        }
        impl ENGCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENGCR::DISABLED => false,
                    ENGCR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENGCR {
                match value {
                    false => ENGCR::DISABLED,
                    true => ENGCR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENGCR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENGCR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ENPEC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENPECR {
            #[doc = "PEC calculation disabled"]
            DISABLED,
            #[doc = "PEC calculation enabled"]
            ENABLED,
        }
        impl ENPECR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENPECR::DISABLED => false,
                    ENPECR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENPECR {
                match value {
                    false => ENPECR::DISABLED,
                    true => ENPECR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENPECR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENPECR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ENARP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENARPR {
            #[doc = "ARP disabled"]
            DISABLED,
            #[doc = "ARP enabled"]
            ENABLED,
        }
        impl ENARPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENARPR::DISABLED => false,
                    ENARPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENARPR {
                match value {
                    false => ENARPR::DISABLED,
                    true => ENARPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENARPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENARPR::ENABLED
            }
        }
        #[doc = "Possible values of the field `SMBTYPE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SMBTYPER {
            #[doc = "SMBus Device"]
            DEVICE,
            #[doc = "SMBus Host"]
            HOST,
        }
        impl SMBTYPER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SMBTYPER::DEVICE => false,
                    SMBTYPER::HOST => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SMBTYPER {
                match value {
                    false => SMBTYPER::DEVICE,
                    true => SMBTYPER::HOST,
                }
            }
            #[doc = "Checks if the value of the field is `DEVICE`"]
            #[inline]
            pub fn is_device(&self) -> bool {
                *self == SMBTYPER::DEVICE
            }
            #[doc = "Checks if the value of the field is `HOST`"]
            #[inline]
            pub fn is_host(&self) -> bool {
                *self == SMBTYPER::HOST
            }
        }
        #[doc = "Possible values of the field `SMBUS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SMBUSR {
            #[doc = "I2C Mode"]
            I2C,
            #[doc = "SMBus"]
            SMBUS,
        }
        impl SMBUSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SMBUSR::I2C => false,
                    SMBUSR::SMBUS => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SMBUSR {
                match value {
                    false => SMBUSR::I2C,
                    true => SMBUSR::SMBUS,
                }
            }
            #[doc = "Checks if the value of the field is `I2C`"]
            #[inline]
            pub fn is_i2c(&self) -> bool {
                *self == SMBUSR::I2C
            }
            #[doc = "Checks if the value of the field is `SMBUS`"]
            #[inline]
            pub fn is_smbus(&self) -> bool {
                *self == SMBUSR::SMBUS
            }
        }
        #[doc = "Possible values of the field `PE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PER {
            #[doc = "Peripheral disabled"]
            DISABLED,
            #[doc = "Peripheral enabled"]
            ENABLED,
        }
        impl PER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PER::DISABLED => false,
                    PER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PER {
                match value {
                    false => PER::DISABLED,
                    true => PER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PER::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `SWRST`"]
        pub enum SWRSTW {
            #[doc = "I2C peripheral not under reset"]
            NOTRESET,
            #[doc = "I2C peripheral under reset"]
            RESET,
        }
        impl SWRSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SWRSTW::NOTRESET => false,
                    SWRSTW::RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SWRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "I2C peripheral not under reset"]
            #[inline]
            pub fn not_reset(self) -> &'a mut W {
                self.variant(SWRSTW::NOTRESET)
            }
            #[doc = "I2C peripheral under reset"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(SWRSTW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ALERT`"]
        pub enum ALERTW {
            #[doc = "SMBA pin released high"]
            RELEASE,
            #[doc = "SMBA pin driven low"]
            DRIVE,
        }
        impl ALERTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ALERTW::RELEASE => false,
                    ALERTW::DRIVE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ALERTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ALERTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ALERTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "SMBA pin released high"]
            #[inline]
            pub fn release(self) -> &'a mut W {
                self.variant(ALERTW::RELEASE)
            }
            #[doc = "SMBA pin driven low"]
            #[inline]
            pub fn drive(self) -> &'a mut W {
                self.variant(ALERTW::DRIVE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PEC`"]
        pub enum PECW {
            #[doc = "No PEC transfer"]
            DISABLED,
            #[doc = "PEC transfer"]
            ENABLED,
        }
        impl PECW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PECW::DISABLED => false,
                    PECW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PECW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PECW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PECW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No PEC transfer"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PECW::DISABLED)
            }
            #[doc = "PEC transfer"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PECW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `POS`"]
        pub enum POSW {
            #[doc = "ACK bit controls the (N)ACK of the current byte being received"]
            CURRENT,
            #[doc = "ACK bit controls the (N)ACK of the next byte to be received"]
            NEXT,
        }
        impl POSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POSW::CURRENT => false,
                    POSW::NEXT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ACK bit controls the (N)ACK of the current byte being received"]
            #[inline]
            pub fn current(self) -> &'a mut W {
                self.variant(POSW::CURRENT)
            }
            #[doc = "ACK bit controls the (N)ACK of the next byte to be received"]
            #[inline]
            pub fn next(self) -> &'a mut W {
                self.variant(POSW::NEXT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACK`"]
        pub enum ACKW {
            #[doc = "No acknowledge returned"]
            NAK,
            #[doc = "Acknowledge returned after a byte is received"]
            ACK,
        }
        impl ACKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACKW::NAK => false,
                    ACKW::ACK => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ACKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No acknowledge returned"]
            #[inline]
            pub fn nak(self) -> &'a mut W {
                self.variant(ACKW::NAK)
            }
            #[doc = "Acknowledge returned after a byte is received"]
            #[inline]
            pub fn ack(self) -> &'a mut W {
                self.variant(ACKW::ACK)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `STOP`"]
        pub enum STOPW {
            #[doc = "No Stop generation"]
            NOSTOP,
            #[doc = "In master mode: stop generation after current byte/start, in slave mode: release SCL and SDA after current byte"]
            STOP,
        }
        impl STOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    STOPW::NOSTOP => false,
                    STOPW::STOP => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: STOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No Stop generation"]
            #[inline]
            pub fn no_stop(self) -> &'a mut W {
                self.variant(STOPW::NOSTOP)
            }
            #[doc = "In master mode: stop generation after current byte/start, in slave mode: release SCL and SDA after current byte"]
            #[inline]
            pub fn stop(self) -> &'a mut W {
                self.variant(STOPW::STOP)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `START`"]
        pub enum STARTW {
            #[doc = "No Start generation"]
            NOSTART,
            #[doc = "In master mode: repeated start generation, in slave mode: start generation when bus is free"]
            START,
        }
        impl STARTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    STARTW::NOSTART => false,
                    STARTW::START => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: STARTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No Start generation"]
            #[inline]
            pub fn no_start(self) -> &'a mut W {
                self.variant(STARTW::NOSTART)
            }
            #[doc = "In master mode: repeated start generation, in slave mode: start generation when bus is free"]
            #[inline]
            pub fn start(self) -> &'a mut W {
                self.variant(STARTW::START)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `NOSTRETCH`"]
        pub enum NOSTRETCHW {
            #[doc = "Clock stretching enabled"]
            ENABLED,
            #[doc = "Clock stretching disabled"]
            DISABLED,
        }
        impl NOSTRETCHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    NOSTRETCHW::ENABLED => false,
                    NOSTRETCHW::DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _NOSTRETCHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NOSTRETCHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: NOSTRETCHW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clock stretching enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(NOSTRETCHW::ENABLED)
            }
            #[doc = "Clock stretching disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(NOSTRETCHW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENGC`"]
        pub enum ENGCW {
            #[doc = "General call disabled"]
            DISABLED,
            #[doc = "General call enabled"]
            ENABLED,
        }
        impl ENGCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENGCW::DISABLED => false,
                    ENGCW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENGCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENGCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENGCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "General call disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENGCW::DISABLED)
            }
            #[doc = "General call enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENGCW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENPEC`"]
        pub enum ENPECW {
            #[doc = "PEC calculation disabled"]
            DISABLED,
            #[doc = "PEC calculation enabled"]
            ENABLED,
        }
        impl ENPECW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENPECW::DISABLED => false,
                    ENPECW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENPECW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENPECW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENPECW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "PEC calculation disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENPECW::DISABLED)
            }
            #[doc = "PEC calculation enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENPECW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENARP`"]
        pub enum ENARPW {
            #[doc = "ARP disabled"]
            DISABLED,
            #[doc = "ARP enabled"]
            ENABLED,
        }
        impl ENARPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENARPW::DISABLED => false,
                    ENARPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENARPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENARPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENARPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ARP disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENARPW::DISABLED)
            }
            #[doc = "ARP enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENARPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SMBTYPE`"]
        pub enum SMBTYPEW {
            #[doc = "SMBus Device"]
            DEVICE,
            #[doc = "SMBus Host"]
            HOST,
        }
        impl SMBTYPEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SMBTYPEW::DEVICE => false,
                    SMBTYPEW::HOST => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMBTYPEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMBTYPEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SMBTYPEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "SMBus Device"]
            #[inline]
            pub fn device(self) -> &'a mut W {
                self.variant(SMBTYPEW::DEVICE)
            }
            #[doc = "SMBus Host"]
            #[inline]
            pub fn host(self) -> &'a mut W {
                self.variant(SMBTYPEW::HOST)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SMBUS`"]
        pub enum SMBUSW {
            #[doc = "I2C Mode"]
            I2C,
            #[doc = "SMBus"]
            SMBUS,
        }
        impl SMBUSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SMBUSW::I2C => false,
                    SMBUSW::SMBUS => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMBUSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMBUSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SMBUSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "I2C Mode"]
            #[inline]
            pub fn i2c(self) -> &'a mut W {
                self.variant(SMBUSW::I2C)
            }
            #[doc = "SMBus"]
            #[inline]
            pub fn smbus(self) -> &'a mut W {
                self.variant(SMBUSW::SMBUS)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PE`"]
        pub enum PEW {
            #[doc = "Peripheral disabled"]
            DISABLED,
            #[doc = "Peripheral enabled"]
            ENABLED,
        }
        impl PEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PEW::DISABLED => false,
                    PEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Peripheral disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PEW::DISABLED)
            }
            #[doc = "Peripheral enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Software reset"]
            #[inline]
            pub fn swrst(&self) -> SWRSTR {
                SWRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - SMBus alert"]
            #[inline]
            pub fn alert(&self) -> ALERTR {
                ALERTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Packet error checking"]
            #[inline]
            pub fn pec(&self) -> PECR {
                PECR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Acknowledge/PEC Position (for data reception)"]
            #[inline]
            pub fn pos(&self) -> POSR {
                POSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Acknowledge enable"]
            #[inline]
            pub fn ack(&self) -> ACKR {
                ACKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Stop generation"]
            #[inline]
            pub fn stop(&self) -> STOPR {
                STOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Start generation"]
            #[inline]
            pub fn start(&self) -> STARTR {
                STARTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Clock stretching disable (Slave mode)"]
            #[inline]
            pub fn nostretch(&self) -> NOSTRETCHR {
                NOSTRETCHR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - General call enable"]
            #[inline]
            pub fn engc(&self) -> ENGCR {
                ENGCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - PEC enable"]
            #[inline]
            pub fn enpec(&self) -> ENPECR {
                ENPECR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - ARP enable"]
            #[inline]
            pub fn enarp(&self) -> ENARPR {
                ENARPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - SMBus type"]
            #[inline]
            pub fn smbtype(&self) -> SMBTYPER {
                SMBTYPER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - SMBus mode"]
            #[inline]
            pub fn smbus(&self) -> SMBUSR {
                SMBUSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 0 - Peripheral enable"]
            #[inline]
            pub fn pe(&self) -> PER {
                PER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Software reset"]
            #[inline]
            pub fn swrst(&mut self) -> _SWRSTW {
                _SWRSTW { w: self }
            }
            #[doc = "Bit 13 - SMBus alert"]
            #[inline]
            pub fn alert(&mut self) -> _ALERTW {
                _ALERTW { w: self }
            }
            #[doc = "Bit 12 - Packet error checking"]
            #[inline]
            pub fn pec(&mut self) -> _PECW {
                _PECW { w: self }
            }
            #[doc = "Bit 11 - Acknowledge/PEC Position (for data reception)"]
            #[inline]
            pub fn pos(&mut self) -> _POSW {
                _POSW { w: self }
            }
            #[doc = "Bit 10 - Acknowledge enable"]
            #[inline]
            pub fn ack(&mut self) -> _ACKW {
                _ACKW { w: self }
            }
            #[doc = "Bit 9 - Stop generation"]
            #[inline]
            pub fn stop(&mut self) -> _STOPW {
                _STOPW { w: self }
            }
            #[doc = "Bit 8 - Start generation"]
            #[inline]
            pub fn start(&mut self) -> _STARTW {
                _STARTW { w: self }
            }
            #[doc = "Bit 7 - Clock stretching disable (Slave mode)"]
            #[inline]
            pub fn nostretch(&mut self) -> _NOSTRETCHW {
                _NOSTRETCHW { w: self }
            }
            #[doc = "Bit 6 - General call enable"]
            #[inline]
            pub fn engc(&mut self) -> _ENGCW {
                _ENGCW { w: self }
            }
            #[doc = "Bit 5 - PEC enable"]
            #[inline]
            pub fn enpec(&mut self) -> _ENPECW {
                _ENPECW { w: self }
            }
            #[doc = "Bit 4 - ARP enable"]
            #[inline]
            pub fn enarp(&mut self) -> _ENARPW {
                _ENARPW { w: self }
            }
            #[doc = "Bit 3 - SMBus type"]
            #[inline]
            pub fn smbtype(&mut self) -> _SMBTYPEW {
                _SMBTYPEW { w: self }
            }
            #[doc = "Bit 1 - SMBus mode"]
            #[inline]
            pub fn smbus(&mut self) -> _SMBUSW {
                _SMBUSW { w: self }
            }
            #[doc = "Bit 0 - Peripheral enable"]
            #[inline]
            pub fn pe(&mut self) -> _PEW {
                _PEW { w: self }
            }
        }
    }
    #[doc = "Control register 2"]
    pub struct CR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `LAST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LASTR {
            #[doc = "Next DMA EOT is not the last transfer"]
            NOTLAST,
            #[doc = "Next DMA EOT is the last transfer"]
            LAST,
        }
        impl LASTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LASTR::NOTLAST => false,
                    LASTR::LAST => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LASTR {
                match value {
                    false => LASTR::NOTLAST,
                    true => LASTR::LAST,
                }
            }
            #[doc = "Checks if the value of the field is `NOTLAST`"]
            #[inline]
            pub fn is_not_last(&self) -> bool {
                *self == LASTR::NOTLAST
            }
            #[doc = "Checks if the value of the field is `LAST`"]
            #[inline]
            pub fn is_last(&self) -> bool {
                *self == LASTR::LAST
            }
        }
        #[doc = "Possible values of the field `DMAEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAENR {
            #[doc = "DMA requests disabled"]
            DISABLED,
            #[doc = "DMA request enabled when TxE=1 or RxNE=1"]
            ENABLED,
        }
        impl DMAENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DMAENR::DISABLED => false,
                    DMAENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DMAENR {
                match value {
                    false => DMAENR::DISABLED,
                    true => DMAENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DMAENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DMAENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ITBUFEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ITBUFENR {
            #[doc = "TxE=1 or RxNE=1 does not generate any interrupt"]
            DISABLED,
            #[doc = "TxE=1 or RxNE=1 generates Event interrupt"]
            ENABLED,
        }
        impl ITBUFENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ITBUFENR::DISABLED => false,
                    ITBUFENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ITBUFENR {
                match value {
                    false => ITBUFENR::DISABLED,
                    true => ITBUFENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ITBUFENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ITBUFENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ITEVTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ITEVTENR {
            #[doc = "Event interrupt disabled"]
            DISABLED,
            #[doc = "Event interrupt enabled"]
            ENABLED,
        }
        impl ITEVTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ITEVTENR::DISABLED => false,
                    ITEVTENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ITEVTENR {
                match value {
                    false => ITEVTENR::DISABLED,
                    true => ITEVTENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ITEVTENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ITEVTENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ITERREN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ITERRENR {
            #[doc = "Error interrupt disabled"]
            DISABLED,
            #[doc = "Error interrupt enabled"]
            ENABLED,
        }
        impl ITERRENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ITERRENR::DISABLED => false,
                    ITERRENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ITERRENR {
                match value {
                    false => ITERRENR::DISABLED,
                    true => ITERRENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ITERRENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ITERRENR::ENABLED
            }
        }
        #[doc = r" Value of the field"]
        pub struct FREQR {
            bits: u8,
        }
        impl FREQR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `LAST`"]
        pub enum LASTW {
            #[doc = "Next DMA EOT is not the last transfer"]
            NOTLAST,
            #[doc = "Next DMA EOT is the last transfer"]
            LAST,
        }
        impl LASTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LASTW::NOTLAST => false,
                    LASTW::LAST => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LASTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LASTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LASTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Next DMA EOT is not the last transfer"]
            #[inline]
            pub fn not_last(self) -> &'a mut W {
                self.variant(LASTW::NOTLAST)
            }
            #[doc = "Next DMA EOT is the last transfer"]
            #[inline]
            pub fn last(self) -> &'a mut W {
                self.variant(LASTW::LAST)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DMAEN`"]
        pub enum DMAENW {
            #[doc = "DMA requests disabled"]
            DISABLED,
            #[doc = "DMA request enabled when TxE=1 or RxNE=1"]
            ENABLED,
        }
        impl DMAENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DMAENW::DISABLED => false,
                    DMAENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMAENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMAENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMAENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "DMA requests disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAENW::DISABLED)
            }
            #[doc = "DMA request enabled when TxE=1 or RxNE=1"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ITBUFEN`"]
        pub enum ITBUFENW {
            #[doc = "TxE=1 or RxNE=1 does not generate any interrupt"]
            DISABLED,
            #[doc = "TxE=1 or RxNE=1 generates Event interrupt"]
            ENABLED,
        }
        impl ITBUFENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ITBUFENW::DISABLED => false,
                    ITBUFENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ITBUFENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ITBUFENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ITBUFENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "TxE=1 or RxNE=1 does not generate any interrupt"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ITBUFENW::DISABLED)
            }
            #[doc = "TxE=1 or RxNE=1 generates Event interrupt"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ITBUFENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ITEVTEN`"]
        pub enum ITEVTENW {
            #[doc = "Event interrupt disabled"]
            DISABLED,
            #[doc = "Event interrupt enabled"]
            ENABLED,
        }
        impl ITEVTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ITEVTENW::DISABLED => false,
                    ITEVTENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ITEVTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ITEVTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ITEVTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Event interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ITEVTENW::DISABLED)
            }
            #[doc = "Event interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ITEVTENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ITERREN`"]
        pub enum ITERRENW {
            #[doc = "Error interrupt disabled"]
            DISABLED,
            #[doc = "Error interrupt enabled"]
            ENABLED,
        }
        impl ITERRENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ITERRENW::DISABLED => false,
                    ITERRENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ITERRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ITERRENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ITERRENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Error interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ITERRENW::DISABLED)
            }
            #[doc = "Error interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ITERRENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FREQW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FREQW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 12 - DMA last transfer"]
            #[inline]
            pub fn last(&self) -> LASTR {
                LASTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - DMA requests enable"]
            #[inline]
            pub fn dmaen(&self) -> DMAENR {
                DMAENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Buffer interrupt enable"]
            #[inline]
            pub fn itbufen(&self) -> ITBUFENR {
                ITBUFENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Event interrupt enable"]
            #[inline]
            pub fn itevten(&self) -> ITEVTENR {
                ITEVTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Error interrupt enable"]
            #[inline]
            pub fn iterren(&self) -> ITERRENR {
                ITERRENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 0:5 - Peripheral clock frequency"]
            #[inline]
            pub fn freq(&self) -> FREQR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FREQR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 12 - DMA last transfer"]
            #[inline]
            pub fn last(&mut self) -> _LASTW {
                _LASTW { w: self }
            }
            #[doc = "Bit 11 - DMA requests enable"]
            #[inline]
            pub fn dmaen(&mut self) -> _DMAENW {
                _DMAENW { w: self }
            }
            #[doc = "Bit 10 - Buffer interrupt enable"]
            #[inline]
            pub fn itbufen(&mut self) -> _ITBUFENW {
                _ITBUFENW { w: self }
            }
            #[doc = "Bit 9 - Event interrupt enable"]
            #[inline]
            pub fn itevten(&mut self) -> _ITEVTENW {
                _ITEVTENW { w: self }
            }
            #[doc = "Bit 8 - Error interrupt enable"]
            #[inline]
            pub fn iterren(&mut self) -> _ITERRENW {
                _ITERRENW { w: self }
            }
            #[doc = "Bits 0:5 - Peripheral clock frequency"]
            #[inline]
            pub fn freq(&mut self) -> _FREQW {
                _FREQW { w: self }
            }
        }
    }
    #[doc = "Own address register 1"]
    pub struct OAR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Own address register 1"]
    pub mod oar1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OAR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ADDMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDMODER {
            #[doc = "7-bit slave address"]
            ADD7,
            #[doc = "10-bit slave address"]
            ADD10,
        }
        impl ADDMODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDMODER::ADD7 => false,
                    ADDMODER::ADD10 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDMODER {
                match value {
                    false => ADDMODER::ADD7,
                    true => ADDMODER::ADD10,
                }
            }
            #[doc = "Checks if the value of the field is `ADD7`"]
            #[inline]
            pub fn is_add7(&self) -> bool {
                *self == ADDMODER::ADD7
            }
            #[doc = "Checks if the value of the field is `ADD10`"]
            #[inline]
            pub fn is_add10(&self) -> bool {
                *self == ADDMODER::ADD10
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDR {
            bits: u16,
        }
        impl ADDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `ADDMODE`"]
        pub enum ADDMODEW {
            #[doc = "7-bit slave address"]
            ADD7,
            #[doc = "10-bit slave address"]
            ADD10,
        }
        impl ADDMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDMODEW::ADD7 => false,
                    ADDMODEW::ADD10 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADDMODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "7-bit slave address"]
            #[inline]
            pub fn add7(self) -> &'a mut W {
                self.variant(ADDMODEW::ADD7)
            }
            #[doc = "10-bit slave address"]
            #[inline]
            pub fn add10(self) -> &'a mut W {
                self.variant(ADDMODEW::ADD10)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x03ff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Addressing mode (slave mode)"]
            #[inline]
            pub fn addmode(&self) -> ADDMODER {
                ADDMODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 0:9 - Interface address"]
            #[inline]
            pub fn add(&self) -> ADDR {
                let bits = {
                    const MASK: u16 = 0x03ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ADDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Addressing mode (slave mode)"]
            #[inline]
            pub fn addmode(&mut self) -> _ADDMODEW {
                _ADDMODEW { w: self }
            }
            #[doc = "Bits 0:9 - Interface address"]
            #[inline]
            pub fn add(&mut self) -> _ADDW {
                _ADDW { w: self }
            }
        }
    }
    #[doc = "Own address register 2"]
    pub struct OAR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Own address register 2"]
    pub mod oar2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OAR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADD2R {
            bits: u8,
        }
        impl ADD2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `ENDUAL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDUALR {
            #[doc = "Single addressing mode"]
            SINGLE,
            #[doc = "Dual addressing mode"]
            DUAL,
        }
        impl ENDUALR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDUALR::SINGLE => false,
                    ENDUALR::DUAL => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDUALR {
                match value {
                    false => ENDUALR::SINGLE,
                    true => ENDUALR::DUAL,
                }
            }
            #[doc = "Checks if the value of the field is `SINGLE`"]
            #[inline]
            pub fn is_single(&self) -> bool {
                *self == ENDUALR::SINGLE
            }
            #[doc = "Checks if the value of the field is `DUAL`"]
            #[inline]
            pub fn is_dual(&self) -> bool {
                *self == ENDUALR::DUAL
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADD2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADD2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x7f;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENDUAL`"]
        pub enum ENDUALW {
            #[doc = "Single addressing mode"]
            SINGLE,
            #[doc = "Dual addressing mode"]
            DUAL,
        }
        impl ENDUALW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDUALW::SINGLE => false,
                    ENDUALW::DUAL => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDUALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDUALW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDUALW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Single addressing mode"]
            #[inline]
            pub fn single(self) -> &'a mut W {
                self.variant(ENDUALW::SINGLE)
            }
            #[doc = "Dual addressing mode"]
            #[inline]
            pub fn dual(self) -> &'a mut W {
                self.variant(ENDUALW::DUAL)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 1:7 - Interface address"]
            #[inline]
            pub fn add2(&self) -> ADD2R {
                let bits = {
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADD2R { bits }
            }
            #[doc = "Bit 0 - Dual addressing mode enable"]
            #[inline]
            pub fn endual(&self) -> ENDUALR {
                ENDUALR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 1:7 - Interface address"]
            #[inline]
            pub fn add2(&mut self) -> _ADD2W {
                _ADD2W { w: self }
            }
            #[doc = "Bit 0 - Dual addressing mode enable"]
            #[inline]
            pub fn endual(&mut self) -> _ENDUALW {
                _ENDUALW { w: self }
            }
        }
    }
    #[doc = "Data register"]
    pub struct DR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Data register"]
    pub mod dr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DRR {
            bits: u8,
        }
        impl DRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - 8-bit data register"]
            #[inline]
            pub fn dr(&self) -> DRR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - 8-bit data register"]
            #[inline]
            pub fn dr(&mut self) -> _DRW {
                _DRW { w: self }
            }
        }
    }
    #[doc = "Status register 1"]
    pub struct SR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Status register 1"]
    pub mod sr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SMBALERT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SMBALERTR {
            #[doc = "No SMBALERT occured"]
            NOALERT,
            #[doc = "SMBALERT occurred"]
            ALERT,
        }
        impl SMBALERTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SMBALERTR::NOALERT => false,
                    SMBALERTR::ALERT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SMBALERTR {
                match value {
                    false => SMBALERTR::NOALERT,
                    true => SMBALERTR::ALERT,
                }
            }
            #[doc = "Checks if the value of the field is `NOALERT`"]
            #[inline]
            pub fn is_no_alert(&self) -> bool {
                *self == SMBALERTR::NOALERT
            }
            #[doc = "Checks if the value of the field is `ALERT`"]
            #[inline]
            pub fn is_alert(&self) -> bool {
                *self == SMBALERTR::ALERT
            }
        }
        #[doc = "Possible values of the field `TIMEOUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIMEOUTR {
            #[doc = "No Timeout error"]
            NOTIMEOUT,
            #[doc = "SCL remained LOW for 25 ms"]
            TIMEOUT,
        }
        impl TIMEOUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TIMEOUTR::NOTIMEOUT => false,
                    TIMEOUTR::TIMEOUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TIMEOUTR {
                match value {
                    false => TIMEOUTR::NOTIMEOUT,
                    true => TIMEOUTR::TIMEOUT,
                }
            }
            #[doc = "Checks if the value of the field is `NOTIMEOUT`"]
            #[inline]
            pub fn is_no_timeout(&self) -> bool {
                *self == TIMEOUTR::NOTIMEOUT
            }
            #[doc = "Checks if the value of the field is `TIMEOUT`"]
            #[inline]
            pub fn is_timeout(&self) -> bool {
                *self == TIMEOUTR::TIMEOUT
            }
        }
        #[doc = "Possible values of the field `PECERR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PECERRR {
            #[doc = "no PEC error: receiver returns ACK after PEC reception (if ACK=1)"]
            NOERROR,
            #[doc = "PEC error: receiver returns NACK after PEC reception (whatever ACK)"]
            ERROR,
        }
        impl PECERRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PECERRR::NOERROR => false,
                    PECERRR::ERROR => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PECERRR {
                match value {
                    false => PECERRR::NOERROR,
                    true => PECERRR::ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline]
            pub fn is_no_error(&self) -> bool {
                *self == PECERRR::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline]
            pub fn is_error(&self) -> bool {
                *self == PECERRR::ERROR
            }
        }
        #[doc = "Possible values of the field `OVR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVRR {
            #[doc = "No overrun/underrun occured"]
            NOOVERRUN,
            #[doc = "Overrun/underrun occured"]
            OVERRUN,
        }
        impl OVRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OVRR::NOOVERRUN => false,
                    OVRR::OVERRUN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OVRR {
                match value {
                    false => OVRR::NOOVERRUN,
                    true => OVRR::OVERRUN,
                }
            }
            #[doc = "Checks if the value of the field is `NOOVERRUN`"]
            #[inline]
            pub fn is_no_overrun(&self) -> bool {
                *self == OVRR::NOOVERRUN
            }
            #[doc = "Checks if the value of the field is `OVERRUN`"]
            #[inline]
            pub fn is_overrun(&self) -> bool {
                *self == OVRR::OVERRUN
            }
        }
        #[doc = "Possible values of the field `AF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AFR {
            #[doc = "No acknowledge failure"]
            NOFAILURE,
            #[doc = "Acknowledge failure"]
            FAILURE,
        }
        impl AFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    AFR::NOFAILURE => false,
                    AFR::FAILURE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> AFR {
                match value {
                    false => AFR::NOFAILURE,
                    true => AFR::FAILURE,
                }
            }
            #[doc = "Checks if the value of the field is `NOFAILURE`"]
            #[inline]
            pub fn is_no_failure(&self) -> bool {
                *self == AFR::NOFAILURE
            }
            #[doc = "Checks if the value of the field is `FAILURE`"]
            #[inline]
            pub fn is_failure(&self) -> bool {
                *self == AFR::FAILURE
            }
        }
        #[doc = "Possible values of the field `ARLO`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARLOR {
            #[doc = "No Arbitration Lost detected"]
            NOLOST,
            #[doc = "Arbitration Lost detected"]
            LOST,
        }
        impl ARLOR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ARLOR::NOLOST => false,
                    ARLOR::LOST => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ARLOR {
                match value {
                    false => ARLOR::NOLOST,
                    true => ARLOR::LOST,
                }
            }
            #[doc = "Checks if the value of the field is `NOLOST`"]
            #[inline]
            pub fn is_no_lost(&self) -> bool {
                *self == ARLOR::NOLOST
            }
            #[doc = "Checks if the value of the field is `LOST`"]
            #[inline]
            pub fn is_lost(&self) -> bool {
                *self == ARLOR::LOST
            }
        }
        #[doc = "Possible values of the field `BERR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BERRR {
            #[doc = "No misplaced Start or Stop condition"]
            NOERROR,
            #[doc = "Misplaced Start or Stop condition"]
            ERROR,
        }
        impl BERRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BERRR::NOERROR => false,
                    BERRR::ERROR => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BERRR {
                match value {
                    false => BERRR::NOERROR,
                    true => BERRR::ERROR,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline]
            pub fn is_no_error(&self) -> bool {
                *self == BERRR::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline]
            pub fn is_error(&self) -> bool {
                *self == BERRR::ERROR
            }
        }
        #[doc = "Possible values of the field `TxE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXER {
            #[doc = "Data register not empty"]
            NOTEMPTY,
            #[doc = "Data register empty"]
            EMPTY,
        }
        impl TXER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TXER::NOTEMPTY => false,
                    TXER::EMPTY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TXER {
                match value {
                    false => TXER::NOTEMPTY,
                    true => TXER::EMPTY,
                }
            }
            #[doc = "Checks if the value of the field is `NOTEMPTY`"]
            #[inline]
            pub fn is_not_empty(&self) -> bool {
                *self == TXER::NOTEMPTY
            }
            #[doc = "Checks if the value of the field is `EMPTY`"]
            #[inline]
            pub fn is_empty(&self) -> bool {
                *self == TXER::EMPTY
            }
        }
        #[doc = "Possible values of the field `RxNE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXNER {
            #[doc = "Data register empty"]
            EMPTY,
            #[doc = "Data register not empty"]
            NOTEMPTY,
        }
        impl RXNER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RXNER::EMPTY => false,
                    RXNER::NOTEMPTY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RXNER {
                match value {
                    false => RXNER::EMPTY,
                    true => RXNER::NOTEMPTY,
                }
            }
            #[doc = "Checks if the value of the field is `EMPTY`"]
            #[inline]
            pub fn is_empty(&self) -> bool {
                *self == RXNER::EMPTY
            }
            #[doc = "Checks if the value of the field is `NOTEMPTY`"]
            #[inline]
            pub fn is_not_empty(&self) -> bool {
                *self == RXNER::NOTEMPTY
            }
        }
        #[doc = "Possible values of the field `STOPF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOPFR {
            #[doc = "No Stop condition detected"]
            NOSTOP,
            #[doc = "Stop condition detected"]
            STOP,
        }
        impl STOPFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    STOPFR::NOSTOP => false,
                    STOPFR::STOP => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> STOPFR {
                match value {
                    false => STOPFR::NOSTOP,
                    true => STOPFR::STOP,
                }
            }
            #[doc = "Checks if the value of the field is `NOSTOP`"]
            #[inline]
            pub fn is_no_stop(&self) -> bool {
                *self == STOPFR::NOSTOP
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline]
            pub fn is_stop(&self) -> bool {
                *self == STOPFR::STOP
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADD10R {
            bits: bool,
        }
        impl ADD10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `BTF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BTFR {
            #[doc = "Data byte transfer not done"]
            NOTFINISHED,
            #[doc = "Data byte transfer successful"]
            FINISHED,
        }
        impl BTFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BTFR::NOTFINISHED => false,
                    BTFR::FINISHED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BTFR {
                match value {
                    false => BTFR::NOTFINISHED,
                    true => BTFR::FINISHED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTFINISHED`"]
            #[inline]
            pub fn is_not_finished(&self) -> bool {
                *self == BTFR::NOTFINISHED
            }
            #[doc = "Checks if the value of the field is `FINISHED`"]
            #[inline]
            pub fn is_finished(&self) -> bool {
                *self == BTFR::FINISHED
            }
        }
        #[doc = "Possible values of the field `ADDR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDRR {
            #[doc = "Adress mismatched or not received"]
            NOTMATCH,
            #[doc = "Received slave address matched with one of the enabled slave addresses"]
            MATCH,
        }
        impl ADDRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDRR::NOTMATCH => false,
                    ADDRR::MATCH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDRR {
                match value {
                    false => ADDRR::NOTMATCH,
                    true => ADDRR::MATCH,
                }
            }
            #[doc = "Checks if the value of the field is `NOTMATCH`"]
            #[inline]
            pub fn is_not_match(&self) -> bool {
                *self == ADDRR::NOTMATCH
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline]
            pub fn is_match_(&self) -> bool {
                *self == ADDRR::MATCH
            }
        }
        #[doc = "Possible values of the field `SB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SBR {
            #[doc = "No Start condition"]
            NOSTART,
            #[doc = "Start condition generated"]
            START,
        }
        impl SBR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SBR::NOSTART => false,
                    SBR::START => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SBR {
                match value {
                    false => SBR::NOSTART,
                    true => SBR::START,
                }
            }
            #[doc = "Checks if the value of the field is `NOSTART`"]
            #[inline]
            pub fn is_no_start(&self) -> bool {
                *self == SBR::NOSTART
            }
            #[doc = "Checks if the value of the field is `START`"]
            #[inline]
            pub fn is_start(&self) -> bool {
                *self == SBR::START
            }
        }
        #[doc = "Values that can be written to the field `SMBALERT`"]
        pub enum SMBALERTW {
            #[doc = "No SMBALERT occured"]
            NOALERT,
            #[doc = "SMBALERT occurred"]
            ALERT,
        }
        impl SMBALERTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SMBALERTW::NOALERT => false,
                    SMBALERTW::ALERT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMBALERTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMBALERTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SMBALERTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No SMBALERT occured"]
            #[inline]
            pub fn no_alert(self) -> &'a mut W {
                self.variant(SMBALERTW::NOALERT)
            }
            #[doc = "SMBALERT occurred"]
            #[inline]
            pub fn alert(self) -> &'a mut W {
                self.variant(SMBALERTW::ALERT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIMEOUT`"]
        pub enum TIMEOUTW {
            #[doc = "No Timeout error"]
            NOTIMEOUT,
            #[doc = "SCL remained LOW for 25 ms"]
            TIMEOUT,
        }
        impl TIMEOUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TIMEOUTW::NOTIMEOUT => false,
                    TIMEOUTW::TIMEOUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMEOUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMEOUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIMEOUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No Timeout error"]
            #[inline]
            pub fn no_timeout(self) -> &'a mut W {
                self.variant(TIMEOUTW::NOTIMEOUT)
            }
            #[doc = "SCL remained LOW for 25 ms"]
            #[inline]
            pub fn timeout(self) -> &'a mut W {
                self.variant(TIMEOUTW::TIMEOUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PECERR`"]
        pub enum PECERRW {
            #[doc = "no PEC error: receiver returns ACK after PEC reception (if ACK=1)"]
            NOERROR,
            #[doc = "PEC error: receiver returns NACK after PEC reception (whatever ACK)"]
            ERROR,
        }
        impl PECERRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PECERRW::NOERROR => false,
                    PECERRW::ERROR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PECERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PECERRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PECERRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "no PEC error: receiver returns ACK after PEC reception (if ACK=1)"]
            #[inline]
            pub fn no_error(self) -> &'a mut W {
                self.variant(PECERRW::NOERROR)
            }
            #[doc = "PEC error: receiver returns NACK after PEC reception (whatever ACK)"]
            #[inline]
            pub fn error(self) -> &'a mut W {
                self.variant(PECERRW::ERROR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OVR`"]
        pub enum OVRW {
            #[doc = "No overrun/underrun occured"]
            NOOVERRUN,
            #[doc = "Overrun/underrun occured"]
            OVERRUN,
        }
        impl OVRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OVRW::NOOVERRUN => false,
                    OVRW::OVERRUN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OVRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No overrun/underrun occured"]
            #[inline]
            pub fn no_overrun(self) -> &'a mut W {
                self.variant(OVRW::NOOVERRUN)
            }
            #[doc = "Overrun/underrun occured"]
            #[inline]
            pub fn overrun(self) -> &'a mut W {
                self.variant(OVRW::OVERRUN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `AF`"]
        pub enum AFW {
            #[doc = "No acknowledge failure"]
            NOFAILURE,
            #[doc = "Acknowledge failure"]
            FAILURE,
        }
        impl AFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    AFW::NOFAILURE => false,
                    AFW::FAILURE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _AFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: AFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No acknowledge failure"]
            #[inline]
            pub fn no_failure(self) -> &'a mut W {
                self.variant(AFW::NOFAILURE)
            }
            #[doc = "Acknowledge failure"]
            #[inline]
            pub fn failure(self) -> &'a mut W {
                self.variant(AFW::FAILURE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ARLO`"]
        pub enum ARLOW {
            #[doc = "No Arbitration Lost detected"]
            NOLOST,
            #[doc = "Arbitration Lost detected"]
            LOST,
        }
        impl ARLOW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ARLOW::NOLOST => false,
                    ARLOW::LOST => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ARLOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ARLOW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ARLOW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No Arbitration Lost detected"]
            #[inline]
            pub fn no_lost(self) -> &'a mut W {
                self.variant(ARLOW::NOLOST)
            }
            #[doc = "Arbitration Lost detected"]
            #[inline]
            pub fn lost(self) -> &'a mut W {
                self.variant(ARLOW::LOST)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BERR`"]
        pub enum BERRW {
            #[doc = "No misplaced Start or Stop condition"]
            NOERROR,
            #[doc = "Misplaced Start or Stop condition"]
            ERROR,
        }
        impl BERRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BERRW::NOERROR => false,
                    BERRW::ERROR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BERRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BERRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No misplaced Start or Stop condition"]
            #[inline]
            pub fn no_error(self) -> &'a mut W {
                self.variant(BERRW::NOERROR)
            }
            #[doc = "Misplaced Start or Stop condition"]
            #[inline]
            pub fn error(self) -> &'a mut W {
                self.variant(BERRW::ERROR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - SMBus alert"]
            #[inline]
            pub fn smbalert(&self) -> SMBALERTR {
                SMBALERTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Timeout or Tlow error"]
            #[inline]
            pub fn timeout(&self) -> TIMEOUTR {
                TIMEOUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - PEC Error in reception"]
            #[inline]
            pub fn pecerr(&self) -> PECERRR {
                PECERRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Overrun/Underrun"]
            #[inline]
            pub fn ovr(&self) -> OVRR {
                OVRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Acknowledge failure"]
            #[inline]
            pub fn af(&self) -> AFR {
                AFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Arbitration lost (master mode)"]
            #[inline]
            pub fn arlo(&self) -> ARLOR {
                ARLOR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Bus error"]
            #[inline]
            pub fn berr(&self) -> BERRR {
                BERRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Data register empty (transmitters)"]
            #[inline]
            pub fn tx_e(&self) -> TXER {
                TXER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Data register not empty (receivers)"]
            #[inline]
            pub fn rx_ne(&self) -> RXNER {
                RXNER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Stop detection (slave mode)"]
            #[inline]
            pub fn stopf(&self) -> STOPFR {
                STOPFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - 10-bit header sent (Master mode)"]
            #[inline]
            pub fn add10(&self) -> ADD10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADD10R { bits }
            }
            #[doc = "Bit 2 - Byte transfer finished"]
            #[inline]
            pub fn btf(&self) -> BTFR {
                BTFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Address sent (master mode)/matched (slave mode)"]
            #[inline]
            pub fn addr(&self) -> ADDRR {
                ADDRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 0 - Start bit (Master mode)"]
            #[inline]
            pub fn sb(&self) -> SBR {
                SBR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - SMBus alert"]
            #[inline]
            pub fn smbalert(&mut self) -> _SMBALERTW {
                _SMBALERTW { w: self }
            }
            #[doc = "Bit 14 - Timeout or Tlow error"]
            #[inline]
            pub fn timeout(&mut self) -> _TIMEOUTW {
                _TIMEOUTW { w: self }
            }
            #[doc = "Bit 12 - PEC Error in reception"]
            #[inline]
            pub fn pecerr(&mut self) -> _PECERRW {
                _PECERRW { w: self }
            }
            #[doc = "Bit 11 - Overrun/Underrun"]
            #[inline]
            pub fn ovr(&mut self) -> _OVRW {
                _OVRW { w: self }
            }
            #[doc = "Bit 10 - Acknowledge failure"]
            #[inline]
            pub fn af(&mut self) -> _AFW {
                _AFW { w: self }
            }
            #[doc = "Bit 9 - Arbitration lost (master mode)"]
            #[inline]
            pub fn arlo(&mut self) -> _ARLOW {
                _ARLOW { w: self }
            }
            #[doc = "Bit 8 - Bus error"]
            #[inline]
            pub fn berr(&mut self) -> _BERRW {
                _BERRW { w: self }
            }
        }
    }
    #[doc = "Status register 2"]
    pub struct SR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Status register 2"]
    pub mod sr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::SR2 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PECR {
            bits: u8,
        }
        impl PECR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DUALFR {
            bits: bool,
        }
        impl DUALFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMBHOSTR {
            bits: bool,
        }
        impl SMBHOSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMBDEFAULTR {
            bits: bool,
        }
        impl SMBDEFAULTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct GENCALLR {
            bits: bool,
        }
        impl GENCALLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TRAR {
            bits: bool,
        }
        impl TRAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSYR {
            bits: bool,
        }
        impl BUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSLR {
            bits: bool,
        }
        impl MSLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:15 - acket error checking register"]
            #[inline]
            pub fn pec(&self) -> PECR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PECR { bits }
            }
            #[doc = "Bit 7 - Dual flag (Slave mode)"]
            #[inline]
            pub fn dualf(&self) -> DUALFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DUALFR { bits }
            }
            #[doc = "Bit 6 - SMBus host header (Slave mode)"]
            #[inline]
            pub fn smbhost(&self) -> SMBHOSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SMBHOSTR { bits }
            }
            #[doc = "Bit 5 - SMBus device default address (Slave mode)"]
            #[inline]
            pub fn smbdefault(&self) -> SMBDEFAULTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SMBDEFAULTR { bits }
            }
            #[doc = "Bit 4 - General call address (Slave mode)"]
            #[inline]
            pub fn gencall(&self) -> GENCALLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                GENCALLR { bits }
            }
            #[doc = "Bit 2 - Transmitter/receiver"]
            #[inline]
            pub fn tra(&self) -> TRAR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TRAR { bits }
            }
            #[doc = "Bit 1 - Bus busy"]
            #[inline]
            pub fn busy(&self) -> BUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSYR { bits }
            }
            #[doc = "Bit 0 - Master/slave"]
            #[inline]
            pub fn msl(&self) -> MSLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MSLR { bits }
            }
        }
    }
    #[doc = "Clock control register"]
    pub struct CCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock control register"]
    pub mod ccr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `F_S`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum F_SR {
            #[doc = "Standard mode I2C"]
            STANDARD,
            #[doc = "Fast mode I2C"]
            FAST,
        }
        impl F_SR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    F_SR::STANDARD => false,
                    F_SR::FAST => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> F_SR {
                match value {
                    false => F_SR::STANDARD,
                    true => F_SR::FAST,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline]
            pub fn is_standard(&self) -> bool {
                *self == F_SR::STANDARD
            }
            #[doc = "Checks if the value of the field is `FAST`"]
            #[inline]
            pub fn is_fast(&self) -> bool {
                *self == F_SR::FAST
            }
        }
        #[doc = "Possible values of the field `DUTY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DUTYR {
            #[doc = "Duty cycle t_low/t_high = 2/1"]
            DUTY2_1,
            #[doc = "Duty cycle t_low/t_high = 16/9"]
            DUTY16_9,
        }
        impl DUTYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DUTYR::DUTY2_1 => false,
                    DUTYR::DUTY16_9 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DUTYR {
                match value {
                    false => DUTYR::DUTY2_1,
                    true => DUTYR::DUTY16_9,
                }
            }
            #[doc = "Checks if the value of the field is `DUTY2_1`"]
            #[inline]
            pub fn is_duty2_1(&self) -> bool {
                *self == DUTYR::DUTY2_1
            }
            #[doc = "Checks if the value of the field is `DUTY16_9`"]
            #[inline]
            pub fn is_duty16_9(&self) -> bool {
                *self == DUTYR::DUTY16_9
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCRR {
            bits: u16,
        }
        impl CCRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `F_S`"]
        pub enum F_SW {
            #[doc = "Standard mode I2C"]
            STANDARD,
            #[doc = "Fast mode I2C"]
            FAST,
        }
        impl F_SW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    F_SW::STANDARD => false,
                    F_SW::FAST => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _F_SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _F_SW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: F_SW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard mode I2C"]
            #[inline]
            pub fn standard(self) -> &'a mut W {
                self.variant(F_SW::STANDARD)
            }
            #[doc = "Fast mode I2C"]
            #[inline]
            pub fn fast(self) -> &'a mut W {
                self.variant(F_SW::FAST)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DUTY`"]
        pub enum DUTYW {
            #[doc = "Duty cycle t_low/t_high = 2/1"]
            DUTY2_1,
            #[doc = "Duty cycle t_low/t_high = 16/9"]
            DUTY16_9,
        }
        impl DUTYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DUTYW::DUTY2_1 => false,
                    DUTYW::DUTY16_9 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DUTYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DUTYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DUTYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Duty cycle t_low/t_high = 2/1"]
            #[inline]
            pub fn duty2_1(self) -> &'a mut W {
                self.variant(DUTYW::DUTY2_1)
            }
            #[doc = "Duty cycle t_low/t_high = 16/9"]
            #[inline]
            pub fn duty16_9(self) -> &'a mut W {
                self.variant(DUTYW::DUTY16_9)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - I2C master mode selection"]
            #[inline]
            pub fn f_s(&self) -> F_SR {
                F_SR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Fast mode duty cycle"]
            #[inline]
            pub fn duty(&self) -> DUTYR {
                DUTYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 0:11 - Clock control register in Fast/Standard mode (Master mode)"]
            #[inline]
            pub fn ccr(&self) -> CCRR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CCRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - I2C master mode selection"]
            #[inline]
            pub fn f_s(&mut self) -> _F_SW {
                _F_SW { w: self }
            }
            #[doc = "Bit 14 - Fast mode duty cycle"]
            #[inline]
            pub fn duty(&mut self) -> _DUTYW {
                _DUTYW { w: self }
            }
            #[doc = "Bits 0:11 - Clock control register in Fast/Standard mode (Master mode)"]
            #[inline]
            pub fn ccr(&mut self) -> _CCRW {
                _CCRW { w: self }
            }
        }
    }
    #[doc = "TRISE register"]
    pub struct TRISE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "TRISE register"]
    pub mod trise {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TRISE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TRISER {
            bits: u8,
        }
        impl TRISER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRISEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRISEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - Maximum rise time in Fast/Standard mode (Master mode)"]
            #[inline]
            pub fn trise(&self) -> TRISER {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TRISER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x02 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - Maximum rise time in Fast/Standard mode (Master mode)"]
            #[inline]
            pub fn trise(&mut self) -> _TRISEW {
                _TRISEW { w: self }
            }
        }
    }
}
#[doc = "I2C2"]
#[cfg(feature = "i2c2")]
pub struct I2C2 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "i2c2")]
unsafe impl Send for I2C2 {}
#[cfg(feature = "i2c2")]
impl I2C2 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const i2c1::RegisterBlock {
        0x4000_5800 as *const _
    }
}
#[cfg(feature = "i2c2")]
impl Deref for I2C2 {
    type Target = i2c1::RegisterBlock;
    fn deref(&self) -> &i2c1::RegisterBlock {
        unsafe { &*I2C2::ptr() }
    }
}
#[doc = "Serial peripheral interface"]
#[cfg(feature = "spi1")]
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "spi1")]
unsafe impl Send for SPI1 {}
#[cfg(feature = "spi1")]
impl SPI1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const spi1::RegisterBlock {
        0x4001_3000 as *const _
    }
}
#[cfg(feature = "spi1")]
impl Deref for SPI1 {
    type Target = spi1::RegisterBlock;
    fn deref(&self) -> &spi1::RegisterBlock {
        unsafe { &*SPI1::ptr() }
    }
}
#[doc = "Serial peripheral interface"]
#[cfg(feature = "spi1")]
pub mod spi1 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - status register"]
        pub sr: SR,
        #[doc = "0x0c - data register"]
        pub dr: DR,
        #[doc = "0x10 - CRC polynomial register"]
        pub crcpr: CRCPR,
        #[doc = "0x14 - RX CRC register"]
        pub rxcrcr: RXCRCR,
        #[doc = "0x18 - TX CRC register"]
        pub txcrcr: TXCRCR,
    }
    #[doc = "control register 1"]
    pub struct CR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct BIDIMODER {
            bits: bool,
        }
        impl BIDIMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BIDIOER {
            bits: bool,
        }
        impl BIDIOER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRCENR {
            bits: bool,
        }
        impl CRCENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRCNEXTR {
            bits: bool,
        }
        impl CRCNEXTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFFR {
            bits: bool,
        }
        impl DFFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXONLYR {
            bits: bool,
        }
        impl RXONLYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SSMR {
            bits: bool,
        }
        impl SSMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SSIR {
            bits: bool,
        }
        impl SSIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LSBFIRSTR {
            bits: bool,
        }
        impl LSBFIRSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPER {
            bits: bool,
        }
        impl SPER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BRR {
            bits: u8,
        }
        impl BRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSTRR {
            bits: bool,
        }
        impl MSTRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CPOLR {
            bits: bool,
        }
        impl CPOLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CPHAR {
            bits: bool,
        }
        impl CPHAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIDIMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIDIMODEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIDIOEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIDIOEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCNEXTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCNEXTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXONLYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXONLYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LSBFIRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LSBFIRSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPOLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPHAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPHAW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Bidirectional data mode enable"]
            #[inline]
            pub fn bidimode(&self) -> BIDIMODER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BIDIMODER { bits }
            }
            #[doc = "Bit 14 - Output enable in bidirectional mode"]
            #[inline]
            pub fn bidioe(&self) -> BIDIOER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BIDIOER { bits }
            }
            #[doc = "Bit 13 - Hardware CRC calculation enable"]
            #[inline]
            pub fn crcen(&self) -> CRCENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CRCENR { bits }
            }
            #[doc = "Bit 12 - CRC transfer next"]
            #[inline]
            pub fn crcnext(&self) -> CRCNEXTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CRCNEXTR { bits }
            }
            #[doc = "Bit 11 - Data frame format"]
            #[inline]
            pub fn dff(&self) -> DFFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFFR { bits }
            }
            #[doc = "Bit 10 - Receive only"]
            #[inline]
            pub fn rxonly(&self) -> RXONLYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXONLYR { bits }
            }
            #[doc = "Bit 9 - Software slave management"]
            #[inline]
            pub fn ssm(&self) -> SSMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SSMR { bits }
            }
            #[doc = "Bit 8 - Internal slave select"]
            #[inline]
            pub fn ssi(&self) -> SSIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SSIR { bits }
            }
            #[doc = "Bit 7 - Frame format"]
            #[inline]
            pub fn lsbfirst(&self) -> LSBFIRSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LSBFIRSTR { bits }
            }
            #[doc = "Bit 6 - SPI enable"]
            #[inline]
            pub fn spe(&self) -> SPER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPER { bits }
            }
            #[doc = "Bits 3:5 - Baud rate control"]
            #[inline]
            pub fn br(&self) -> BRR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BRR { bits }
            }
            #[doc = "Bit 2 - Master selection"]
            #[inline]
            pub fn mstr(&self) -> MSTRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MSTRR { bits }
            }
            #[doc = "Bit 1 - Clock polarity"]
            #[inline]
            pub fn cpol(&self) -> CPOLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CPOLR { bits }
            }
            #[doc = "Bit 0 - Clock phase"]
            #[inline]
            pub fn cpha(&self) -> CPHAR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CPHAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Bidirectional data mode enable"]
            #[inline]
            pub fn bidimode(&mut self) -> _BIDIMODEW {
                _BIDIMODEW { w: self }
            }
            #[doc = "Bit 14 - Output enable in bidirectional mode"]
            #[inline]
            pub fn bidioe(&mut self) -> _BIDIOEW {
                _BIDIOEW { w: self }
            }
            #[doc = "Bit 13 - Hardware CRC calculation enable"]
            #[inline]
            pub fn crcen(&mut self) -> _CRCENW {
                _CRCENW { w: self }
            }
            #[doc = "Bit 12 - CRC transfer next"]
            #[inline]
            pub fn crcnext(&mut self) -> _CRCNEXTW {
                _CRCNEXTW { w: self }
            }
            #[doc = "Bit 11 - Data frame format"]
            #[inline]
            pub fn dff(&mut self) -> _DFFW {
                _DFFW { w: self }
            }
            #[doc = "Bit 10 - Receive only"]
            #[inline]
            pub fn rxonly(&mut self) -> _RXONLYW {
                _RXONLYW { w: self }
            }
            #[doc = "Bit 9 - Software slave management"]
            #[inline]
            pub fn ssm(&mut self) -> _SSMW {
                _SSMW { w: self }
            }
            #[doc = "Bit 8 - Internal slave select"]
            #[inline]
            pub fn ssi(&mut self) -> _SSIW {
                _SSIW { w: self }
            }
            #[doc = "Bit 7 - Frame format"]
            #[inline]
            pub fn lsbfirst(&mut self) -> _LSBFIRSTW {
                _LSBFIRSTW { w: self }
            }
            #[doc = "Bit 6 - SPI enable"]
            #[inline]
            pub fn spe(&mut self) -> _SPEW {
                _SPEW { w: self }
            }
            #[doc = "Bits 3:5 - Baud rate control"]
            #[inline]
            pub fn br(&mut self) -> _BRW {
                _BRW { w: self }
            }
            #[doc = "Bit 2 - Master selection"]
            #[inline]
            pub fn mstr(&mut self) -> _MSTRW {
                _MSTRW { w: self }
            }
            #[doc = "Bit 1 - Clock polarity"]
            #[inline]
            pub fn cpol(&mut self) -> _CPOLW {
                _CPOLW { w: self }
            }
            #[doc = "Bit 0 - Clock phase"]
            #[inline]
            pub fn cpha(&mut self) -> _CPHAW {
                _CPHAW { w: self }
            }
        }
    }
    #[doc = "control register 2"]
    pub struct CR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXEIER {
            bits: bool,
        }
        impl TXEIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXNEIER {
            bits: bool,
        }
        impl RXNEIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERRIER {
            bits: bool,
        }
        impl ERRIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SSOER {
            bits: bool,
        }
        impl SSOER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXDMAENR {
            bits: bool,
        }
        impl TXDMAENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXDMAENR {
            bits: bool,
        }
        impl RXDMAENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXEIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXEIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXNEIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXNEIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSOEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSOEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDMAENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDMAENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXDMAENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXDMAENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 7 - Tx buffer empty interrupt enable"]
            #[inline]
            pub fn txeie(&self) -> TXEIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXEIER { bits }
            }
            #[doc = "Bit 6 - RX buffer not empty interrupt enable"]
            #[inline]
            pub fn rxneie(&self) -> RXNEIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXNEIER { bits }
            }
            #[doc = "Bit 5 - Error interrupt enable"]
            #[inline]
            pub fn errie(&self) -> ERRIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERRIER { bits }
            }
            #[doc = "Bit 2 - SS output enable"]
            #[inline]
            pub fn ssoe(&self) -> SSOER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SSOER { bits }
            }
            #[doc = "Bit 1 - Tx buffer DMA enable"]
            #[inline]
            pub fn txdmaen(&self) -> TXDMAENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXDMAENR { bits }
            }
            #[doc = "Bit 0 - Rx buffer DMA enable"]
            #[inline]
            pub fn rxdmaen(&self) -> RXDMAENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXDMAENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Tx buffer empty interrupt enable"]
            #[inline]
            pub fn txeie(&mut self) -> _TXEIEW {
                _TXEIEW { w: self }
            }
            #[doc = "Bit 6 - RX buffer not empty interrupt enable"]
            #[inline]
            pub fn rxneie(&mut self) -> _RXNEIEW {
                _RXNEIEW { w: self }
            }
            #[doc = "Bit 5 - Error interrupt enable"]
            #[inline]
            pub fn errie(&mut self) -> _ERRIEW {
                _ERRIEW { w: self }
            }
            #[doc = "Bit 2 - SS output enable"]
            #[inline]
            pub fn ssoe(&mut self) -> _SSOEW {
                _SSOEW { w: self }
            }
            #[doc = "Bit 1 - Tx buffer DMA enable"]
            #[inline]
            pub fn txdmaen(&mut self) -> _TXDMAENW {
                _TXDMAENW { w: self }
            }
            #[doc = "Bit 0 - Rx buffer DMA enable"]
            #[inline]
            pub fn rxdmaen(&mut self) -> _RXDMAENW {
                _RXDMAENW { w: self }
            }
        }
    }
    #[doc = "status register"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct BSYR {
            bits: bool,
        }
        impl BSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVRR {
            bits: bool,
        }
        impl OVRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MODFR {
            bits: bool,
        }
        impl MODFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRCERRR {
            bits: bool,
        }
        impl CRCERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXER {
            bits: bool,
        }
        impl TXER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXNER {
            bits: bool,
        }
        impl RXNER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 7 - Busy flag"]
            #[inline]
            pub fn bsy(&self) -> BSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BSYR { bits }
            }
            #[doc = "Bit 6 - Overrun flag"]
            #[inline]
            pub fn ovr(&self) -> OVRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVRR { bits }
            }
            #[doc = "Bit 5 - Mode fault"]
            #[inline]
            pub fn modf(&self) -> MODFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MODFR { bits }
            }
            #[doc = "Bit 4 - CRC error flag"]
            #[inline]
            pub fn crcerr(&self) -> CRCERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CRCERRR { bits }
            }
            #[doc = "Bit 1 - Transmit buffer empty"]
            #[inline]
            pub fn txe(&self) -> TXER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXER { bits }
            }
            #[doc = "Bit 0 - Receive buffer not empty"]
            #[inline]
            pub fn rxne(&self) -> RXNER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXNER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x02 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 4 - CRC error flag"]
            #[inline]
            pub fn crcerr(&mut self) -> _CRCERRW {
                _CRCERRW { w: self }
            }
        }
    }
    #[doc = "data register"]
    pub struct DR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "data register"]
    pub mod dr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DRR {
            bits: u16,
        }
        impl DRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Data register"]
            #[inline]
            pub fn dr(&self) -> DRR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Data register"]
            #[inline]
            pub fn dr(&mut self) -> _DRW {
                _DRW { w: self }
            }
        }
    }
    #[doc = "CRC polynomial register"]
    pub struct CRCPR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CRC polynomial register"]
    pub mod crcpr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CRCPR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRCPOLYR {
            bits: u16,
        }
        impl CRCPOLYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCPOLYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCPOLYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - CRC polynomial register"]
            #[inline]
            pub fn crcpoly(&self) -> CRCPOLYR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CRCPOLYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x07 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - CRC polynomial register"]
            #[inline]
            pub fn crcpoly(&mut self) -> _CRCPOLYW {
                _CRCPOLYW { w: self }
            }
        }
    }
    #[doc = "RX CRC register"]
    pub struct RXCRCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RX CRC register"]
    pub mod rxcrcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RXCRCR {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXCRCR {
            bits: u16,
        }
        impl RXCRCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Rx CRC register"]
            #[inline]
            pub fn rx_crc(&self) -> RXCRCR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RXCRCR { bits }
            }
        }
    }
    #[doc = "TX CRC register"]
    pub struct TXCRCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "TX CRC register"]
    pub mod txcrcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::TXCRCR {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXCRCR {
            bits: u16,
        }
        impl TXCRCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Tx CRC register"]
            #[inline]
            pub fn tx_crc(&self) -> TXCRCR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TXCRCR { bits }
            }
        }
    }
}
#[doc = "SPI2"]
#[cfg(feature = "spi2")]
pub struct SPI2 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "spi2")]
unsafe impl Send for SPI2 {}
#[cfg(feature = "spi2")]
impl SPI2 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const spi1::RegisterBlock {
        0x4000_3800 as *const _
    }
}
#[cfg(feature = "spi2")]
impl Deref for SPI2 {
    type Target = spi1::RegisterBlock;
    fn deref(&self) -> &spi1::RegisterBlock {
        unsafe { &*SPI2::ptr() }
    }
}
#[doc = "SPI3"]
#[cfg(feature = "spi3")]
pub struct SPI3 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "spi3")]
unsafe impl Send for SPI3 {}
#[cfg(feature = "spi3")]
impl SPI3 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const spi1::RegisterBlock {
        0x4000_3c00 as *const _
    }
}
#[cfg(feature = "spi3")]
impl Deref for SPI3 {
    type Target = spi1::RegisterBlock;
    fn deref(&self) -> &spi1::RegisterBlock {
        unsafe { &*SPI3::ptr() }
    }
}
#[doc = "Universal synchronous asynchronous receiver transmitter"]
#[cfg(feature = "usart1")]
pub struct USART1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "usart1")]
unsafe impl Send for USART1 {}
#[cfg(feature = "usart1")]
impl USART1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const usart1::RegisterBlock {
        0x4001_3800 as *const _
    }
}
#[cfg(feature = "usart1")]
impl Deref for USART1 {
    type Target = usart1::RegisterBlock;
    fn deref(&self) -> &usart1::RegisterBlock {
        unsafe { &*USART1::ptr() }
    }
}
#[doc = "Universal synchronous asynchronous receiver transmitter"]
#[cfg(feature = "usart1")]
pub mod usart1 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Status register"]
        pub sr: SR,
        #[doc = "0x04 - Data register"]
        pub dr: DR,
        #[doc = "0x08 - Baud rate register"]
        pub brr: BRR,
        #[doc = "0x0c - Control register 1"]
        pub cr1: CR1,
        #[doc = "0x10 - Control register 2"]
        pub cr2: CR2,
        #[doc = "0x14 - Control register 3"]
        pub cr3: CR3,
        #[doc = "0x18 - Guard time and prescaler register"]
        pub gtpr: GTPR,
    }
    #[doc = "Status register"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTSR {
            bits: bool,
        }
        impl CTSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LBDR {
            bits: bool,
        }
        impl LBDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXER {
            bits: bool,
        }
        impl TXER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCR {
            bits: bool,
        }
        impl TCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXNER {
            bits: bool,
        }
        impl RXNER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDLER {
            bits: bool,
        }
        impl IDLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ORER {
            bits: bool,
        }
        impl ORER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NER {
            bits: bool,
        }
        impl NER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FER {
            bits: bool,
        }
        impl FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PER {
            bits: bool,
        }
        impl PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LBDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LBDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXNEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXNEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 9 - CTS flag"]
            #[inline]
            pub fn cts(&self) -> CTSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CTSR { bits }
            }
            #[doc = "Bit 8 - LIN break detection flag"]
            #[inline]
            pub fn lbd(&self) -> LBDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LBDR { bits }
            }
            #[doc = "Bit 7 - Transmit data register empty"]
            #[inline]
            pub fn txe(&self) -> TXER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXER { bits }
            }
            #[doc = "Bit 6 - Transmission complete"]
            #[inline]
            pub fn tc(&self) -> TCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TCR { bits }
            }
            #[doc = "Bit 5 - Read data register not empty"]
            #[inline]
            pub fn rxne(&self) -> RXNER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXNER { bits }
            }
            #[doc = "Bit 4 - IDLE line detected"]
            #[inline]
            pub fn idle(&self) -> IDLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IDLER { bits }
            }
            #[doc = "Bit 3 - Overrun error"]
            #[inline]
            pub fn ore(&self) -> ORER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ORER { bits }
            }
            #[doc = "Bit 2 - Noise error flag"]
            #[inline]
            pub fn ne(&self) -> NER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NER { bits }
            }
            #[doc = "Bit 1 - Framing error"]
            #[inline]
            pub fn fe(&self) -> FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FER { bits }
            }
            #[doc = "Bit 0 - Parity error"]
            #[inline]
            pub fn pe(&self) -> PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xc0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 9 - CTS flag"]
            #[inline]
            pub fn cts(&mut self) -> _CTSW {
                _CTSW { w: self }
            }
            #[doc = "Bit 8 - LIN break detection flag"]
            #[inline]
            pub fn lbd(&mut self) -> _LBDW {
                _LBDW { w: self }
            }
            #[doc = "Bit 6 - Transmission complete"]
            #[inline]
            pub fn tc(&mut self) -> _TCW {
                _TCW { w: self }
            }
            #[doc = "Bit 5 - Read data register not empty"]
            #[inline]
            pub fn rxne(&mut self) -> _RXNEW {
                _RXNEW { w: self }
            }
        }
    }
    #[doc = "Data register"]
    pub struct DR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Data register"]
    pub mod dr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DRR {
            bits: u16,
        }
        impl DRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x01ff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:8 - Data value"]
            #[inline]
            pub fn dr(&self) -> DRR {
                let bits = {
                    const MASK: u16 = 0x01ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:8 - Data value"]
            #[inline]
            pub fn dr(&mut self) -> _DRW {
                _DRW { w: self }
            }
        }
    }
    #[doc = "Baud rate register"]
    pub struct BRR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Baud rate register"]
    pub mod brr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BRR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIV_MANTISSAR {
            bits: u16,
        }
        impl DIV_MANTISSAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIV_FRACTIONR {
            bits: u8,
        }
        impl DIV_FRACTIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIV_MANTISSAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIV_MANTISSAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIV_FRACTIONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIV_FRACTIONW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:15 - mantissa of USARTDIV"]
            #[inline]
            pub fn div_mantissa(&self) -> DIV_MANTISSAR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DIV_MANTISSAR { bits }
            }
            #[doc = "Bits 0:3 - fraction of USARTDIV"]
            #[inline]
            pub fn div_fraction(&self) -> DIV_FRACTIONR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIV_FRACTIONR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:15 - mantissa of USARTDIV"]
            #[inline]
            pub fn div_mantissa(&mut self) -> _DIV_MANTISSAW {
                _DIV_MANTISSAW { w: self }
            }
            #[doc = "Bits 0:3 - fraction of USARTDIV"]
            #[inline]
            pub fn div_fraction(&mut self) -> _DIV_FRACTIONW {
                _DIV_FRACTIONW { w: self }
            }
        }
    }
    #[doc = "Control register 1"]
    pub struct CR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct UER {
            bits: bool,
        }
        impl UER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR {
            bits: bool,
        }
        impl MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKER {
            bits: bool,
        }
        impl WAKER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PCER {
            bits: bool,
        }
        impl PCER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PSR {
            bits: bool,
        }
        impl PSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PEIER {
            bits: bool,
        }
        impl PEIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXEIER {
            bits: bool,
        }
        impl TXEIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCIER {
            bits: bool,
        }
        impl TCIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXNEIER {
            bits: bool,
        }
        impl RXNEIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDLEIER {
            bits: bool,
        }
        impl IDLEIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TER {
            bits: bool,
        }
        impl TER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RER {
            bits: bool,
        }
        impl RER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RWUR {
            bits: bool,
        }
        impl RWUR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SBKR {
            bits: bool,
        }
        impl SBKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _UEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PCEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PCEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PEIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PEIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXEIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXEIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXNEIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXNEIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDLEIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDLEIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _REW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RWUW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RWUW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SBKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SBKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 13 - USART enable"]
            #[inline]
            pub fn ue(&self) -> UER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                UER { bits }
            }
            #[doc = "Bit 12 - Word length"]
            #[inline]
            pub fn m(&self) -> MR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR { bits }
            }
            #[doc = "Bit 11 - Wakeup method"]
            #[inline]
            pub fn wake(&self) -> WAKER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKER { bits }
            }
            #[doc = "Bit 10 - Parity control enable"]
            #[inline]
            pub fn pce(&self) -> PCER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PCER { bits }
            }
            #[doc = "Bit 9 - Parity selection"]
            #[inline]
            pub fn ps(&self) -> PSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PSR { bits }
            }
            #[doc = "Bit 8 - PE interrupt enable"]
            #[inline]
            pub fn peie(&self) -> PEIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PEIER { bits }
            }
            #[doc = "Bit 7 - TXE interrupt enable"]
            #[inline]
            pub fn txeie(&self) -> TXEIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXEIER { bits }
            }
            #[doc = "Bit 6 - Transmission complete interrupt enable"]
            #[inline]
            pub fn tcie(&self) -> TCIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TCIER { bits }
            }
            #[doc = "Bit 5 - RXNE interrupt enable"]
            #[inline]
            pub fn rxneie(&self) -> RXNEIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXNEIER { bits }
            }
            #[doc = "Bit 4 - IDLE interrupt enable"]
            #[inline]
            pub fn idleie(&self) -> IDLEIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IDLEIER { bits }
            }
            #[doc = "Bit 3 - Transmitter enable"]
            #[inline]
            pub fn te(&self) -> TER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TER { bits }
            }
            #[doc = "Bit 2 - Receiver enable"]
            #[inline]
            pub fn re(&self) -> RER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RER { bits }
            }
            #[doc = "Bit 1 - Receiver wakeup"]
            #[inline]
            pub fn rwu(&self) -> RWUR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RWUR { bits }
            }
            #[doc = "Bit 0 - Send break"]
            #[inline]
            pub fn sbk(&self) -> SBKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SBKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 13 - USART enable"]
            #[inline]
            pub fn ue(&mut self) -> _UEW {
                _UEW { w: self }
            }
            #[doc = "Bit 12 - Word length"]
            #[inline]
            pub fn m(&mut self) -> _MW {
                _MW { w: self }
            }
            #[doc = "Bit 11 - Wakeup method"]
            #[inline]
            pub fn wake(&mut self) -> _WAKEW {
                _WAKEW { w: self }
            }
            #[doc = "Bit 10 - Parity control enable"]
            #[inline]
            pub fn pce(&mut self) -> _PCEW {
                _PCEW { w: self }
            }
            #[doc = "Bit 9 - Parity selection"]
            #[inline]
            pub fn ps(&mut self) -> _PSW {
                _PSW { w: self }
            }
            #[doc = "Bit 8 - PE interrupt enable"]
            #[inline]
            pub fn peie(&mut self) -> _PEIEW {
                _PEIEW { w: self }
            }
            #[doc = "Bit 7 - TXE interrupt enable"]
            #[inline]
            pub fn txeie(&mut self) -> _TXEIEW {
                _TXEIEW { w: self }
            }
            #[doc = "Bit 6 - Transmission complete interrupt enable"]
            #[inline]
            pub fn tcie(&mut self) -> _TCIEW {
                _TCIEW { w: self }
            }
            #[doc = "Bit 5 - RXNE interrupt enable"]
            #[inline]
            pub fn rxneie(&mut self) -> _RXNEIEW {
                _RXNEIEW { w: self }
            }
            #[doc = "Bit 4 - IDLE interrupt enable"]
            #[inline]
            pub fn idleie(&mut self) -> _IDLEIEW {
                _IDLEIEW { w: self }
            }
            #[doc = "Bit 3 - Transmitter enable"]
            #[inline]
            pub fn te(&mut self) -> _TEW {
                _TEW { w: self }
            }
            #[doc = "Bit 2 - Receiver enable"]
            #[inline]
            pub fn re(&mut self) -> _REW {
                _REW { w: self }
            }
            #[doc = "Bit 1 - Receiver wakeup"]
            #[inline]
            pub fn rwu(&mut self) -> _RWUW {
                _RWUW { w: self }
            }
            #[doc = "Bit 0 - Send break"]
            #[inline]
            pub fn sbk(&mut self) -> _SBKW {
                _SBKW { w: self }
            }
        }
    }
    #[doc = "Control register 2"]
    pub struct CR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LINENR {
            bits: bool,
        }
        impl LINENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOPR {
            bits: u8,
        }
        impl STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKENR {
            bits: bool,
        }
        impl CLKENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CPOLR {
            bits: bool,
        }
        impl CPOLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CPHAR {
            bits: bool,
        }
        impl CPHAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LBCLR {
            bits: bool,
        }
        impl LBCLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LBDIER {
            bits: bool,
        }
        impl LBDIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LBDLR {
            bits: bool,
        }
        impl LBDLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDR {
            bits: u8,
        }
        impl ADDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LINENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LINENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPOLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPHAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPHAW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LBCLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LBCLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LBDIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LBDIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LBDLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LBDLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 14 - LIN mode enable"]
            #[inline]
            pub fn linen(&self) -> LINENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LINENR { bits }
            }
            #[doc = "Bits 12:13 - STOP bits"]
            #[inline]
            pub fn stop(&self) -> STOPR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STOPR { bits }
            }
            #[doc = "Bit 11 - Clock enable"]
            #[inline]
            pub fn clken(&self) -> CLKENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLKENR { bits }
            }
            #[doc = "Bit 10 - Clock polarity"]
            #[inline]
            pub fn cpol(&self) -> CPOLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CPOLR { bits }
            }
            #[doc = "Bit 9 - Clock phase"]
            #[inline]
            pub fn cpha(&self) -> CPHAR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CPHAR { bits }
            }
            #[doc = "Bit 8 - Last bit clock pulse"]
            #[inline]
            pub fn lbcl(&self) -> LBCLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LBCLR { bits }
            }
            #[doc = "Bit 6 - LIN break detection interrupt enable"]
            #[inline]
            pub fn lbdie(&self) -> LBDIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LBDIER { bits }
            }
            #[doc = "Bit 5 - lin break detection length"]
            #[inline]
            pub fn lbdl(&self) -> LBDLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LBDLR { bits }
            }
            #[doc = "Bits 0:3 - Address of the USART node"]
            #[inline]
            pub fn add(&self) -> ADDR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 14 - LIN mode enable"]
            #[inline]
            pub fn linen(&mut self) -> _LINENW {
                _LINENW { w: self }
            }
            #[doc = "Bits 12:13 - STOP bits"]
            #[inline]
            pub fn stop(&mut self) -> _STOPW {
                _STOPW { w: self }
            }
            #[doc = "Bit 11 - Clock enable"]
            #[inline]
            pub fn clken(&mut self) -> _CLKENW {
                _CLKENW { w: self }
            }
            #[doc = "Bit 10 - Clock polarity"]
            #[inline]
            pub fn cpol(&mut self) -> _CPOLW {
                _CPOLW { w: self }
            }
            #[doc = "Bit 9 - Clock phase"]
            #[inline]
            pub fn cpha(&mut self) -> _CPHAW {
                _CPHAW { w: self }
            }
            #[doc = "Bit 8 - Last bit clock pulse"]
            #[inline]
            pub fn lbcl(&mut self) -> _LBCLW {
                _LBCLW { w: self }
            }
            #[doc = "Bit 6 - LIN break detection interrupt enable"]
            #[inline]
            pub fn lbdie(&mut self) -> _LBDIEW {
                _LBDIEW { w: self }
            }
            #[doc = "Bit 5 - lin break detection length"]
            #[inline]
            pub fn lbdl(&mut self) -> _LBDLW {
                _LBDLW { w: self }
            }
            #[doc = "Bits 0:3 - Address of the USART node"]
            #[inline]
            pub fn add(&mut self) -> _ADDW {
                _ADDW { w: self }
            }
        }
    }
    #[doc = "Control register 3"]
    pub struct CR3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control register 3"]
    pub mod cr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTSIER {
            bits: bool,
        }
        impl CTSIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTSER {
            bits: bool,
        }
        impl CTSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RTSER {
            bits: bool,
        }
        impl RTSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMATR {
            bits: bool,
        }
        impl DMATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMARR {
            bits: bool,
        }
        impl DMARR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCENR {
            bits: bool,
        }
        impl SCENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NACKR {
            bits: bool,
        }
        impl NACKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HDSELR {
            bits: bool,
        }
        impl HDSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IRLPR {
            bits: bool,
        }
        impl IRLPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IRENR {
            bits: bool,
        }
        impl IRENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EIER {
            bits: bool,
        }
        impl EIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTSIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTSIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTSEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RTSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RTSEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMATW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMARW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMARW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NACKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NACKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HDSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HDSELW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRLPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRLPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 10 - CTS interrupt enable"]
            #[inline]
            pub fn ctsie(&self) -> CTSIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CTSIER { bits }
            }
            #[doc = "Bit 9 - CTS enable"]
            #[inline]
            pub fn ctse(&self) -> CTSER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CTSER { bits }
            }
            #[doc = "Bit 8 - RTS enable"]
            #[inline]
            pub fn rtse(&self) -> RTSER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RTSER { bits }
            }
            #[doc = "Bit 7 - DMA enable transmitter"]
            #[inline]
            pub fn dmat(&self) -> DMATR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DMATR { bits }
            }
            #[doc = "Bit 6 - DMA enable receiver"]
            #[inline]
            pub fn dmar(&self) -> DMARR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DMARR { bits }
            }
            #[doc = "Bit 5 - Smartcard mode enable"]
            #[inline]
            pub fn scen(&self) -> SCENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SCENR { bits }
            }
            #[doc = "Bit 4 - Smartcard NACK enable"]
            #[inline]
            pub fn nack(&self) -> NACKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NACKR { bits }
            }
            #[doc = "Bit 3 - Half-duplex selection"]
            #[inline]
            pub fn hdsel(&self) -> HDSELR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HDSELR { bits }
            }
            #[doc = "Bit 2 - IrDA low-power"]
            #[inline]
            pub fn irlp(&self) -> IRLPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IRLPR { bits }
            }
            #[doc = "Bit 1 - IrDA mode enable"]
            #[inline]
            pub fn iren(&self) -> IRENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IRENR { bits }
            }
            #[doc = "Bit 0 - Error interrupt enable"]
            #[inline]
            pub fn eie(&self) -> EIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EIER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 10 - CTS interrupt enable"]
            #[inline]
            pub fn ctsie(&mut self) -> _CTSIEW {
                _CTSIEW { w: self }
            }
            #[doc = "Bit 9 - CTS enable"]
            #[inline]
            pub fn ctse(&mut self) -> _CTSEW {
                _CTSEW { w: self }
            }
            #[doc = "Bit 8 - RTS enable"]
            #[inline]
            pub fn rtse(&mut self) -> _RTSEW {
                _RTSEW { w: self }
            }
            #[doc = "Bit 7 - DMA enable transmitter"]
            #[inline]
            pub fn dmat(&mut self) -> _DMATW {
                _DMATW { w: self }
            }
            #[doc = "Bit 6 - DMA enable receiver"]
            #[inline]
            pub fn dmar(&mut self) -> _DMARW {
                _DMARW { w: self }
            }
            #[doc = "Bit 5 - Smartcard mode enable"]
            #[inline]
            pub fn scen(&mut self) -> _SCENW {
                _SCENW { w: self }
            }
            #[doc = "Bit 4 - Smartcard NACK enable"]
            #[inline]
            pub fn nack(&mut self) -> _NACKW {
                _NACKW { w: self }
            }
            #[doc = "Bit 3 - Half-duplex selection"]
            #[inline]
            pub fn hdsel(&mut self) -> _HDSELW {
                _HDSELW { w: self }
            }
            #[doc = "Bit 2 - IrDA low-power"]
            #[inline]
            pub fn irlp(&mut self) -> _IRLPW {
                _IRLPW { w: self }
            }
            #[doc = "Bit 1 - IrDA mode enable"]
            #[inline]
            pub fn iren(&mut self) -> _IRENW {
                _IRENW { w: self }
            }
            #[doc = "Bit 0 - Error interrupt enable"]
            #[inline]
            pub fn eie(&mut self) -> _EIEW {
                _EIEW { w: self }
            }
        }
    }
    #[doc = "Guard time and prescaler register"]
    pub struct GTPR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Guard time and prescaler register"]
    pub mod gtpr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::GTPR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct GTR {
            bits: u8,
        }
        impl GTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PSCR {
            bits: u8,
        }
        impl PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _GTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:15 - Guard time value"]
            #[inline]
            pub fn gt(&self) -> GTR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                GTR { bits }
            }
            #[doc = "Bits 0:7 - Prescaler value"]
            #[inline]
            pub fn psc(&self) -> PSCR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PSCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:15 - Guard time value"]
            #[inline]
            pub fn gt(&mut self) -> _GTW {
                _GTW { w: self }
            }
            #[doc = "Bits 0:7 - Prescaler value"]
            #[inline]
            pub fn psc(&mut self) -> _PSCW {
                _PSCW { w: self }
            }
        }
    }
}
#[doc = "USART2"]
#[cfg(feature = "usart2")]
pub struct USART2 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "usart2")]
unsafe impl Send for USART2 {}
#[cfg(feature = "usart2")]
impl USART2 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const usart1::RegisterBlock {
        0x4000_4400 as *const _
    }
}
#[cfg(feature = "usart2")]
impl Deref for USART2 {
    type Target = usart1::RegisterBlock;
    fn deref(&self) -> &usart1::RegisterBlock {
        unsafe { &*USART2::ptr() }
    }
}
#[doc = "USART3"]
#[cfg(feature = "usart3")]
pub struct USART3 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "usart3")]
unsafe impl Send for USART3 {}
#[cfg(feature = "usart3")]
impl USART3 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const usart1::RegisterBlock {
        0x4000_4800 as *const _
    }
}
#[cfg(feature = "usart3")]
impl Deref for USART3 {
    type Target = usart1::RegisterBlock;
    fn deref(&self) -> &usart1::RegisterBlock {
        unsafe { &*USART3::ptr() }
    }
}
#[doc = "Analog to digital converter"]
#[cfg(feature = "adc1")]
pub struct ADC1 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "adc1")]
unsafe impl Send for ADC1 {}
#[cfg(feature = "adc1")]
impl ADC1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const adc1::RegisterBlock {
        0x4001_2400 as *const _
    }
}
#[cfg(feature = "adc1")]
impl Deref for ADC1 {
    type Target = adc1::RegisterBlock;
    fn deref(&self) -> &adc1::RegisterBlock {
        unsafe { &*ADC1::ptr() }
    }
}
#[doc = "Analog to digital converter"]
#[cfg(feature = "adc1")]
pub mod adc1 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - status register"]
        pub sr: SR,
        #[doc = "0x04 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x08 - control register 2"]
        pub cr2: CR2,
        #[doc = "0x0c - sample time register 1"]
        pub smpr1: SMPR1,
        #[doc = "0x10 - sample time register 2"]
        pub smpr2: SMPR2,
        #[doc = "0x14 - injected channel data offset register x"]
        pub jofr1: JOFR1,
        #[doc = "0x18 - injected channel data offset register x"]
        pub jofr2: JOFR2,
        #[doc = "0x1c - injected channel data offset register x"]
        pub jofr3: JOFR3,
        #[doc = "0x20 - injected channel data offset register x"]
        pub jofr4: JOFR4,
        #[doc = "0x24 - watchdog higher threshold register"]
        pub htr: HTR,
        #[doc = "0x28 - watchdog lower threshold register"]
        pub ltr: LTR,
        #[doc = "0x2c - regular sequence register 1"]
        pub sqr1: SQR1,
        #[doc = "0x30 - regular sequence register 2"]
        pub sqr2: SQR2,
        #[doc = "0x34 - regular sequence register 3"]
        pub sqr3: SQR3,
        #[doc = "0x38 - injected sequence register"]
        pub jsqr: JSQR,
        #[doc = "0x3c - injected data register x"]
        pub jdr1: JDR1,
        #[doc = "0x40 - injected data register x"]
        pub jdr2: JDR2,
        #[doc = "0x44 - injected data register x"]
        pub jdr3: JDR3,
        #[doc = "0x48 - injected data register x"]
        pub jdr4: JDR4,
        #[doc = "0x4c - regular data register"]
        pub dr: DR,
    }
    #[doc = "status register"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STRTR {
            bits: bool,
        }
        impl STRTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct JSTRTR {
            bits: bool,
        }
        impl JSTRTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct JEOCR {
            bits: bool,
        }
        impl JEOCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EOCR {
            bits: bool,
        }
        impl EOCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AWDR {
            bits: bool,
        }
        impl AWDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _STRTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STRTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _JSTRTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JSTRTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _JEOCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JEOCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EOCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EOCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AWDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AWDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 4 - Regular channel start flag"]
            #[inline]
            pub fn strt(&self) -> STRTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STRTR { bits }
            }
            #[doc = "Bit 3 - Injected channel start flag"]
            #[inline]
            pub fn jstrt(&self) -> JSTRTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                JSTRTR { bits }
            }
            #[doc = "Bit 2 - Injected channel end of conversion"]
            #[inline]
            pub fn jeoc(&self) -> JEOCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                JEOCR { bits }
            }
            #[doc = "Bit 1 - Regular channel end of conversion"]
            #[inline]
            pub fn eoc(&self) -> EOCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EOCR { bits }
            }
            #[doc = "Bit 0 - Analog watchdog flag"]
            #[inline]
            pub fn awd(&self) -> AWDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AWDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 4 - Regular channel start flag"]
            #[inline]
            pub fn strt(&mut self) -> _STRTW {
                _STRTW { w: self }
            }
            #[doc = "Bit 3 - Injected channel start flag"]
            #[inline]
            pub fn jstrt(&mut self) -> _JSTRTW {
                _JSTRTW { w: self }
            }
            #[doc = "Bit 2 - Injected channel end of conversion"]
            #[inline]
            pub fn jeoc(&mut self) -> _JEOCW {
                _JEOCW { w: self }
            }
            #[doc = "Bit 1 - Regular channel end of conversion"]
            #[inline]
            pub fn eoc(&mut self) -> _EOCW {
                _EOCW { w: self }
            }
            #[doc = "Bit 0 - Analog watchdog flag"]
            #[inline]
            pub fn awd(&mut self) -> _AWDW {
                _AWDW { w: self }
            }
        }
    }
    #[doc = "control register 1"]
    pub struct CR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct AWDENR {
            bits: bool,
        }
        impl AWDENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct JAWDENR {
            bits: bool,
        }
        impl JAWDENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DISCNUMR {
            bits: u8,
        }
        impl DISCNUMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct JDISCENR {
            bits: bool,
        }
        impl JDISCENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DISCENR {
            bits: bool,
        }
        impl DISCENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct JAUTOR {
            bits: bool,
        }
        impl JAUTOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AWDSGLR {
            bits: bool,
        }
        impl AWDSGLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCANR {
            bits: bool,
        }
        impl SCANR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct JEOCIER {
            bits: bool,
        }
        impl JEOCIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AWDIER {
            bits: bool,
        }
        impl AWDIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EOCIER {
            bits: bool,
        }
        impl EOCIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AWDCHR {
            bits: u8,
        }
        impl AWDCHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _AWDENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AWDENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _JAWDENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JAWDENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DISCNUMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DISCNUMW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _JDISCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JDISCENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DISCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DISCENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _JAUTOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JAUTOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AWDSGLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AWDSGLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCANW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCANW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _JEOCIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JEOCIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AWDIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AWDIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EOCIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EOCIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AWDCHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AWDCHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 23 - Analog watchdog enable on regular channels"]
            #[inline]
            pub fn awden(&self) -> AWDENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AWDENR { bits }
            }
            #[doc = "Bit 22 - Analog watchdog enable on injected channels"]
            #[inline]
            pub fn jawden(&self) -> JAWDENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                JAWDENR { bits }
            }
            #[doc = "Bits 13:15 - Discontinuous mode channel count"]
            #[inline]
            pub fn discnum(&self) -> DISCNUMR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DISCNUMR { bits }
            }
            #[doc = "Bit 12 - Discontinuous mode on injected channels"]
            #[inline]
            pub fn jdiscen(&self) -> JDISCENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                JDISCENR { bits }
            }
            #[doc = "Bit 11 - Discontinuous mode on regular channels"]
            #[inline]
            pub fn discen(&self) -> DISCENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DISCENR { bits }
            }
            #[doc = "Bit 10 - Automatic injected group conversion"]
            #[inline]
            pub fn jauto(&self) -> JAUTOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                JAUTOR { bits }
            }
            #[doc = "Bit 9 - Enable the watchdog on a single channel in scan mode"]
            #[inline]
            pub fn awdsgl(&self) -> AWDSGLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AWDSGLR { bits }
            }
            #[doc = "Bit 8 - Scan mode"]
            #[inline]
            pub fn scan(&self) -> SCANR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SCANR { bits }
            }
            #[doc = "Bit 7 - Interrupt enable for injected channels"]
            #[inline]
            pub fn jeocie(&self) -> JEOCIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                JEOCIER { bits }
            }
            #[doc = "Bit 6 - Analog watchdog interrupt enable"]
            #[inline]
            pub fn awdie(&self) -> AWDIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AWDIER { bits }
            }
            #[doc = "Bit 5 - Interrupt enable for EOC"]
            #[inline]
            pub fn eocie(&self) -> EOCIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EOCIER { bits }
            }
            #[doc = "Bits 0:4 - Analog watchdog channel select bits"]
            #[inline]
            pub fn awdch(&self) -> AWDCHR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AWDCHR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 23 - Analog watchdog enable on regular channels"]
            #[inline]
            pub fn awden(&mut self) -> _AWDENW {
                _AWDENW { w: self }
            }
            #[doc = "Bit 22 - Analog watchdog enable on injected channels"]
            #[inline]
            pub fn jawden(&mut self) -> _JAWDENW {
                _JAWDENW { w: self }
            }
            #[doc = "Bits 13:15 - Discontinuous mode channel count"]
            #[inline]
            pub fn discnum(&mut self) -> _DISCNUMW {
                _DISCNUMW { w: self }
            }
            #[doc = "Bit 12 - Discontinuous mode on injected channels"]
            #[inline]
            pub fn jdiscen(&mut self) -> _JDISCENW {
                _JDISCENW { w: self }
            }
            #[doc = "Bit 11 - Discontinuous mode on regular channels"]
            #[inline]
            pub fn discen(&mut self) -> _DISCENW {
                _DISCENW { w: self }
            }
            #[doc = "Bit 10 - Automatic injected group conversion"]
            #[inline]
            pub fn jauto(&mut self) -> _JAUTOW {
                _JAUTOW { w: self }
            }
            #[doc = "Bit 9 - Enable the watchdog on a single channel in scan mode"]
            #[inline]
            pub fn awdsgl(&mut self) -> _AWDSGLW {
                _AWDSGLW { w: self }
            }
            #[doc = "Bit 8 - Scan mode"]
            #[inline]
            pub fn scan(&mut self) -> _SCANW {
                _SCANW { w: self }
            }
            #[doc = "Bit 7 - Interrupt enable for injected channels"]
            #[inline]
            pub fn jeocie(&mut self) -> _JEOCIEW {
                _JEOCIEW { w: self }
            }
            #[doc = "Bit 6 - Analog watchdog interrupt enable"]
            #[inline]
            pub fn awdie(&mut self) -> _AWDIEW {
                _AWDIEW { w: self }
            }
            #[doc = "Bit 5 - Interrupt enable for EOC"]
            #[inline]
            pub fn eocie(&mut self) -> _EOCIEW {
                _EOCIEW { w: self }
            }
            #[doc = "Bits 0:4 - Analog watchdog channel select bits"]
            #[inline]
            pub fn awdch(&mut self) -> _AWDCHW {
                _AWDCHW { w: self }
            }
        }
    }
    #[doc = "control register 2"]
    pub struct CR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TSVREFER {
            bits: bool,
        }
        impl TSVREFER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SWSTARTR {
            bits: bool,
        }
        impl SWSTARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct JSWSTARTR {
            bits: bool,
        }
        impl JSWSTARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTTRIGR {
            bits: bool,
        }
        impl EXTTRIGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EXTSELR {
            bits: u8,
        }
        impl EXTSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct JEXTTRIGR {
            bits: bool,
        }
        impl JEXTTRIGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct JEXTSELR {
            bits: u8,
        }
        impl JEXTSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ALIGNR {
            bits: bool,
        }
        impl ALIGNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMAR {
            bits: bool,
        }
        impl DMAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RSTCALR {
            bits: bool,
        }
        impl RSTCALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CALR {
            bits: bool,
        }
        impl CALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CONTR {
            bits: bool,
        }
        impl CONTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADONR {
            bits: bool,
        }
        impl ADONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _TSVREFEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TSVREFEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWSTARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWSTARTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _JSWSTARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JSWSTARTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTTRIGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTTRIGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _JEXTTRIGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JEXTTRIGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _JEXTSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JEXTSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ALIGNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ALIGNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMAW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSTCALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSTCALW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CALW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CONTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CONTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADONW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 23 - Temperature sensor and VREFINT enable"]
            #[inline]
            pub fn tsvrefe(&self) -> TSVREFER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TSVREFER { bits }
            }
            #[doc = "Bit 22 - Start conversion of regular channels"]
            #[inline]
            pub fn swstart(&self) -> SWSTARTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SWSTARTR { bits }
            }
            #[doc = "Bit 21 - Start conversion of injected channels"]
            #[inline]
            pub fn jswstart(&self) -> JSWSTARTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                JSWSTARTR { bits }
            }
            #[doc = "Bit 20 - External trigger conversion mode for regular channels"]
            #[inline]
            pub fn exttrig(&self) -> EXTTRIGR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EXTTRIGR { bits }
            }
            #[doc = "Bits 17:19 - External event select for regular group"]
            #[inline]
            pub fn extsel(&self) -> EXTSELR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EXTSELR { bits }
            }
            #[doc = "Bit 15 - External trigger conversion mode for injected channels"]
            #[inline]
            pub fn jexttrig(&self) -> JEXTTRIGR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                JEXTTRIGR { bits }
            }
            #[doc = "Bits 12:14 - External event select for injected group"]
            #[inline]
            pub fn jextsel(&self) -> JEXTSELR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JEXTSELR { bits }
            }
            #[doc = "Bit 11 - Data alignment"]
            #[inline]
            pub fn align(&self) -> ALIGNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ALIGNR { bits }
            }
            #[doc = "Bit 8 - Direct memory access mode"]
            #[inline]
            pub fn dma(&self) -> DMAR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DMAR { bits }
            }
            #[doc = "Bit 3 - Reset calibration"]
            #[inline]
            pub fn rstcal(&self) -> RSTCALR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RSTCALR { bits }
            }
            #[doc = "Bit 2 - A/D calibration"]
            #[inline]
            pub fn cal(&self) -> CALR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CALR { bits }
            }
            #[doc = "Bit 1 - Continuous conversion"]
            #[inline]
            pub fn cont(&self) -> CONTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CONTR { bits }
            }
            #[doc = "Bit 0 - A/D converter ON / OFF"]
            #[inline]
            pub fn adon(&self) -> ADONR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADONR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 23 - Temperature sensor and VREFINT enable"]
            #[inline]
            pub fn tsvrefe(&mut self) -> _TSVREFEW {
                _TSVREFEW { w: self }
            }
            #[doc = "Bit 22 - Start conversion of regular channels"]
            #[inline]
            pub fn swstart(&mut self) -> _SWSTARTW {
                _SWSTARTW { w: self }
            }
            #[doc = "Bit 21 - Start conversion of injected channels"]
            #[inline]
            pub fn jswstart(&mut self) -> _JSWSTARTW {
                _JSWSTARTW { w: self }
            }
            #[doc = "Bit 20 - External trigger conversion mode for regular channels"]
            #[inline]
            pub fn exttrig(&mut self) -> _EXTTRIGW {
                _EXTTRIGW { w: self }
            }
            #[doc = "Bits 17:19 - External event select for regular group"]
            #[inline]
            pub fn extsel(&mut self) -> _EXTSELW {
                _EXTSELW { w: self }
            }
            #[doc = "Bit 15 - External trigger conversion mode for injected channels"]
            #[inline]
            pub fn jexttrig(&mut self) -> _JEXTTRIGW {
                _JEXTTRIGW { w: self }
            }
            #[doc = "Bits 12:14 - External event select for injected group"]
            #[inline]
            pub fn jextsel(&mut self) -> _JEXTSELW {
                _JEXTSELW { w: self }
            }
            #[doc = "Bit 11 - Data alignment"]
            #[inline]
            pub fn align(&mut self) -> _ALIGNW {
                _ALIGNW { w: self }
            }
            #[doc = "Bit 8 - Direct memory access mode"]
            #[inline]
            pub fn dma(&mut self) -> _DMAW {
                _DMAW { w: self }
            }
            #[doc = "Bit 3 - Reset calibration"]
            #[inline]
            pub fn rstcal(&mut self) -> _RSTCALW {
                _RSTCALW { w: self }
            }
            #[doc = "Bit 2 - A/D calibration"]
            #[inline]
            pub fn cal(&mut self) -> _CALW {
                _CALW { w: self }
            }
            #[doc = "Bit 1 - Continuous conversion"]
            #[inline]
            pub fn cont(&mut self) -> _CONTW {
                _CONTW { w: self }
            }
            #[doc = "Bit 0 - A/D converter ON / OFF"]
            #[inline]
            pub fn adon(&mut self) -> _ADONW {
                _ADONW { w: self }
            }
        }
    }
    #[doc = "sample time register 1"]
    pub struct SMPR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "sample time register 1"]
    pub mod smpr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SMPR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP10R {
            bits: u8,
        }
        impl SMP10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP11R {
            bits: u8,
        }
        impl SMP11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP12R {
            bits: u8,
        }
        impl SMP12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP13R {
            bits: u8,
        }
        impl SMP13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP14R {
            bits: u8,
        }
        impl SMP14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP15R {
            bits: u8,
        }
        impl SMP15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP16R {
            bits: u8,
        }
        impl SMP16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP17R {
            bits: u8,
        }
        impl SMP17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP16W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP17W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Channel 10 sample time selection"]
            #[inline]
            pub fn smp10(&self) -> SMP10R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP10R { bits }
            }
            #[doc = "Bits 3:5 - Channel 11 sample time selection"]
            #[inline]
            pub fn smp11(&self) -> SMP11R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP11R { bits }
            }
            #[doc = "Bits 6:8 - Channel 12 sample time selection"]
            #[inline]
            pub fn smp12(&self) -> SMP12R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP12R { bits }
            }
            #[doc = "Bits 9:11 - Channel 13 sample time selection"]
            #[inline]
            pub fn smp13(&self) -> SMP13R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP13R { bits }
            }
            #[doc = "Bits 12:14 - Channel 14 sample time selection"]
            #[inline]
            pub fn smp14(&self) -> SMP14R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP14R { bits }
            }
            #[doc = "Bits 15:17 - Channel 15 sample time selection"]
            #[inline]
            pub fn smp15(&self) -> SMP15R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP15R { bits }
            }
            #[doc = "Bits 18:20 - Channel 16 sample time selection"]
            #[inline]
            pub fn smp16(&self) -> SMP16R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP16R { bits }
            }
            #[doc = "Bits 21:23 - Channel 17 sample time selection"]
            #[inline]
            pub fn smp17(&self) -> SMP17R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP17R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Channel 10 sample time selection"]
            #[inline]
            pub fn smp10(&mut self) -> _SMP10W {
                _SMP10W { w: self }
            }
            #[doc = "Bits 3:5 - Channel 11 sample time selection"]
            #[inline]
            pub fn smp11(&mut self) -> _SMP11W {
                _SMP11W { w: self }
            }
            #[doc = "Bits 6:8 - Channel 12 sample time selection"]
            #[inline]
            pub fn smp12(&mut self) -> _SMP12W {
                _SMP12W { w: self }
            }
            #[doc = "Bits 9:11 - Channel 13 sample time selection"]
            #[inline]
            pub fn smp13(&mut self) -> _SMP13W {
                _SMP13W { w: self }
            }
            #[doc = "Bits 12:14 - Channel 14 sample time selection"]
            #[inline]
            pub fn smp14(&mut self) -> _SMP14W {
                _SMP14W { w: self }
            }
            #[doc = "Bits 15:17 - Channel 15 sample time selection"]
            #[inline]
            pub fn smp15(&mut self) -> _SMP15W {
                _SMP15W { w: self }
            }
            #[doc = "Bits 18:20 - Channel 16 sample time selection"]
            #[inline]
            pub fn smp16(&mut self) -> _SMP16W {
                _SMP16W { w: self }
            }
            #[doc = "Bits 21:23 - Channel 17 sample time selection"]
            #[inline]
            pub fn smp17(&mut self) -> _SMP17W {
                _SMP17W { w: self }
            }
        }
    }
    #[doc = "sample time register 2"]
    pub struct SMPR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "sample time register 2"]
    pub mod smpr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SMPR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP0R {
            bits: u8,
        }
        impl SMP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP1R {
            bits: u8,
        }
        impl SMP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP2R {
            bits: u8,
        }
        impl SMP2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP3R {
            bits: u8,
        }
        impl SMP3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP4R {
            bits: u8,
        }
        impl SMP4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP5R {
            bits: u8,
        }
        impl SMP5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP6R {
            bits: u8,
        }
        impl SMP6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP7R {
            bits: u8,
        }
        impl SMP7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP8R {
            bits: u8,
        }
        impl SMP8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMP9R {
            bits: u8,
        }
        impl SMP9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMP9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMP9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Channel 0 sample time selection"]
            #[inline]
            pub fn smp0(&self) -> SMP0R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP0R { bits }
            }
            #[doc = "Bits 3:5 - Channel 1 sample time selection"]
            #[inline]
            pub fn smp1(&self) -> SMP1R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP1R { bits }
            }
            #[doc = "Bits 6:8 - Channel 2 sample time selection"]
            #[inline]
            pub fn smp2(&self) -> SMP2R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP2R { bits }
            }
            #[doc = "Bits 9:11 - Channel 3 sample time selection"]
            #[inline]
            pub fn smp3(&self) -> SMP3R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP3R { bits }
            }
            #[doc = "Bits 12:14 - Channel 4 sample time selection"]
            #[inline]
            pub fn smp4(&self) -> SMP4R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP4R { bits }
            }
            #[doc = "Bits 15:17 - Channel 5 sample time selection"]
            #[inline]
            pub fn smp5(&self) -> SMP5R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP5R { bits }
            }
            #[doc = "Bits 18:20 - Channel 6 sample time selection"]
            #[inline]
            pub fn smp6(&self) -> SMP6R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP6R { bits }
            }
            #[doc = "Bits 21:23 - Channel 7 sample time selection"]
            #[inline]
            pub fn smp7(&self) -> SMP7R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP7R { bits }
            }
            #[doc = "Bits 24:26 - Channel 8 sample time selection"]
            #[inline]
            pub fn smp8(&self) -> SMP8R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP8R { bits }
            }
            #[doc = "Bits 27:29 - Channel 9 sample time selection"]
            #[inline]
            pub fn smp9(&self) -> SMP9R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMP9R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Channel 0 sample time selection"]
            #[inline]
            pub fn smp0(&mut self) -> _SMP0W {
                _SMP0W { w: self }
            }
            #[doc = "Bits 3:5 - Channel 1 sample time selection"]
            #[inline]
            pub fn smp1(&mut self) -> _SMP1W {
                _SMP1W { w: self }
            }
            #[doc = "Bits 6:8 - Channel 2 sample time selection"]
            #[inline]
            pub fn smp2(&mut self) -> _SMP2W {
                _SMP2W { w: self }
            }
            #[doc = "Bits 9:11 - Channel 3 sample time selection"]
            #[inline]
            pub fn smp3(&mut self) -> _SMP3W {
                _SMP3W { w: self }
            }
            #[doc = "Bits 12:14 - Channel 4 sample time selection"]
            #[inline]
            pub fn smp4(&mut self) -> _SMP4W {
                _SMP4W { w: self }
            }
            #[doc = "Bits 15:17 - Channel 5 sample time selection"]
            #[inline]
            pub fn smp5(&mut self) -> _SMP5W {
                _SMP5W { w: self }
            }
            #[doc = "Bits 18:20 - Channel 6 sample time selection"]
            #[inline]
            pub fn smp6(&mut self) -> _SMP6W {
                _SMP6W { w: self }
            }
            #[doc = "Bits 21:23 - Channel 7 sample time selection"]
            #[inline]
            pub fn smp7(&mut self) -> _SMP7W {
                _SMP7W { w: self }
            }
            #[doc = "Bits 24:26 - Channel 8 sample time selection"]
            #[inline]
            pub fn smp8(&mut self) -> _SMP8W {
                _SMP8W { w: self }
            }
            #[doc = "Bits 27:29 - Channel 9 sample time selection"]
            #[inline]
            pub fn smp9(&mut self) -> _SMP9W {
                _SMP9W { w: self }
            }
        }
    }
    #[doc = "injected channel data offset register x"]
    pub struct JOFR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "injected channel data offset register x"]
    pub mod jofr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::JOFR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct JOFFSET1R {
            bits: u16,
        }
        impl JOFFSET1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _JOFFSET1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _JOFFSET1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - Data offset for injected channel 1"]
            #[inline]
            pub fn joffset1(&self) -> JOFFSET1R {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                JOFFSET1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Data offset for injected channel 1"]
            #[inline]
            pub fn joffset1(&mut self) -> _JOFFSET1W {
                _JOFFSET1W { w: self }
            }
        }
    }
    #[doc = "injected channel data offset register x"]
    pub struct JOFR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "injected channel data offset register x"]
    pub mod jofr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::JOFR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct JOFFSET2R {
            bits: u16,
        }
        impl JOFFSET2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _JOFFSET2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _JOFFSET2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - Data offset for injected channel 2"]
            #[inline]
            pub fn joffset2(&self) -> JOFFSET2R {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                JOFFSET2R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Data offset for injected channel 2"]
            #[inline]
            pub fn joffset2(&mut self) -> _JOFFSET2W {
                _JOFFSET2W { w: self }
            }
        }
    }
    #[doc = "injected channel data offset register x"]
    pub struct JOFR3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "injected channel data offset register x"]
    pub mod jofr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::JOFR3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct JOFFSET3R {
            bits: u16,
        }
        impl JOFFSET3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _JOFFSET3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _JOFFSET3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - Data offset for injected channel 3"]
            #[inline]
            pub fn joffset3(&self) -> JOFFSET3R {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                JOFFSET3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Data offset for injected channel 3"]
            #[inline]
            pub fn joffset3(&mut self) -> _JOFFSET3W {
                _JOFFSET3W { w: self }
            }
        }
    }
    #[doc = "injected channel data offset register x"]
    pub struct JOFR4 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "injected channel data offset register x"]
    pub mod jofr4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::JOFR4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct JOFFSET4R {
            bits: u16,
        }
        impl JOFFSET4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _JOFFSET4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _JOFFSET4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - Data offset for injected channel 4"]
            #[inline]
            pub fn joffset4(&self) -> JOFFSET4R {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                JOFFSET4R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Data offset for injected channel 4"]
            #[inline]
            pub fn joffset4(&mut self) -> _JOFFSET4W {
                _JOFFSET4W { w: self }
            }
        }
    }
    #[doc = "watchdog higher threshold register"]
    pub struct HTR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "watchdog higher threshold register"]
    pub mod htr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::HTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct HTR {
            bits: u16,
        }
        impl HTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _HTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - Analog watchdog higher threshold"]
            #[inline]
            pub fn ht(&self) -> HTR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                HTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0fff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Analog watchdog higher threshold"]
            #[inline]
            pub fn ht(&mut self) -> _HTW {
                _HTW { w: self }
            }
        }
    }
    #[doc = "watchdog lower threshold register"]
    pub struct LTR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "watchdog lower threshold register"]
    pub mod ltr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LTR {
            bits: u16,
        }
        impl LTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - Analog watchdog lower threshold"]
            #[inline]
            pub fn lt(&self) -> LTR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                LTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Analog watchdog lower threshold"]
            #[inline]
            pub fn lt(&mut self) -> _LTW {
                _LTW { w: self }
            }
        }
    }
    #[doc = "regular sequence register 1"]
    pub struct SQR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "regular sequence register 1"]
    pub mod sqr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SQR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LR {
            bits: u8,
        }
        impl LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SQ16R {
            bits: u8,
        }
        impl SQ16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SQ15R {
            bits: u8,
        }
        impl SQ15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SQ14R {
            bits: u8,
        }
        impl SQ14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SQ13R {
            bits: u8,
        }
        impl SQ13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SQ16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SQ16W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SQ15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SQ15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SQ14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SQ14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SQ13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SQ13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 20:23 - Regular channel sequence length"]
            #[inline]
            pub fn l(&self) -> LR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LR { bits }
            }
            #[doc = "Bits 15:19 - 16th conversion in regular sequence"]
            #[inline]
            pub fn sq16(&self) -> SQ16R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SQ16R { bits }
            }
            #[doc = "Bits 10:14 - 15th conversion in regular sequence"]
            #[inline]
            pub fn sq15(&self) -> SQ15R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SQ15R { bits }
            }
            #[doc = "Bits 5:9 - 14th conversion in regular sequence"]
            #[inline]
            pub fn sq14(&self) -> SQ14R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SQ14R { bits }
            }
            #[doc = "Bits 0:4 - 13th conversion in regular sequence"]
            #[inline]
            pub fn sq13(&self) -> SQ13R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SQ13R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 20:23 - Regular channel sequence length"]
            #[inline]
            pub fn l(&mut self) -> _LW {
                _LW { w: self }
            }
            #[doc = "Bits 15:19 - 16th conversion in regular sequence"]
            #[inline]
            pub fn sq16(&mut self) -> _SQ16W {
                _SQ16W { w: self }
            }
            #[doc = "Bits 10:14 - 15th conversion in regular sequence"]
            #[inline]
            pub fn sq15(&mut self) -> _SQ15W {
                _SQ15W { w: self }
            }
            #[doc = "Bits 5:9 - 14th conversion in regular sequence"]
            #[inline]
            pub fn sq14(&mut self) -> _SQ14W {
                _SQ14W { w: self }
            }
            #[doc = "Bits 0:4 - 13th conversion in regular sequence"]
            #[inline]
            pub fn sq13(&mut self) -> _SQ13W {
                _SQ13W { w: self }
            }
        }
    }
    #[doc = "regular sequence register 2"]
    pub struct SQR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "regular sequence register 2"]
    pub mod sqr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SQR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SQ12R {
            bits: u8,
        }
        impl SQ12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SQ11R {
            bits: u8,
        }
        impl SQ11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SQ10R {
            bits: u8,
        }
        impl SQ10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SQ9R {
            bits: u8,
        }
        impl SQ9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SQ8R {
            bits: u8,
        }
        impl SQ8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SQ7R {
            bits: u8,
        }
        impl SQ7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SQ12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SQ12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SQ11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SQ11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SQ10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SQ10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SQ9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SQ9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SQ8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SQ8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SQ7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SQ7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 25:29 - 12th conversion in regular sequence"]
            #[inline]
            pub fn sq12(&self) -> SQ12R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SQ12R { bits }
            }
            #[doc = "Bits 20:24 - 11th conversion in regular sequence"]
            #[inline]
            pub fn sq11(&self) -> SQ11R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SQ11R { bits }
            }
            #[doc = "Bits 15:19 - 10th conversion in regular sequence"]
            #[inline]
            pub fn sq10(&self) -> SQ10R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SQ10R { bits }
            }
            #[doc = "Bits 10:14 - 9th conversion in regular sequence"]
            #[inline]
            pub fn sq9(&self) -> SQ9R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SQ9R { bits }
            }
            #[doc = "Bits 5:9 - 8th conversion in regular sequence"]
            #[inline]
            pub fn sq8(&self) -> SQ8R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SQ8R { bits }
            }
            #[doc = "Bits 0:4 - 7th conversion in regular sequence"]
            #[inline]
            pub fn sq7(&self) -> SQ7R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SQ7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 25:29 - 12th conversion in regular sequence"]
            #[inline]
            pub fn sq12(&mut self) -> _SQ12W {
                _SQ12W { w: self }
            }
            #[doc = "Bits 20:24 - 11th conversion in regular sequence"]
            #[inline]
            pub fn sq11(&mut self) -> _SQ11W {
                _SQ11W { w: self }
            }
            #[doc = "Bits 15:19 - 10th conversion in regular sequence"]
            #[inline]
            pub fn sq10(&mut self) -> _SQ10W {
                _SQ10W { w: self }
            }
            #[doc = "Bits 10:14 - 9th conversion in regular sequence"]
            #[inline]
            pub fn sq9(&mut self) -> _SQ9W {
                _SQ9W { w: self }
            }
            #[doc = "Bits 5:9 - 8th conversion in regular sequence"]
            #[inline]
            pub fn sq8(&mut self) -> _SQ8W {
                _SQ8W { w: self }
            }
            #[doc = "Bits 0:4 - 7th conversion in regular sequence"]
            #[inline]
            pub fn sq7(&mut self) -> _SQ7W {
                _SQ7W { w: self }
            }
        }
    }
    #[doc = "regular sequence register 3"]
    pub struct SQR3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "regular sequence register 3"]
    pub mod sqr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SQR3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SQ6R {
            bits: u8,
        }
        impl SQ6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SQ5R {
            bits: u8,
        }
        impl SQ5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SQ4R {
            bits: u8,
        }
        impl SQ4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SQ3R {
            bits: u8,
        }
        impl SQ3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SQ2R {
            bits: u8,
        }
        impl SQ2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SQ1R {
            bits: u8,
        }
        impl SQ1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SQ6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SQ6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SQ5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SQ5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SQ4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SQ4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SQ3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SQ3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SQ2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SQ2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SQ1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SQ1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 25:29 - 6th conversion in regular sequence"]
            #[inline]
            pub fn sq6(&self) -> SQ6R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SQ6R { bits }
            }
            #[doc = "Bits 20:24 - 5th conversion in regular sequence"]
            #[inline]
            pub fn sq5(&self) -> SQ5R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SQ5R { bits }
            }
            #[doc = "Bits 15:19 - 4th conversion in regular sequence"]
            #[inline]
            pub fn sq4(&self) -> SQ4R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SQ4R { bits }
            }
            #[doc = "Bits 10:14 - 3rd conversion in regular sequence"]
            #[inline]
            pub fn sq3(&self) -> SQ3R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SQ3R { bits }
            }
            #[doc = "Bits 5:9 - 2nd conversion in regular sequence"]
            #[inline]
            pub fn sq2(&self) -> SQ2R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SQ2R { bits }
            }
            #[doc = "Bits 0:4 - 1st conversion in regular sequence"]
            #[inline]
            pub fn sq1(&self) -> SQ1R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SQ1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 25:29 - 6th conversion in regular sequence"]
            #[inline]
            pub fn sq6(&mut self) -> _SQ6W {
                _SQ6W { w: self }
            }
            #[doc = "Bits 20:24 - 5th conversion in regular sequence"]
            #[inline]
            pub fn sq5(&mut self) -> _SQ5W {
                _SQ5W { w: self }
            }
            #[doc = "Bits 15:19 - 4th conversion in regular sequence"]
            #[inline]
            pub fn sq4(&mut self) -> _SQ4W {
                _SQ4W { w: self }
            }
            #[doc = "Bits 10:14 - 3rd conversion in regular sequence"]
            #[inline]
            pub fn sq3(&mut self) -> _SQ3W {
                _SQ3W { w: self }
            }
            #[doc = "Bits 5:9 - 2nd conversion in regular sequence"]
            #[inline]
            pub fn sq2(&mut self) -> _SQ2W {
                _SQ2W { w: self }
            }
            #[doc = "Bits 0:4 - 1st conversion in regular sequence"]
            #[inline]
            pub fn sq1(&mut self) -> _SQ1W {
                _SQ1W { w: self }
            }
        }
    }
    #[doc = "injected sequence register"]
    pub struct JSQR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "injected sequence register"]
    pub mod jsqr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::JSQR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct JLR {
            bits: u8,
        }
        impl JLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct JSQ4R {
            bits: u8,
        }
        impl JSQ4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct JSQ3R {
            bits: u8,
        }
        impl JSQ3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct JSQ2R {
            bits: u8,
        }
        impl JSQ2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct JSQ1R {
            bits: u8,
        }
        impl JSQ1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _JLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _JSQ4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _JSQ4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _JSQ3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _JSQ3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _JSQ2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _JSQ2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _JSQ1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _JSQ1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 20:21 - Injected sequence length"]
            #[inline]
            pub fn jl(&self) -> JLR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JLR { bits }
            }
            #[doc = "Bits 15:19 - 4th conversion in injected sequence"]
            #[inline]
            pub fn jsq4(&self) -> JSQ4R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JSQ4R { bits }
            }
            #[doc = "Bits 10:14 - 3rd conversion in injected sequence"]
            #[inline]
            pub fn jsq3(&self) -> JSQ3R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JSQ3R { bits }
            }
            #[doc = "Bits 5:9 - 2nd conversion in injected sequence"]
            #[inline]
            pub fn jsq2(&self) -> JSQ2R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JSQ2R { bits }
            }
            #[doc = "Bits 0:4 - 1st conversion in injected sequence"]
            #[inline]
            pub fn jsq1(&self) -> JSQ1R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JSQ1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 20:21 - Injected sequence length"]
            #[inline]
            pub fn jl(&mut self) -> _JLW {
                _JLW { w: self }
            }
            #[doc = "Bits 15:19 - 4th conversion in injected sequence"]
            #[inline]
            pub fn jsq4(&mut self) -> _JSQ4W {
                _JSQ4W { w: self }
            }
            #[doc = "Bits 10:14 - 3rd conversion in injected sequence"]
            #[inline]
            pub fn jsq3(&mut self) -> _JSQ3W {
                _JSQ3W { w: self }
            }
            #[doc = "Bits 5:9 - 2nd conversion in injected sequence"]
            #[inline]
            pub fn jsq2(&mut self) -> _JSQ2W {
                _JSQ2W { w: self }
            }
            #[doc = "Bits 0:4 - 1st conversion in injected sequence"]
            #[inline]
            pub fn jsq1(&mut self) -> _JSQ1W {
                _JSQ1W { w: self }
            }
        }
    }
    #[doc = "injected data register x"]
    pub struct JDR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "injected data register x"]
    pub mod jdr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::JDR1 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct JDATAR {
            bits: u16,
        }
        impl JDATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Injected data"]
            #[inline]
            pub fn jdata(&self) -> JDATAR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                JDATAR { bits }
            }
        }
    }
    #[doc = "injected data register x"]
    pub struct JDR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "injected data register x"]
    pub mod jdr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::JDR2 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct JDATAR {
            bits: u16,
        }
        impl JDATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Injected data"]
            #[inline]
            pub fn jdata(&self) -> JDATAR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                JDATAR { bits }
            }
        }
    }
    #[doc = "injected data register x"]
    pub struct JDR3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "injected data register x"]
    pub mod jdr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::JDR3 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct JDATAR {
            bits: u16,
        }
        impl JDATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Injected data"]
            #[inline]
            pub fn jdata(&self) -> JDATAR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                JDATAR { bits }
            }
        }
    }
    #[doc = "injected data register x"]
    pub struct JDR4 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "injected data register x"]
    pub mod jdr4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::JDR4 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct JDATAR {
            bits: u16,
        }
        impl JDATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Injected data"]
            #[inline]
            pub fn jdata(&self) -> JDATAR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                JDATAR { bits }
            }
        }
    }
    #[doc = "regular data register"]
    pub struct DR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "regular data register"]
    pub mod dr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DR {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u16,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Regular data"]
            #[inline]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DATAR { bits }
            }
        }
    }
}
#[doc = "Digital to analog converter"]
#[cfg(feature = "dac")]
pub struct DAC {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "dac")]
unsafe impl Send for DAC {}
#[cfg(feature = "dac")]
impl DAC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const dac::RegisterBlock {
        0x4000_7400 as *const _
    }
}
#[cfg(feature = "dac")]
impl Deref for DAC {
    type Target = dac::RegisterBlock;
    fn deref(&self) -> &dac::RegisterBlock {
        unsafe { &*DAC::ptr() }
    }
}
#[doc = "Digital to analog converter"]
#[cfg(feature = "dac")]
pub mod dac {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control register (DAC_CR)"]
        pub cr: CR,
        #[doc = "0x04 - DAC software trigger register (DAC_SWTRIGR)"]
        pub swtrigr: SWTRIGR,
        #[doc = "0x08 - DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)"]
        pub dhr12r1: DHR12R1,
        #[doc = "0x0c - DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)"]
        pub dhr12l1: DHR12L1,
        #[doc = "0x10 - DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)"]
        pub dhr8r1: DHR8R1,
        #[doc = "0x14 - DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)"]
        pub dhr12r2: DHR12R2,
        #[doc = "0x18 - DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)"]
        pub dhr12l2: DHR12L2,
        #[doc = "0x1c - DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)"]
        pub dhr8r2: DHR8R2,
        #[doc = "0x20 - Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved"]
        pub dhr12rd: DHR12RD,
        #[doc = "0x24 - DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved"]
        pub dhr12ld: DHR12LD,
        #[doc = "0x28 - DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved"]
        pub dhr8rd: DHR8RD,
        #[doc = "0x2c - DAC channel1 data output register (DAC_DOR1)"]
        pub dor1: DOR1,
        #[doc = "0x30 - DAC channel2 data output register (DAC_DOR2)"]
        pub dor2: DOR2,
        #[doc = "0x34 - DAC status register"]
        pub sr: SR,
    }
    #[doc = "Control register (DAC_CR)"]
    pub struct CR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control register (DAC_CR)"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `EN1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EN1R {
            #[doc = "DAC channel1 disabled"]
            DISABLED,
            #[doc = "DAC channel1 enabled"]
            ENABLED,
        }
        impl EN1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    EN1R::DISABLED => false,
                    EN1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> EN1R {
                match value {
                    false => EN1R::DISABLED,
                    true => EN1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == EN1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == EN1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `BOFF1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BOFF1R {
            #[doc = "DAC channel1 output buffer enabled"]
            ENABLED,
            #[doc = "DAC channel1 output buffer disabled"]
            DISABLED,
        }
        impl BOFF1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BOFF1R::ENABLED => false,
                    BOFF1R::DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BOFF1R {
                match value {
                    false => BOFF1R::ENABLED,
                    true => BOFF1R::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == BOFF1R::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == BOFF1R::DISABLED
            }
        }
        #[doc = "Possible values of the field `TEN1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TEN1R {
            #[doc = "DAC channel1 trigger disabled"]
            DISABLED,
            #[doc = "DAC channel1 trigger enabled"]
            ENABLED,
        }
        impl TEN1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TEN1R::DISABLED => false,
                    TEN1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TEN1R {
                match value {
                    false => TEN1R::DISABLED,
                    true => TEN1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TEN1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TEN1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `TSEL1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TSEL1R {
            #[doc = "Timer 6 TRGO event"]
            TIM6_TRGO,
            #[doc = "Timer 3 TRGO event"]
            TIM3_TRGO,
            #[doc = "Timer 7 TRGO event"]
            TIM7_TRGO,
            #[doc = "Timer 15 TRGO event"]
            TIM15_TRGO,
            #[doc = "Timer 2 TRGO event"]
            TIM2_TRGO,
            #[doc = "EXTI line9"]
            EXTI9,
            #[doc = "Software trigger"]
            SOFTWARE,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl TSEL1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    TSEL1R::TIM6_TRGO => 0,
                    TSEL1R::TIM3_TRGO => 0x01,
                    TSEL1R::TIM7_TRGO => 0x02,
                    TSEL1R::TIM15_TRGO => 0x03,
                    TSEL1R::TIM2_TRGO => 0x04,
                    TSEL1R::EXTI9 => 0x06,
                    TSEL1R::SOFTWARE => 0x07,
                    TSEL1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> TSEL1R {
                match value {
                    0 => TSEL1R::TIM6_TRGO,
                    1 => TSEL1R::TIM3_TRGO,
                    2 => TSEL1R::TIM7_TRGO,
                    3 => TSEL1R::TIM15_TRGO,
                    4 => TSEL1R::TIM2_TRGO,
                    6 => TSEL1R::EXTI9,
                    7 => TSEL1R::SOFTWARE,
                    i => TSEL1R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `TIM6_TRGO`"]
            #[inline]
            pub fn is_tim6_trgo(&self) -> bool {
                *self == TSEL1R::TIM6_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM3_TRGO`"]
            #[inline]
            pub fn is_tim3_trgo(&self) -> bool {
                *self == TSEL1R::TIM3_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM7_TRGO`"]
            #[inline]
            pub fn is_tim7_trgo(&self) -> bool {
                *self == TSEL1R::TIM7_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM15_TRGO`"]
            #[inline]
            pub fn is_tim15_trgo(&self) -> bool {
                *self == TSEL1R::TIM15_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM2_TRGO`"]
            #[inline]
            pub fn is_tim2_trgo(&self) -> bool {
                *self == TSEL1R::TIM2_TRGO
            }
            #[doc = "Checks if the value of the field is `EXTI9`"]
            #[inline]
            pub fn is_exti9(&self) -> bool {
                *self == TSEL1R::EXTI9
            }
            #[doc = "Checks if the value of the field is `SOFTWARE`"]
            #[inline]
            pub fn is_software(&self) -> bool {
                *self == TSEL1R::SOFTWARE
            }
        }
        #[doc = "Possible values of the field `WAVE1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAVE1R {
            #[doc = "Wave generation disabled"]
            DISABLED,
            #[doc = "Noise wave generation enabled"]
            NOISE,
            #[doc = "Triangle wave generation enabled"]
            TRIANGLE,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl WAVE1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    WAVE1R::DISABLED => 0,
                    WAVE1R::NOISE => 0x01,
                    WAVE1R::TRIANGLE => 0x02,
                    WAVE1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> WAVE1R {
                match value {
                    0 => WAVE1R::DISABLED,
                    1 => WAVE1R::NOISE,
                    2 => WAVE1R::TRIANGLE,
                    i => WAVE1R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == WAVE1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `NOISE`"]
            #[inline]
            pub fn is_noise(&self) -> bool {
                *self == WAVE1R::NOISE
            }
            #[doc = "Checks if the value of the field is `TRIANGLE`"]
            #[inline]
            pub fn is_triangle(&self) -> bool {
                *self == WAVE1R::TRIANGLE
            }
        }
        #[doc = r" Value of the field"]
        pub struct MAMP1R {
            bits: u8,
        }
        impl MAMP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `DMAEN1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAEN1R {
            #[doc = "DAC channel1 DMA mode disabled"]
            DISABLED,
            #[doc = "DAC channel1 DMA mode enabled"]
            ENABLED,
        }
        impl DMAEN1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DMAEN1R::DISABLED => false,
                    DMAEN1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DMAEN1R {
                match value {
                    false => DMAEN1R::DISABLED,
                    true => DMAEN1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DMAEN1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DMAEN1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `EN2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EN2R {
            #[doc = "DAC channel2 disabled"]
            DISABLED,
            #[doc = "DAC channel2 enabled"]
            ENABLED,
        }
        impl EN2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    EN2R::DISABLED => false,
                    EN2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> EN2R {
                match value {
                    false => EN2R::DISABLED,
                    true => EN2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == EN2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == EN2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `BOFF2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BOFF2R {
            #[doc = "DAC channel2 output buffer enabled"]
            ENABLED,
            #[doc = "DAC channel2 output buffer disabled"]
            DISABLED,
        }
        impl BOFF2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BOFF2R::ENABLED => false,
                    BOFF2R::DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BOFF2R {
                match value {
                    false => BOFF2R::ENABLED,
                    true => BOFF2R::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == BOFF2R::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == BOFF2R::DISABLED
            }
        }
        #[doc = "Possible values of the field `TEN2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TEN2R {
            #[doc = "DAC channel2 trigger disabled"]
            DISABLED,
            #[doc = "DAC channel2 trigger enabled"]
            ENABLED,
        }
        impl TEN2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TEN2R::DISABLED => false,
                    TEN2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TEN2R {
                match value {
                    false => TEN2R::DISABLED,
                    true => TEN2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TEN2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TEN2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `TSEL2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TSEL2R {
            #[doc = "Timer 6 TRGO event"]
            TIM6_TRGO,
            #[doc = "Timer 8 TRGO event"]
            TIM8_TRGO,
            #[doc = "Timer 7 TRGO event"]
            TIM7_TRGO,
            #[doc = "Timer 5 TRGO event"]
            TIM5_TRGO,
            #[doc = "Timer 2 TRGO event"]
            TIM2_TRGO,
            #[doc = "Timer 4 TRGO event"]
            TIM4_TRGO,
            #[doc = "EXTI line9"]
            EXTI9,
            #[doc = "Software trigger"]
            SOFTWARE,
        }
        impl TSEL2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    TSEL2R::TIM6_TRGO => 0,
                    TSEL2R::TIM8_TRGO => 0x01,
                    TSEL2R::TIM7_TRGO => 0x02,
                    TSEL2R::TIM5_TRGO => 0x03,
                    TSEL2R::TIM2_TRGO => 0x04,
                    TSEL2R::TIM4_TRGO => 0x05,
                    TSEL2R::EXTI9 => 0x06,
                    TSEL2R::SOFTWARE => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> TSEL2R {
                match value {
                    0 => TSEL2R::TIM6_TRGO,
                    1 => TSEL2R::TIM8_TRGO,
                    2 => TSEL2R::TIM7_TRGO,
                    3 => TSEL2R::TIM5_TRGO,
                    4 => TSEL2R::TIM2_TRGO,
                    5 => TSEL2R::TIM4_TRGO,
                    6 => TSEL2R::EXTI9,
                    7 => TSEL2R::SOFTWARE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TIM6_TRGO`"]
            #[inline]
            pub fn is_tim6_trgo(&self) -> bool {
                *self == TSEL2R::TIM6_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM8_TRGO`"]
            #[inline]
            pub fn is_tim8_trgo(&self) -> bool {
                *self == TSEL2R::TIM8_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM7_TRGO`"]
            #[inline]
            pub fn is_tim7_trgo(&self) -> bool {
                *self == TSEL2R::TIM7_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM5_TRGO`"]
            #[inline]
            pub fn is_tim5_trgo(&self) -> bool {
                *self == TSEL2R::TIM5_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM2_TRGO`"]
            #[inline]
            pub fn is_tim2_trgo(&self) -> bool {
                *self == TSEL2R::TIM2_TRGO
            }
            #[doc = "Checks if the value of the field is `TIM4_TRGO`"]
            #[inline]
            pub fn is_tim4_trgo(&self) -> bool {
                *self == TSEL2R::TIM4_TRGO
            }
            #[doc = "Checks if the value of the field is `EXTI9`"]
            #[inline]
            pub fn is_exti9(&self) -> bool {
                *self == TSEL2R::EXTI9
            }
            #[doc = "Checks if the value of the field is `SOFTWARE`"]
            #[inline]
            pub fn is_software(&self) -> bool {
                *self == TSEL2R::SOFTWARE
            }
        }
        #[doc = "Possible values of the field `WAVE2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAVE2R {
            #[doc = "Wave generation disabled"]
            DISABLED,
            #[doc = "Noise wave generation enabled"]
            NOISE,
            #[doc = "Triangle wave generation enabled"]
            TRIANGLE,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl WAVE2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    WAVE2R::DISABLED => 0,
                    WAVE2R::NOISE => 0x01,
                    WAVE2R::TRIANGLE => 0x02,
                    WAVE2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> WAVE2R {
                match value {
                    0 => WAVE2R::DISABLED,
                    1 => WAVE2R::NOISE,
                    2 => WAVE2R::TRIANGLE,
                    i => WAVE2R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == WAVE2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `NOISE`"]
            #[inline]
            pub fn is_noise(&self) -> bool {
                *self == WAVE2R::NOISE
            }
            #[doc = "Checks if the value of the field is `TRIANGLE`"]
            #[inline]
            pub fn is_triangle(&self) -> bool {
                *self == WAVE2R::TRIANGLE
            }
        }
        #[doc = r" Value of the field"]
        pub struct MAMP2R {
            bits: u8,
        }
        impl MAMP2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `DMAEN2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAEN2R {
            #[doc = "DAC channel2 DMA mode disabled"]
            DISABLED,
            #[doc = "DAC channel2 DMA mode enabled"]
            ENABLED,
        }
        impl DMAEN2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DMAEN2R::DISABLED => false,
                    DMAEN2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DMAEN2R {
                match value {
                    false => DMAEN2R::DISABLED,
                    true => DMAEN2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DMAEN2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DMAEN2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `DMAUDRIE1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAUDRIE1R {
            #[doc = "DAC channel1 DMA Underrun Interrupt disabled"]
            DISABLED,
            #[doc = "DAC channel1 DMA Underrun Interrupt enabled"]
            ENABLED,
        }
        impl DMAUDRIE1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DMAUDRIE1R::DISABLED => false,
                    DMAUDRIE1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DMAUDRIE1R {
                match value {
                    false => DMAUDRIE1R::DISABLED,
                    true => DMAUDRIE1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DMAUDRIE1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DMAUDRIE1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `DMAUDRIE2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAUDRIE2R {
            #[doc = "DAC channel2 DMA Underrun Interrupt disabled"]
            DISABLED,
            #[doc = "DAC channel2 DMA Underrun Interrupt enabled"]
            ENABLED,
        }
        impl DMAUDRIE2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DMAUDRIE2R::DISABLED => false,
                    DMAUDRIE2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DMAUDRIE2R {
                match value {
                    false => DMAUDRIE2R::DISABLED,
                    true => DMAUDRIE2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DMAUDRIE2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DMAUDRIE2R::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `EN1`"]
        pub enum EN1W {
            #[doc = "DAC channel1 disabled"]
            DISABLED,
            #[doc = "DAC channel1 enabled"]
            ENABLED,
        }
        impl EN1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    EN1W::DISABLED => false,
                    EN1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EN1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EN1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "DAC channel1 disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EN1W::DISABLED)
            }
            #[doc = "DAC channel1 enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EN1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BOFF1`"]
        pub enum BOFF1W {
            #[doc = "DAC channel1 output buffer enabled"]
            ENABLED,
            #[doc = "DAC channel1 output buffer disabled"]
            DISABLED,
        }
        impl BOFF1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BOFF1W::ENABLED => false,
                    BOFF1W::DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOFF1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOFF1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BOFF1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "DAC channel1 output buffer enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BOFF1W::ENABLED)
            }
            #[doc = "DAC channel1 output buffer disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BOFF1W::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TEN1`"]
        pub enum TEN1W {
            #[doc = "DAC channel1 trigger disabled"]
            DISABLED,
            #[doc = "DAC channel1 trigger enabled"]
            ENABLED,
        }
        impl TEN1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TEN1W::DISABLED => false,
                    TEN1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TEN1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TEN1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "DAC channel1 trigger disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TEN1W::DISABLED)
            }
            #[doc = "DAC channel1 trigger enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TEN1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TSEL1`"]
        pub enum TSEL1W {
            #[doc = "Timer 6 TRGO event"]
            TIM6_TRGO,
            #[doc = "Timer 3 TRGO event"]
            TIM3_TRGO,
            #[doc = "Timer 7 TRGO event"]
            TIM7_TRGO,
            #[doc = "Timer 15 TRGO event"]
            TIM15_TRGO,
            #[doc = "Timer 2 TRGO event"]
            TIM2_TRGO,
            #[doc = "EXTI line9"]
            EXTI9,
            #[doc = "Software trigger"]
            SOFTWARE,
        }
        impl TSEL1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TSEL1W::TIM6_TRGO => 0,
                    TSEL1W::TIM3_TRGO => 1,
                    TSEL1W::TIM7_TRGO => 2,
                    TSEL1W::TIM15_TRGO => 3,
                    TSEL1W::TIM2_TRGO => 4,
                    TSEL1W::EXTI9 => 6,
                    TSEL1W::SOFTWARE => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TSEL1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TSEL1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TSEL1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Timer 6 TRGO event"]
            #[inline]
            pub fn tim6_trgo(self) -> &'a mut W {
                self.variant(TSEL1W::TIM6_TRGO)
            }
            #[doc = "Timer 3 TRGO event"]
            #[inline]
            pub fn tim3_trgo(self) -> &'a mut W {
                self.variant(TSEL1W::TIM3_TRGO)
            }
            #[doc = "Timer 7 TRGO event"]
            #[inline]
            pub fn tim7_trgo(self) -> &'a mut W {
                self.variant(TSEL1W::TIM7_TRGO)
            }
            #[doc = "Timer 15 TRGO event"]
            #[inline]
            pub fn tim15_trgo(self) -> &'a mut W {
                self.variant(TSEL1W::TIM15_TRGO)
            }
            #[doc = "Timer 2 TRGO event"]
            #[inline]
            pub fn tim2_trgo(self) -> &'a mut W {
                self.variant(TSEL1W::TIM2_TRGO)
            }
            #[doc = "EXTI line9"]
            #[inline]
            pub fn exti9(self) -> &'a mut W {
                self.variant(TSEL1W::EXTI9)
            }
            #[doc = "Software trigger"]
            #[inline]
            pub fn software(self) -> &'a mut W {
                self.variant(TSEL1W::SOFTWARE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WAVE1`"]
        pub enum WAVE1W {
            #[doc = "Wave generation disabled"]
            DISABLED,
            #[doc = "Noise wave generation enabled"]
            NOISE,
            #[doc = "Triangle wave generation enabled"]
            TRIANGLE,
        }
        impl WAVE1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WAVE1W::DISABLED => 0,
                    WAVE1W::NOISE => 1,
                    WAVE1W::TRIANGLE => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAVE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAVE1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WAVE1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Wave generation disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAVE1W::DISABLED)
            }
            #[doc = "Noise wave generation enabled"]
            #[inline]
            pub fn noise(self) -> &'a mut W {
                self.variant(WAVE1W::NOISE)
            }
            #[doc = "Triangle wave generation enabled"]
            #[inline]
            pub fn triangle(self) -> &'a mut W {
                self.variant(WAVE1W::TRIANGLE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MAMP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MAMP1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DMAEN1`"]
        pub enum DMAEN1W {
            #[doc = "DAC channel1 DMA mode disabled"]
            DISABLED,
            #[doc = "DAC channel1 DMA mode enabled"]
            ENABLED,
        }
        impl DMAEN1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DMAEN1W::DISABLED => false,
                    DMAEN1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMAEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMAEN1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMAEN1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "DAC channel1 DMA mode disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAEN1W::DISABLED)
            }
            #[doc = "DAC channel1 DMA mode enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAEN1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EN2`"]
        pub enum EN2W {
            #[doc = "DAC channel2 disabled"]
            DISABLED,
            #[doc = "DAC channel2 enabled"]
            ENABLED,
        }
        impl EN2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    EN2W::DISABLED => false,
                    EN2W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EN2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EN2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "DAC channel2 disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EN2W::DISABLED)
            }
            #[doc = "DAC channel2 enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EN2W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BOFF2`"]
        pub enum BOFF2W {
            #[doc = "DAC channel2 output buffer enabled"]
            ENABLED,
            #[doc = "DAC channel2 output buffer disabled"]
            DISABLED,
        }
        impl BOFF2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BOFF2W::ENABLED => false,
                    BOFF2W::DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOFF2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOFF2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BOFF2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "DAC channel2 output buffer enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BOFF2W::ENABLED)
            }
            #[doc = "DAC channel2 output buffer disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BOFF2W::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TEN2`"]
        pub enum TEN2W {
            #[doc = "DAC channel2 trigger disabled"]
            DISABLED,
            #[doc = "DAC channel2 trigger enabled"]
            ENABLED,
        }
        impl TEN2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TEN2W::DISABLED => false,
                    TEN2W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TEN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TEN2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TEN2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "DAC channel2 trigger disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TEN2W::DISABLED)
            }
            #[doc = "DAC channel2 trigger enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TEN2W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TSEL2`"]
        pub enum TSEL2W {
            #[doc = "Timer 6 TRGO event"]
            TIM6_TRGO,
            #[doc = "Timer 8 TRGO event"]
            TIM8_TRGO,
            #[doc = "Timer 7 TRGO event"]
            TIM7_TRGO,
            #[doc = "Timer 5 TRGO event"]
            TIM5_TRGO,
            #[doc = "Timer 2 TRGO event"]
            TIM2_TRGO,
            #[doc = "Timer 4 TRGO event"]
            TIM4_TRGO,
            #[doc = "EXTI line9"]
            EXTI9,
            #[doc = "Software trigger"]
            SOFTWARE,
        }
        impl TSEL2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TSEL2W::TIM6_TRGO => 0,
                    TSEL2W::TIM8_TRGO => 1,
                    TSEL2W::TIM7_TRGO => 2,
                    TSEL2W::TIM5_TRGO => 3,
                    TSEL2W::TIM2_TRGO => 4,
                    TSEL2W::TIM4_TRGO => 5,
                    TSEL2W::EXTI9 => 6,
                    TSEL2W::SOFTWARE => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TSEL2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TSEL2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TSEL2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Timer 6 TRGO event"]
            #[inline]
            pub fn tim6_trgo(self) -> &'a mut W {
                self.variant(TSEL2W::TIM6_TRGO)
            }
            #[doc = "Timer 8 TRGO event"]
            #[inline]
            pub fn tim8_trgo(self) -> &'a mut W {
                self.variant(TSEL2W::TIM8_TRGO)
            }
            #[doc = "Timer 7 TRGO event"]
            #[inline]
            pub fn tim7_trgo(self) -> &'a mut W {
                self.variant(TSEL2W::TIM7_TRGO)
            }
            #[doc = "Timer 5 TRGO event"]
            #[inline]
            pub fn tim5_trgo(self) -> &'a mut W {
                self.variant(TSEL2W::TIM5_TRGO)
            }
            #[doc = "Timer 2 TRGO event"]
            #[inline]
            pub fn tim2_trgo(self) -> &'a mut W {
                self.variant(TSEL2W::TIM2_TRGO)
            }
            #[doc = "Timer 4 TRGO event"]
            #[inline]
            pub fn tim4_trgo(self) -> &'a mut W {
                self.variant(TSEL2W::TIM4_TRGO)
            }
            #[doc = "EXTI line9"]
            #[inline]
            pub fn exti9(self) -> &'a mut W {
                self.variant(TSEL2W::EXTI9)
            }
            #[doc = "Software trigger"]
            #[inline]
            pub fn software(self) -> &'a mut W {
                self.variant(TSEL2W::SOFTWARE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WAVE2`"]
        pub enum WAVE2W {
            #[doc = "Wave generation disabled"]
            DISABLED,
            #[doc = "Noise wave generation enabled"]
            NOISE,
            #[doc = "Triangle wave generation enabled"]
            TRIANGLE,
        }
        impl WAVE2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WAVE2W::DISABLED => 0,
                    WAVE2W::NOISE => 1,
                    WAVE2W::TRIANGLE => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAVE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAVE2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WAVE2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Wave generation disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAVE2W::DISABLED)
            }
            #[doc = "Noise wave generation enabled"]
            #[inline]
            pub fn noise(self) -> &'a mut W {
                self.variant(WAVE2W::NOISE)
            }
            #[doc = "Triangle wave generation enabled"]
            #[inline]
            pub fn triangle(self) -> &'a mut W {
                self.variant(WAVE2W::TRIANGLE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MAMP2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MAMP2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DMAEN2`"]
        pub enum DMAEN2W {
            #[doc = "DAC channel2 DMA mode disabled"]
            DISABLED,
            #[doc = "DAC channel2 DMA mode enabled"]
            ENABLED,
        }
        impl DMAEN2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DMAEN2W::DISABLED => false,
                    DMAEN2W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMAEN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMAEN2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMAEN2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "DAC channel2 DMA mode disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAEN2W::DISABLED)
            }
            #[doc = "DAC channel2 DMA mode enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAEN2W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DMAUDRIE1`"]
        pub enum DMAUDRIE1W {
            #[doc = "DAC channel1 DMA Underrun Interrupt disabled"]
            DISABLED,
            #[doc = "DAC channel1 DMA Underrun Interrupt enabled"]
            ENABLED,
        }
        impl DMAUDRIE1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DMAUDRIE1W::DISABLED => false,
                    DMAUDRIE1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMAUDRIE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMAUDRIE1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMAUDRIE1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "DAC channel1 DMA Underrun Interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAUDRIE1W::DISABLED)
            }
            #[doc = "DAC channel1 DMA Underrun Interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAUDRIE1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DMAUDRIE2`"]
        pub enum DMAUDRIE2W {
            #[doc = "DAC channel2 DMA Underrun Interrupt disabled"]
            DISABLED,
            #[doc = "DAC channel2 DMA Underrun Interrupt enabled"]
            ENABLED,
        }
        impl DMAUDRIE2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DMAUDRIE2W::DISABLED => false,
                    DMAUDRIE2W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMAUDRIE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMAUDRIE2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMAUDRIE2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "DAC channel2 DMA Underrun Interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAUDRIE2W::DISABLED)
            }
            #[doc = "DAC channel2 DMA Underrun Interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAUDRIE2W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - DAC channel1 enable"]
            #[inline]
            pub fn en1(&self) -> EN1R {
                EN1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - DAC channel1 output buffer disable"]
            #[inline]
            pub fn boff1(&self) -> BOFF1R {
                BOFF1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - DAC channel1 trigger enable"]
            #[inline]
            pub fn ten1(&self) -> TEN1R {
                TEN1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 3:5 - DAC channel1 trigger selection"]
            #[inline]
            pub fn tsel1(&self) -> TSEL1R {
                TSEL1R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 6:7 - DAC channel1 noise/triangle wave generation enable"]
            #[inline]
            pub fn wave1(&self) -> WAVE1R {
                WAVE1R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:11 - DAC channel1 mask/amplitude selector"]
            #[inline]
            pub fn mamp1(&self) -> MAMP1R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MAMP1R { bits }
            }
            #[doc = "Bit 12 - DAC channel1 DMA enable"]
            #[inline]
            pub fn dmaen1(&self) -> DMAEN1R {
                DMAEN1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - DAC channel2 enable"]
            #[inline]
            pub fn en2(&self) -> EN2R {
                EN2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - DAC channel2 output buffer disable"]
            #[inline]
            pub fn boff2(&self) -> BOFF2R {
                BOFF2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - DAC channel2 trigger enable"]
            #[inline]
            pub fn ten2(&self) -> TEN2R {
                TEN2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 19:21 - DAC channel2 trigger selection"]
            #[inline]
            pub fn tsel2(&self) -> TSEL2R {
                TSEL2R::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 22:23 - DAC channel2 noise/triangle wave generation enable"]
            #[inline]
            pub fn wave2(&self) -> WAVE2R {
                WAVE2R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 24:27 - DAC channel2 mask/amplitude selector"]
            #[inline]
            pub fn mamp2(&self) -> MAMP2R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MAMP2R { bits }
            }
            #[doc = "Bit 28 - DAC channel2 DMA enable"]
            #[inline]
            pub fn dmaen2(&self) -> DMAEN2R {
                DMAEN2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - DAC channel1 DMA underrun interrupt enable"]
            #[inline]
            pub fn dmaudrie1(&self) -> DMAUDRIE1R {
                DMAUDRIE1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - DAC channel2 DMA underrun interrupt enable"]
            #[inline]
            pub fn dmaudrie2(&self) -> DMAUDRIE2R {
                DMAUDRIE2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - DAC channel1 enable"]
            #[inline]
            pub fn en1(&mut self) -> _EN1W {
                _EN1W { w: self }
            }
            #[doc = "Bit 1 - DAC channel1 output buffer disable"]
            #[inline]
            pub fn boff1(&mut self) -> _BOFF1W {
                _BOFF1W { w: self }
            }
            #[doc = "Bit 2 - DAC channel1 trigger enable"]
            #[inline]
            pub fn ten1(&mut self) -> _TEN1W {
                _TEN1W { w: self }
            }
            #[doc = "Bits 3:5 - DAC channel1 trigger selection"]
            #[inline]
            pub fn tsel1(&mut self) -> _TSEL1W {
                _TSEL1W { w: self }
            }
            #[doc = "Bits 6:7 - DAC channel1 noise/triangle wave generation enable"]
            #[inline]
            pub fn wave1(&mut self) -> _WAVE1W {
                _WAVE1W { w: self }
            }
            #[doc = "Bits 8:11 - DAC channel1 mask/amplitude selector"]
            #[inline]
            pub fn mamp1(&mut self) -> _MAMP1W {
                _MAMP1W { w: self }
            }
            #[doc = "Bit 12 - DAC channel1 DMA enable"]
            #[inline]
            pub fn dmaen1(&mut self) -> _DMAEN1W {
                _DMAEN1W { w: self }
            }
            #[doc = "Bit 16 - DAC channel2 enable"]
            #[inline]
            pub fn en2(&mut self) -> _EN2W {
                _EN2W { w: self }
            }
            #[doc = "Bit 17 - DAC channel2 output buffer disable"]
            #[inline]
            pub fn boff2(&mut self) -> _BOFF2W {
                _BOFF2W { w: self }
            }
            #[doc = "Bit 18 - DAC channel2 trigger enable"]
            #[inline]
            pub fn ten2(&mut self) -> _TEN2W {
                _TEN2W { w: self }
            }
            #[doc = "Bits 19:21 - DAC channel2 trigger selection"]
            #[inline]
            pub fn tsel2(&mut self) -> _TSEL2W {
                _TSEL2W { w: self }
            }
            #[doc = "Bits 22:23 - DAC channel2 noise/triangle wave generation enable"]
            #[inline]
            pub fn wave2(&mut self) -> _WAVE2W {
                _WAVE2W { w: self }
            }
            #[doc = "Bits 24:27 - DAC channel2 mask/amplitude selector"]
            #[inline]
            pub fn mamp2(&mut self) -> _MAMP2W {
                _MAMP2W { w: self }
            }
            #[doc = "Bit 28 - DAC channel2 DMA enable"]
            #[inline]
            pub fn dmaen2(&mut self) -> _DMAEN2W {
                _DMAEN2W { w: self }
            }
            #[doc = "Bit 13 - DAC channel1 DMA underrun interrupt enable"]
            #[inline]
            pub fn dmaudrie1(&mut self) -> _DMAUDRIE1W {
                _DMAUDRIE1W { w: self }
            }
            #[doc = "Bit 29 - DAC channel2 DMA underrun interrupt enable"]
            #[inline]
            pub fn dmaudrie2(&mut self) -> _DMAUDRIE2W {
                _DMAUDRIE2W { w: self }
            }
        }
    }
    #[doc = "DAC software trigger register (DAC_SWTRIGR)"]
    pub struct SWTRIGR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DAC software trigger register (DAC_SWTRIGR)"]
    pub mod swtrigr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SWTRIGR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Values that can be written to the field `SWTRIG1`"]
        pub enum SWTRIG1W {
            #[doc = "DAC channel1 software trigger disabled"]
            DISABLED,
            #[doc = "DAC channel1 software trigger enabled"]
            ENABLED,
        }
        impl SWTRIG1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SWTRIG1W::DISABLED => false,
                    SWTRIG1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWTRIG1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWTRIG1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SWTRIG1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "DAC channel1 software trigger disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SWTRIG1W::DISABLED)
            }
            #[doc = "DAC channel1 software trigger enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SWTRIG1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWTRIG2`"]
        pub enum SWTRIG2W {
            #[doc = "DAC channel2 software trigger disabled"]
            DISABLED,
            #[doc = "DAC channel2 software trigger enabled"]
            ENABLED,
        }
        impl SWTRIG2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SWTRIG2W::DISABLED => false,
                    SWTRIG2W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWTRIG2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWTRIG2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SWTRIG2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "DAC channel2 software trigger disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SWTRIG2W::DISABLED)
            }
            #[doc = "DAC channel2 software trigger enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SWTRIG2W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - DAC channel1 software trigger"]
            #[inline]
            pub fn swtrig1(&mut self) -> _SWTRIG1W {
                _SWTRIG1W { w: self }
            }
            #[doc = "Bit 1 - DAC channel2 software trigger"]
            #[inline]
            pub fn swtrig2(&mut self) -> _SWTRIG2W {
                _SWTRIG2W { w: self }
            }
        }
    }
    #[doc = "DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)"]
    pub struct DHR12R1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)"]
    pub mod dhr12r1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DHR12R1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DACC1DHRR {
            bits: u16,
        }
        impl DACC1DHRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DACC1DHRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DACC1DHRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data"]
            #[inline]
            pub fn dacc1dhr(&self) -> DACC1DHRR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DACC1DHRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data"]
            #[inline]
            pub fn dacc1dhr(&mut self) -> _DACC1DHRW {
                _DACC1DHRW { w: self }
            }
        }
    }
    #[doc = "DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)"]
    pub struct DHR12L1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)"]
    pub mod dhr12l1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DHR12L1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DACC1DHRR {
            bits: u16,
        }
        impl DACC1DHRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DACC1DHRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DACC1DHRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data"]
            #[inline]
            pub fn dacc1dhr(&self) -> DACC1DHRR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DACC1DHRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data"]
            #[inline]
            pub fn dacc1dhr(&mut self) -> _DACC1DHRW {
                _DACC1DHRW { w: self }
            }
        }
    }
    #[doc = "DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)"]
    pub struct DHR8R1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)"]
    pub mod dhr8r1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DHR8R1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DACC1DHRR {
            bits: u8,
        }
        impl DACC1DHRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DACC1DHRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DACC1DHRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data"]
            #[inline]
            pub fn dacc1dhr(&self) -> DACC1DHRR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DACC1DHRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data"]
            #[inline]
            pub fn dacc1dhr(&mut self) -> _DACC1DHRW {
                _DACC1DHRW { w: self }
            }
        }
    }
    #[doc = "DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)"]
    pub struct DHR12R2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)"]
    pub mod dhr12r2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DHR12R2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DACC2DHRR {
            bits: u16,
        }
        impl DACC2DHRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DACC2DHRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DACC2DHRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - DAC channel2 12-bit right-aligned data"]
            #[inline]
            pub fn dacc2dhr(&self) -> DACC2DHRR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DACC2DHRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - DAC channel2 12-bit right-aligned data"]
            #[inline]
            pub fn dacc2dhr(&mut self) -> _DACC2DHRW {
                _DACC2DHRW { w: self }
            }
        }
    }
    #[doc = "DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)"]
    pub struct DHR12L2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)"]
    pub mod dhr12l2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DHR12L2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DACC2DHRR {
            bits: u16,
        }
        impl DACC2DHRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DACC2DHRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DACC2DHRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:15 - DAC channel2 12-bit left-aligned data"]
            #[inline]
            pub fn dacc2dhr(&self) -> DACC2DHRR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DACC2DHRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:15 - DAC channel2 12-bit left-aligned data"]
            #[inline]
            pub fn dacc2dhr(&mut self) -> _DACC2DHRW {
                _DACC2DHRW { w: self }
            }
        }
    }
    #[doc = "DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)"]
    pub struct DHR8R2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)"]
    pub mod dhr8r2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DHR8R2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DACC2DHRR {
            bits: u8,
        }
        impl DACC2DHRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DACC2DHRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DACC2DHRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - DAC channel2 8-bit right-aligned data"]
            #[inline]
            pub fn dacc2dhr(&self) -> DACC2DHRR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DACC2DHRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - DAC channel2 8-bit right-aligned data"]
            #[inline]
            pub fn dacc2dhr(&mut self) -> _DACC2DHRW {
                _DACC2DHRW { w: self }
            }
        }
    }
    #[doc = "Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved"]
    pub struct DHR12RD {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved"]
    pub mod dhr12rd {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DHR12RD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DACC1DHRR {
            bits: u16,
        }
        impl DACC1DHRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DACC2DHRR {
            bits: u16,
        }
        impl DACC2DHRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DACC1DHRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DACC1DHRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DACC2DHRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DACC2DHRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data"]
            #[inline]
            pub fn dacc1dhr(&self) -> DACC1DHRR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DACC1DHRR { bits }
            }
            #[doc = "Bits 16:27 - DAC channel2 12-bit right-aligned data"]
            #[inline]
            pub fn dacc2dhr(&self) -> DACC2DHRR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DACC2DHRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data"]
            #[inline]
            pub fn dacc1dhr(&mut self) -> _DACC1DHRW {
                _DACC1DHRW { w: self }
            }
            #[doc = "Bits 16:27 - DAC channel2 12-bit right-aligned data"]
            #[inline]
            pub fn dacc2dhr(&mut self) -> _DACC2DHRW {
                _DACC2DHRW { w: self }
            }
        }
    }
    #[doc = "DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved"]
    pub struct DHR12LD {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved"]
    pub mod dhr12ld {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DHR12LD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DACC1DHRR {
            bits: u16,
        }
        impl DACC1DHRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DACC2DHRR {
            bits: u16,
        }
        impl DACC2DHRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DACC1DHRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DACC1DHRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DACC2DHRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DACC2DHRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data"]
            #[inline]
            pub fn dacc1dhr(&self) -> DACC1DHRR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DACC1DHRR { bits }
            }
            #[doc = "Bits 20:31 - DAC channel2 12-bit right-aligned data"]
            #[inline]
            pub fn dacc2dhr(&self) -> DACC2DHRR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DACC2DHRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data"]
            #[inline]
            pub fn dacc1dhr(&mut self) -> _DACC1DHRW {
                _DACC1DHRW { w: self }
            }
            #[doc = "Bits 20:31 - DAC channel2 12-bit right-aligned data"]
            #[inline]
            pub fn dacc2dhr(&mut self) -> _DACC2DHRW {
                _DACC2DHRW { w: self }
            }
        }
    }
    #[doc = "DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved"]
    pub struct DHR8RD {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved"]
    pub mod dhr8rd {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DHR8RD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DACC1DHRR {
            bits: u8,
        }
        impl DACC1DHRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DACC2DHRR {
            bits: u8,
        }
        impl DACC2DHRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DACC1DHRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DACC1DHRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DACC2DHRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DACC2DHRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data"]
            #[inline]
            pub fn dacc1dhr(&self) -> DACC1DHRR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DACC1DHRR { bits }
            }
            #[doc = "Bits 8:15 - DAC channel2 8-bit right-aligned data"]
            #[inline]
            pub fn dacc2dhr(&self) -> DACC2DHRR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DACC2DHRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data"]
            #[inline]
            pub fn dacc1dhr(&mut self) -> _DACC1DHRW {
                _DACC1DHRW { w: self }
            }
            #[doc = "Bits 8:15 - DAC channel2 8-bit right-aligned data"]
            #[inline]
            pub fn dacc2dhr(&mut self) -> _DACC2DHRW {
                _DACC2DHRW { w: self }
            }
        }
    }
    #[doc = "DAC channel1 data output register (DAC_DOR1)"]
    pub struct DOR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DAC channel1 data output register (DAC_DOR1)"]
    pub mod dor1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DOR1 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct DACC1DORR {
            bits: u16,
        }
        impl DACC1DORR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - DAC channel1 data output"]
            #[inline]
            pub fn dacc1dor(&self) -> DACC1DORR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DACC1DORR { bits }
            }
        }
    }
    #[doc = "DAC channel2 data output register (DAC_DOR2)"]
    pub struct DOR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DAC channel2 data output register (DAC_DOR2)"]
    pub mod dor2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DOR2 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct DACC2DORR {
            bits: u16,
        }
        impl DACC2DORR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - DAC channel2 data output"]
            #[inline]
            pub fn dacc2dor(&self) -> DACC2DORR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DACC2DORR { bits }
            }
        }
    }
    #[doc = "DAC status register"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DAC status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `DMAUDR1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAUDR1R {
            #[doc = "No DMA underrun error condition occurred for DAC channel1"]
            NOUNDERRUN,
            #[doc = "DMA underrun error condition occurred for DAC channel1"]
            UNDERRUN,
        }
        impl DMAUDR1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DMAUDR1R::NOUNDERRUN => false,
                    DMAUDR1R::UNDERRUN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DMAUDR1R {
                match value {
                    false => DMAUDR1R::NOUNDERRUN,
                    true => DMAUDR1R::UNDERRUN,
                }
            }
            #[doc = "Checks if the value of the field is `NOUNDERRUN`"]
            #[inline]
            pub fn is_no_underrun(&self) -> bool {
                *self == DMAUDR1R::NOUNDERRUN
            }
            #[doc = "Checks if the value of the field is `UNDERRUN`"]
            #[inline]
            pub fn is_underrun(&self) -> bool {
                *self == DMAUDR1R::UNDERRUN
            }
        }
        #[doc = "Possible values of the field `DMAUDR2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAUDR2R {
            #[doc = "No DMA underrun error condition occurred for DAC channel2"]
            NOUNDERRUN,
            #[doc = "DMA underrun error condition occurred for DAC channel2"]
            UNDERRUN,
        }
        impl DMAUDR2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DMAUDR2R::NOUNDERRUN => false,
                    DMAUDR2R::UNDERRUN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DMAUDR2R {
                match value {
                    false => DMAUDR2R::NOUNDERRUN,
                    true => DMAUDR2R::UNDERRUN,
                }
            }
            #[doc = "Checks if the value of the field is `NOUNDERRUN`"]
            #[inline]
            pub fn is_no_underrun(&self) -> bool {
                *self == DMAUDR2R::NOUNDERRUN
            }
            #[doc = "Checks if the value of the field is `UNDERRUN`"]
            #[inline]
            pub fn is_underrun(&self) -> bool {
                *self == DMAUDR2R::UNDERRUN
            }
        }
        #[doc = "Values that can be written to the field `DMAUDR1`"]
        pub enum DMAUDR1W {
            #[doc = "No DMA underrun error condition occurred for DAC channel1"]
            NOUNDERRUN,
            #[doc = "DMA underrun error condition occurred for DAC channel1"]
            UNDERRUN,
        }
        impl DMAUDR1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DMAUDR1W::NOUNDERRUN => false,
                    DMAUDR1W::UNDERRUN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMAUDR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMAUDR1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMAUDR1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No DMA underrun error condition occurred for DAC channel1"]
            #[inline]
            pub fn no_underrun(self) -> &'a mut W {
                self.variant(DMAUDR1W::NOUNDERRUN)
            }
            #[doc = "DMA underrun error condition occurred for DAC channel1"]
            #[inline]
            pub fn underrun(self) -> &'a mut W {
                self.variant(DMAUDR1W::UNDERRUN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DMAUDR2`"]
        pub enum DMAUDR2W {
            #[doc = "No DMA underrun error condition occurred for DAC channel2"]
            NOUNDERRUN,
            #[doc = "DMA underrun error condition occurred for DAC channel2"]
            UNDERRUN,
        }
        impl DMAUDR2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DMAUDR2W::NOUNDERRUN => false,
                    DMAUDR2W::UNDERRUN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMAUDR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMAUDR2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMAUDR2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No DMA underrun error condition occurred for DAC channel2"]
            #[inline]
            pub fn no_underrun(self) -> &'a mut W {
                self.variant(DMAUDR2W::NOUNDERRUN)
            }
            #[doc = "DMA underrun error condition occurred for DAC channel2"]
            #[inline]
            pub fn underrun(self) -> &'a mut W {
                self.variant(DMAUDR2W::UNDERRUN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 13 - DAC channel1 DMA underrun flag"]
            #[inline]
            pub fn dmaudr1(&self) -> DMAUDR1R {
                DMAUDR1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - DAC channel2 DMA underrun flag"]
            #[inline]
            pub fn dmaudr2(&self) -> DMAUDR2R {
                DMAUDR2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 13 - DAC channel1 DMA underrun flag"]
            #[inline]
            pub fn dmaudr1(&mut self) -> _DMAUDR1W {
                _DMAUDR1W { w: self }
            }
            #[doc = "Bit 29 - DAC channel2 DMA underrun flag"]
            #[inline]
            pub fn dmaudr2(&mut self) -> _DMAUDR2W {
                _DMAUDR2W { w: self }
            }
        }
    }
}
#[doc = "Debug support"]
#[cfg(feature = "dbg")]
pub struct DBG {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "dbg")]
unsafe impl Send for DBG {}
#[cfg(feature = "dbg")]
impl DBG {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const dbg::RegisterBlock {
        0xe004_2000 as *const _
    }
}
#[cfg(feature = "dbg")]
impl Deref for DBG {
    type Target = dbg::RegisterBlock;
    fn deref(&self) -> &dbg::RegisterBlock {
        unsafe { &*DBG::ptr() }
    }
}
#[doc = "Debug support"]
#[cfg(feature = "dbg")]
pub mod dbg {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - DBGMCU_IDCODE"]
        pub idcode: IDCODE,
        #[doc = "0x04 - DBGMCU_CR"]
        pub cr: CR,
    }
    #[doc = "DBGMCU_IDCODE"]
    pub struct IDCODE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DBGMCU_IDCODE"]
    pub mod idcode {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::IDCODE {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct DEV_IDR {
            bits: u16,
        }
        impl DEV_IDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct REV_IDR {
            bits: u16,
        }
        impl REV_IDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - DEV_ID"]
            #[inline]
            pub fn dev_id(&self) -> DEV_IDR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DEV_IDR { bits }
            }
            #[doc = "Bits 16:31 - REV_ID"]
            #[inline]
            pub fn rev_id(&self) -> REV_IDR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                REV_IDR { bits }
            }
        }
    }
    #[doc = "DBGMCU_CR"]
    pub struct CR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DBGMCU_CR"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_SLEEPR {
            bits: bool,
        }
        impl DBG_SLEEPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_STOPR {
            bits: bool,
        }
        impl DBG_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_STANDBYR {
            bits: bool,
        }
        impl DBG_STANDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TRACE_IOENR {
            bits: bool,
        }
        impl TRACE_IOENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TRACE_MODER {
            bits: u8,
        }
        impl TRACE_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_IWDG_STOPR {
            bits: bool,
        }
        impl DBG_IWDG_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_WWDG_STOPR {
            bits: bool,
        }
        impl DBG_WWDG_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_TIM1_STOPR {
            bits: bool,
        }
        impl DBG_TIM1_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_TIM2_STOPR {
            bits: bool,
        }
        impl DBG_TIM2_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_TIM3_STOPR {
            bits: bool,
        }
        impl DBG_TIM3_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_TIM4_STOPR {
            bits: bool,
        }
        impl DBG_TIM4_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_I2C1_SMBUS_TIMEOUTR {
            bits: bool,
        }
        impl DBG_I2C1_SMBUS_TIMEOUTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_I2C2_SMBUS_TIMEOUTR {
            bits: bool,
        }
        impl DBG_I2C2_SMBUS_TIMEOUTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_TIM5_STOPR {
            bits: bool,
        }
        impl DBG_TIM5_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_TIM6_STOPR {
            bits: bool,
        }
        impl DBG_TIM6_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_TIM7_STOPR {
            bits: bool,
        }
        impl DBG_TIM7_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_TIM15_STOPR {
            bits: bool,
        }
        impl DBG_TIM15_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_TIM16_STOPR {
            bits: bool,
        }
        impl DBG_TIM16_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_TIM17_STOPR {
            bits: bool,
        }
        impl DBG_TIM17_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_TIM12_STOPR {
            bits: bool,
        }
        impl DBG_TIM12_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_TIM13_STOPR {
            bits: bool,
        }
        impl DBG_TIM13_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBG_TIM14_STOPR {
            bits: bool,
        }
        impl DBG_TIM14_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_SLEEPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_SLEEPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_STANDBYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_STANDBYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRACE_IOENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRACE_IOENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRACE_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRACE_MODEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_IWDG_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_IWDG_STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_WWDG_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_WWDG_STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_TIM1_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_TIM1_STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_TIM2_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_TIM2_STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_TIM3_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_TIM3_STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_TIM4_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_TIM4_STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_I2C1_SMBUS_TIMEOUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_I2C1_SMBUS_TIMEOUTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_I2C2_SMBUS_TIMEOUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_I2C2_SMBUS_TIMEOUTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_TIM5_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_TIM5_STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_TIM6_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_TIM6_STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_TIM7_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_TIM7_STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_TIM15_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_TIM15_STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_TIM16_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_TIM16_STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_TIM17_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_TIM17_STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_TIM12_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_TIM12_STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_TIM13_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_TIM13_STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBG_TIM14_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBG_TIM14_STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - DBG_SLEEP"]
            #[inline]
            pub fn dbg_sleep(&self) -> DBG_SLEEPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_SLEEPR { bits }
            }
            #[doc = "Bit 1 - DBG_STOP"]
            #[inline]
            pub fn dbg_stop(&self) -> DBG_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_STOPR { bits }
            }
            #[doc = "Bit 2 - DBG_STANDBY"]
            #[inline]
            pub fn dbg_standby(&self) -> DBG_STANDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_STANDBYR { bits }
            }
            #[doc = "Bit 5 - TRACE_IOEN"]
            #[inline]
            pub fn trace_ioen(&self) -> TRACE_IOENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TRACE_IOENR { bits }
            }
            #[doc = "Bits 6:7 - TRACE_MODE"]
            #[inline]
            pub fn trace_mode(&self) -> TRACE_MODER {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TRACE_MODER { bits }
            }
            #[doc = "Bit 8 - DBG_IWDG_STOP"]
            #[inline]
            pub fn dbg_iwdg_stop(&self) -> DBG_IWDG_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_IWDG_STOPR { bits }
            }
            #[doc = "Bit 9 - DBG_WWDG_STOP"]
            #[inline]
            pub fn dbg_wwdg_stop(&self) -> DBG_WWDG_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_WWDG_STOPR { bits }
            }
            #[doc = "Bit 10 - DBG_TIM1_STOP"]
            #[inline]
            pub fn dbg_tim1_stop(&self) -> DBG_TIM1_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_TIM1_STOPR { bits }
            }
            #[doc = "Bit 11 - DBG_TIM2_STOP"]
            #[inline]
            pub fn dbg_tim2_stop(&self) -> DBG_TIM2_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_TIM2_STOPR { bits }
            }
            #[doc = "Bit 12 - DBG_TIM3_STOP"]
            #[inline]
            pub fn dbg_tim3_stop(&self) -> DBG_TIM3_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_TIM3_STOPR { bits }
            }
            #[doc = "Bit 13 - DBG_TIM4_STOP"]
            #[inline]
            pub fn dbg_tim4_stop(&self) -> DBG_TIM4_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_TIM4_STOPR { bits }
            }
            #[doc = "Bit 15 - DBG_I2C1_SMBUS_TIMEOUT"]
            #[inline]
            pub fn dbg_i2c1_smbus_timeout(&self) -> DBG_I2C1_SMBUS_TIMEOUTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_I2C1_SMBUS_TIMEOUTR { bits }
            }
            #[doc = "Bit 16 - DBG_I2C2_SMBUS_TIMEOUT"]
            #[inline]
            pub fn dbg_i2c2_smbus_timeout(&self) -> DBG_I2C2_SMBUS_TIMEOUTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_I2C2_SMBUS_TIMEOUTR { bits }
            }
            #[doc = "Bit 18 - DBG_TIM5_STOP"]
            #[inline]
            pub fn dbg_tim5_stop(&self) -> DBG_TIM5_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_TIM5_STOPR { bits }
            }
            #[doc = "Bit 19 - DBG_TIM6_STOP"]
            #[inline]
            pub fn dbg_tim6_stop(&self) -> DBG_TIM6_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_TIM6_STOPR { bits }
            }
            #[doc = "Bit 20 - DBG_TIM7_STOP"]
            #[inline]
            pub fn dbg_tim7_stop(&self) -> DBG_TIM7_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_TIM7_STOPR { bits }
            }
            #[doc = "Bit 22 - DBG_TIM15_STOP"]
            #[inline]
            pub fn dbg_tim15_stop(&self) -> DBG_TIM15_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_TIM15_STOPR { bits }
            }
            #[doc = "Bit 23 - DBG_TIM16_STOP"]
            #[inline]
            pub fn dbg_tim16_stop(&self) -> DBG_TIM16_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_TIM16_STOPR { bits }
            }
            #[doc = "Bit 24 - DBG_TIM17_STOP"]
            #[inline]
            pub fn dbg_tim17_stop(&self) -> DBG_TIM17_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_TIM17_STOPR { bits }
            }
            #[doc = "Bit 25 - DBG_TIM12_STOP"]
            #[inline]
            pub fn dbg_tim12_stop(&self) -> DBG_TIM12_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_TIM12_STOPR { bits }
            }
            #[doc = "Bit 26 - DBG_TIM13_STOP"]
            #[inline]
            pub fn dbg_tim13_stop(&self) -> DBG_TIM13_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_TIM13_STOPR { bits }
            }
            #[doc = "Bit 27 - DBG_TIM14_STOP"]
            #[inline]
            pub fn dbg_tim14_stop(&self) -> DBG_TIM14_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DBG_TIM14_STOPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - DBG_SLEEP"]
            #[inline]
            pub fn dbg_sleep(&mut self) -> _DBG_SLEEPW {
                _DBG_SLEEPW { w: self }
            }
            #[doc = "Bit 1 - DBG_STOP"]
            #[inline]
            pub fn dbg_stop(&mut self) -> _DBG_STOPW {
                _DBG_STOPW { w: self }
            }
            #[doc = "Bit 2 - DBG_STANDBY"]
            #[inline]
            pub fn dbg_standby(&mut self) -> _DBG_STANDBYW {
                _DBG_STANDBYW { w: self }
            }
            #[doc = "Bit 5 - TRACE_IOEN"]
            #[inline]
            pub fn trace_ioen(&mut self) -> _TRACE_IOENW {
                _TRACE_IOENW { w: self }
            }
            #[doc = "Bits 6:7 - TRACE_MODE"]
            #[inline]
            pub fn trace_mode(&mut self) -> _TRACE_MODEW {
                _TRACE_MODEW { w: self }
            }
            #[doc = "Bit 8 - DBG_IWDG_STOP"]
            #[inline]
            pub fn dbg_iwdg_stop(&mut self) -> _DBG_IWDG_STOPW {
                _DBG_IWDG_STOPW { w: self }
            }
            #[doc = "Bit 9 - DBG_WWDG_STOP"]
            #[inline]
            pub fn dbg_wwdg_stop(&mut self) -> _DBG_WWDG_STOPW {
                _DBG_WWDG_STOPW { w: self }
            }
            #[doc = "Bit 10 - DBG_TIM1_STOP"]
            #[inline]
            pub fn dbg_tim1_stop(&mut self) -> _DBG_TIM1_STOPW {
                _DBG_TIM1_STOPW { w: self }
            }
            #[doc = "Bit 11 - DBG_TIM2_STOP"]
            #[inline]
            pub fn dbg_tim2_stop(&mut self) -> _DBG_TIM2_STOPW {
                _DBG_TIM2_STOPW { w: self }
            }
            #[doc = "Bit 12 - DBG_TIM3_STOP"]
            #[inline]
            pub fn dbg_tim3_stop(&mut self) -> _DBG_TIM3_STOPW {
                _DBG_TIM3_STOPW { w: self }
            }
            #[doc = "Bit 13 - DBG_TIM4_STOP"]
            #[inline]
            pub fn dbg_tim4_stop(&mut self) -> _DBG_TIM4_STOPW {
                _DBG_TIM4_STOPW { w: self }
            }
            #[doc = "Bit 15 - DBG_I2C1_SMBUS_TIMEOUT"]
            #[inline]
            pub fn dbg_i2c1_smbus_timeout(&mut self) -> _DBG_I2C1_SMBUS_TIMEOUTW {
                _DBG_I2C1_SMBUS_TIMEOUTW { w: self }
            }
            #[doc = "Bit 16 - DBG_I2C2_SMBUS_TIMEOUT"]
            #[inline]
            pub fn dbg_i2c2_smbus_timeout(&mut self) -> _DBG_I2C2_SMBUS_TIMEOUTW {
                _DBG_I2C2_SMBUS_TIMEOUTW { w: self }
            }
            #[doc = "Bit 18 - DBG_TIM5_STOP"]
            #[inline]
            pub fn dbg_tim5_stop(&mut self) -> _DBG_TIM5_STOPW {
                _DBG_TIM5_STOPW { w: self }
            }
            #[doc = "Bit 19 - DBG_TIM6_STOP"]
            #[inline]
            pub fn dbg_tim6_stop(&mut self) -> _DBG_TIM6_STOPW {
                _DBG_TIM6_STOPW { w: self }
            }
            #[doc = "Bit 20 - DBG_TIM7_STOP"]
            #[inline]
            pub fn dbg_tim7_stop(&mut self) -> _DBG_TIM7_STOPW {
                _DBG_TIM7_STOPW { w: self }
            }
            #[doc = "Bit 22 - DBG_TIM15_STOP"]
            #[inline]
            pub fn dbg_tim15_stop(&mut self) -> _DBG_TIM15_STOPW {
                _DBG_TIM15_STOPW { w: self }
            }
            #[doc = "Bit 23 - DBG_TIM16_STOP"]
            #[inline]
            pub fn dbg_tim16_stop(&mut self) -> _DBG_TIM16_STOPW {
                _DBG_TIM16_STOPW { w: self }
            }
            #[doc = "Bit 24 - DBG_TIM17_STOP"]
            #[inline]
            pub fn dbg_tim17_stop(&mut self) -> _DBG_TIM17_STOPW {
                _DBG_TIM17_STOPW { w: self }
            }
            #[doc = "Bit 25 - DBG_TIM12_STOP"]
            #[inline]
            pub fn dbg_tim12_stop(&mut self) -> _DBG_TIM12_STOPW {
                _DBG_TIM12_STOPW { w: self }
            }
            #[doc = "Bit 26 - DBG_TIM13_STOP"]
            #[inline]
            pub fn dbg_tim13_stop(&mut self) -> _DBG_TIM13_STOPW {
                _DBG_TIM13_STOPW { w: self }
            }
            #[doc = "Bit 27 - DBG_TIM14_STOP"]
            #[inline]
            pub fn dbg_tim14_stop(&mut self) -> _DBG_TIM14_STOPW {
                _DBG_TIM14_STOPW { w: self }
            }
        }
    }
}
#[doc = "Universal asynchronous receiver transmitter"]
#[cfg(feature = "uart4")]
pub struct UART4 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "uart4")]
unsafe impl Send for UART4 {}
#[cfg(feature = "uart4")]
impl UART4 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const uart4::RegisterBlock {
        0x4000_4c00 as *const _
    }
}
#[cfg(feature = "uart4")]
impl Deref for UART4 {
    type Target = uart4::RegisterBlock;
    fn deref(&self) -> &uart4::RegisterBlock {
        unsafe { &*UART4::ptr() }
    }
}
#[doc = "Universal asynchronous receiver transmitter"]
#[cfg(feature = "uart4")]
pub mod uart4 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Status register"]
        pub sr: SR,
        #[doc = "0x04 - Data register"]
        pub dr: DR,
        #[doc = "0x08 - Baud rate register"]
        pub brr: BRR,
        #[doc = "0x0c - Control register 1"]
        pub cr1: CR1,
        #[doc = "0x10 - Control register 2"]
        pub cr2: CR2,
        #[doc = "0x14 - Control register 3"]
        pub cr3: CR3,
    }
    #[doc = "Status register"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PER {
            bits: bool,
        }
        impl PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FER {
            bits: bool,
        }
        impl FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NER {
            bits: bool,
        }
        impl NER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ORER {
            bits: bool,
        }
        impl ORER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDLER {
            bits: bool,
        }
        impl IDLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXNER {
            bits: bool,
        }
        impl RXNER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCR {
            bits: bool,
        }
        impl TCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXER {
            bits: bool,
        }
        impl TXER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LBDR {
            bits: bool,
        }
        impl LBDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXNEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXNEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LBDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LBDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Parity error"]
            #[inline]
            pub fn pe(&self) -> PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PER { bits }
            }
            #[doc = "Bit 1 - Framing error"]
            #[inline]
            pub fn fe(&self) -> FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FER { bits }
            }
            #[doc = "Bit 2 - Noise error flag"]
            #[inline]
            pub fn ne(&self) -> NER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NER { bits }
            }
            #[doc = "Bit 3 - Overrun error"]
            #[inline]
            pub fn ore(&self) -> ORER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ORER { bits }
            }
            #[doc = "Bit 4 - IDLE line detected"]
            #[inline]
            pub fn idle(&self) -> IDLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IDLER { bits }
            }
            #[doc = "Bit 5 - Read data register not empty"]
            #[inline]
            pub fn rxne(&self) -> RXNER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXNER { bits }
            }
            #[doc = "Bit 6 - Transmission complete"]
            #[inline]
            pub fn tc(&self) -> TCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TCR { bits }
            }
            #[doc = "Bit 7 - Transmit data register empty"]
            #[inline]
            pub fn txe(&self) -> TXER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXER { bits }
            }
            #[doc = "Bit 8 - LIN break detection flag"]
            #[inline]
            pub fn lbd(&self) -> LBDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LBDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 5 - Read data register not empty"]
            #[inline]
            pub fn rxne(&mut self) -> _RXNEW {
                _RXNEW { w: self }
            }
            #[doc = "Bit 6 - Transmission complete"]
            #[inline]
            pub fn tc(&mut self) -> _TCW {
                _TCW { w: self }
            }
            #[doc = "Bit 8 - LIN break detection flag"]
            #[inline]
            pub fn lbd(&mut self) -> _LBDW {
                _LBDW { w: self }
            }
        }
    }
    #[doc = "Data register"]
    pub struct DR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Data register"]
    pub mod dr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DRR {
            bits: u16,
        }
        impl DRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x01ff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:8 - DR"]
            #[inline]
            pub fn dr(&self) -> DRR {
                let bits = {
                    const MASK: u16 = 0x01ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:8 - DR"]
            #[inline]
            pub fn dr(&mut self) -> _DRW {
                _DRW { w: self }
            }
        }
    }
    #[doc = "Baud rate register"]
    pub struct BRR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Baud rate register"]
    pub mod brr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BRR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIV_FRACTIONR {
            bits: u8,
        }
        impl DIV_FRACTIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIV_MANTISSAR {
            bits: u16,
        }
        impl DIV_MANTISSAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIV_FRACTIONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIV_FRACTIONW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIV_MANTISSAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIV_MANTISSAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - DIV_Fraction"]
            #[inline]
            pub fn div_fraction(&self) -> DIV_FRACTIONR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIV_FRACTIONR { bits }
            }
            #[doc = "Bits 4:15 - DIV_Mantissa"]
            #[inline]
            pub fn div_mantissa(&self) -> DIV_MANTISSAR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DIV_MANTISSAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - DIV_Fraction"]
            #[inline]
            pub fn div_fraction(&mut self) -> _DIV_FRACTIONW {
                _DIV_FRACTIONW { w: self }
            }
            #[doc = "Bits 4:15 - DIV_Mantissa"]
            #[inline]
            pub fn div_mantissa(&mut self) -> _DIV_MANTISSAW {
                _DIV_MANTISSAW { w: self }
            }
        }
    }
    #[doc = "Control register 1"]
    pub struct CR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SBKR {
            bits: bool,
        }
        impl SBKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RWUR {
            bits: bool,
        }
        impl RWUR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RER {
            bits: bool,
        }
        impl RER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TER {
            bits: bool,
        }
        impl TER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDLEIER {
            bits: bool,
        }
        impl IDLEIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXNEIER {
            bits: bool,
        }
        impl RXNEIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCIER {
            bits: bool,
        }
        impl TCIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXEIER {
            bits: bool,
        }
        impl TXEIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PEIER {
            bits: bool,
        }
        impl PEIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PSR {
            bits: bool,
        }
        impl PSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PCER {
            bits: bool,
        }
        impl PCER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKER {
            bits: bool,
        }
        impl WAKER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR {
            bits: bool,
        }
        impl MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct UER {
            bits: bool,
        }
        impl UER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SBKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SBKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RWUW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RWUW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _REW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDLEIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDLEIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXNEIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXNEIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXEIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXEIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PEIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PEIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PCEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PCEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Send break"]
            #[inline]
            pub fn sbk(&self) -> SBKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SBKR { bits }
            }
            #[doc = "Bit 1 - Receiver wakeup"]
            #[inline]
            pub fn rwu(&self) -> RWUR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RWUR { bits }
            }
            #[doc = "Bit 2 - Receiver enable"]
            #[inline]
            pub fn re(&self) -> RER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RER { bits }
            }
            #[doc = "Bit 3 - Transmitter enable"]
            #[inline]
            pub fn te(&self) -> TER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TER { bits }
            }
            #[doc = "Bit 4 - IDLE interrupt enable"]
            #[inline]
            pub fn idleie(&self) -> IDLEIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IDLEIER { bits }
            }
            #[doc = "Bit 5 - RXNE interrupt enable"]
            #[inline]
            pub fn rxneie(&self) -> RXNEIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXNEIER { bits }
            }
            #[doc = "Bit 6 - Transmission complete interrupt enable"]
            #[inline]
            pub fn tcie(&self) -> TCIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TCIER { bits }
            }
            #[doc = "Bit 7 - TXE interrupt enable"]
            #[inline]
            pub fn txeie(&self) -> TXEIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXEIER { bits }
            }
            #[doc = "Bit 8 - PE interrupt enable"]
            #[inline]
            pub fn peie(&self) -> PEIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PEIER { bits }
            }
            #[doc = "Bit 9 - Parity selection"]
            #[inline]
            pub fn ps(&self) -> PSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PSR { bits }
            }
            #[doc = "Bit 10 - Parity control enable"]
            #[inline]
            pub fn pce(&self) -> PCER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PCER { bits }
            }
            #[doc = "Bit 11 - Wakeup method"]
            #[inline]
            pub fn wake(&self) -> WAKER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKER { bits }
            }
            #[doc = "Bit 12 - Word length"]
            #[inline]
            pub fn m(&self) -> MR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR { bits }
            }
            #[doc = "Bit 13 - USART enable"]
            #[inline]
            pub fn ue(&self) -> UER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                UER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Send break"]
            #[inline]
            pub fn sbk(&mut self) -> _SBKW {
                _SBKW { w: self }
            }
            #[doc = "Bit 1 - Receiver wakeup"]
            #[inline]
            pub fn rwu(&mut self) -> _RWUW {
                _RWUW { w: self }
            }
            #[doc = "Bit 2 - Receiver enable"]
            #[inline]
            pub fn re(&mut self) -> _REW {
                _REW { w: self }
            }
            #[doc = "Bit 3 - Transmitter enable"]
            #[inline]
            pub fn te(&mut self) -> _TEW {
                _TEW { w: self }
            }
            #[doc = "Bit 4 - IDLE interrupt enable"]
            #[inline]
            pub fn idleie(&mut self) -> _IDLEIEW {
                _IDLEIEW { w: self }
            }
            #[doc = "Bit 5 - RXNE interrupt enable"]
            #[inline]
            pub fn rxneie(&mut self) -> _RXNEIEW {
                _RXNEIEW { w: self }
            }
            #[doc = "Bit 6 - Transmission complete interrupt enable"]
            #[inline]
            pub fn tcie(&mut self) -> _TCIEW {
                _TCIEW { w: self }
            }
            #[doc = "Bit 7 - TXE interrupt enable"]
            #[inline]
            pub fn txeie(&mut self) -> _TXEIEW {
                _TXEIEW { w: self }
            }
            #[doc = "Bit 8 - PE interrupt enable"]
            #[inline]
            pub fn peie(&mut self) -> _PEIEW {
                _PEIEW { w: self }
            }
            #[doc = "Bit 9 - Parity selection"]
            #[inline]
            pub fn ps(&mut self) -> _PSW {
                _PSW { w: self }
            }
            #[doc = "Bit 10 - Parity control enable"]
            #[inline]
            pub fn pce(&mut self) -> _PCEW {
                _PCEW { w: self }
            }
            #[doc = "Bit 11 - Wakeup method"]
            #[inline]
            pub fn wake(&mut self) -> _WAKEW {
                _WAKEW { w: self }
            }
            #[doc = "Bit 12 - Word length"]
            #[inline]
            pub fn m(&mut self) -> _MW {
                _MW { w: self }
            }
            #[doc = "Bit 13 - USART enable"]
            #[inline]
            pub fn ue(&mut self) -> _UEW {
                _UEW { w: self }
            }
        }
    }
    #[doc = "Control register 2"]
    pub struct CR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDR {
            bits: u8,
        }
        impl ADDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LBDLR {
            bits: bool,
        }
        impl LBDLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LBDIER {
            bits: bool,
        }
        impl LBDIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOPR {
            bits: u8,
        }
        impl STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LINENR {
            bits: bool,
        }
        impl LINENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LBDLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LBDLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LBDIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LBDIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LINENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LINENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Address of the USART node"]
            #[inline]
            pub fn add(&self) -> ADDR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADDR { bits }
            }
            #[doc = "Bit 5 - lin break detection length"]
            #[inline]
            pub fn lbdl(&self) -> LBDLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LBDLR { bits }
            }
            #[doc = "Bit 6 - LIN break detection interrupt enable"]
            #[inline]
            pub fn lbdie(&self) -> LBDIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LBDIER { bits }
            }
            #[doc = "Bits 12:13 - STOP bits"]
            #[inline]
            pub fn stop(&self) -> STOPR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STOPR { bits }
            }
            #[doc = "Bit 14 - LIN mode enable"]
            #[inline]
            pub fn linen(&self) -> LINENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LINENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Address of the USART node"]
            #[inline]
            pub fn add(&mut self) -> _ADDW {
                _ADDW { w: self }
            }
            #[doc = "Bit 5 - lin break detection length"]
            #[inline]
            pub fn lbdl(&mut self) -> _LBDLW {
                _LBDLW { w: self }
            }
            #[doc = "Bit 6 - LIN break detection interrupt enable"]
            #[inline]
            pub fn lbdie(&mut self) -> _LBDIEW {
                _LBDIEW { w: self }
            }
            #[doc = "Bits 12:13 - STOP bits"]
            #[inline]
            pub fn stop(&mut self) -> _STOPW {
                _STOPW { w: self }
            }
            #[doc = "Bit 14 - LIN mode enable"]
            #[inline]
            pub fn linen(&mut self) -> _LINENW {
                _LINENW { w: self }
            }
        }
    }
    #[doc = "Control register 3"]
    pub struct CR3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control register 3"]
    pub mod cr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EIER {
            bits: bool,
        }
        impl EIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IRENR {
            bits: bool,
        }
        impl IRENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IRLPR {
            bits: bool,
        }
        impl IRLPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HDSELR {
            bits: bool,
        }
        impl HDSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMARR {
            bits: bool,
        }
        impl DMARR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMATR {
            bits: bool,
        }
        impl DMATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRLPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRLPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HDSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HDSELW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMARW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMARW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMATW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Error interrupt enable"]
            #[inline]
            pub fn eie(&self) -> EIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EIER { bits }
            }
            #[doc = "Bit 1 - IrDA mode enable"]
            #[inline]
            pub fn iren(&self) -> IRENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IRENR { bits }
            }
            #[doc = "Bit 2 - IrDA low-power"]
            #[inline]
            pub fn irlp(&self) -> IRLPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IRLPR { bits }
            }
            #[doc = "Bit 3 - Half-duplex selection"]
            #[inline]
            pub fn hdsel(&self) -> HDSELR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HDSELR { bits }
            }
            #[doc = "Bit 6 - DMA enable receiver"]
            #[inline]
            pub fn dmar(&self) -> DMARR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DMARR { bits }
            }
            #[doc = "Bit 7 - DMA enable transmitter"]
            #[inline]
            pub fn dmat(&self) -> DMATR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DMATR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Error interrupt enable"]
            #[inline]
            pub fn eie(&mut self) -> _EIEW {
                _EIEW { w: self }
            }
            #[doc = "Bit 1 - IrDA mode enable"]
            #[inline]
            pub fn iren(&mut self) -> _IRENW {
                _IRENW { w: self }
            }
            #[doc = "Bit 2 - IrDA low-power"]
            #[inline]
            pub fn irlp(&mut self) -> _IRLPW {
                _IRLPW { w: self }
            }
            #[doc = "Bit 3 - Half-duplex selection"]
            #[inline]
            pub fn hdsel(&mut self) -> _HDSELW {
                _HDSELW { w: self }
            }
            #[doc = "Bit 6 - DMA enable receiver"]
            #[inline]
            pub fn dmar(&mut self) -> _DMARW {
                _DMARW { w: self }
            }
            #[doc = "Bit 7 - DMA enable transmitter"]
            #[inline]
            pub fn dmat(&mut self) -> _DMATW {
                _DMATW { w: self }
            }
        }
    }
}
#[doc = "Universal asynchronous receiver transmitter"]
#[cfg(feature = "uart5")]
pub struct UART5 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "uart5")]
unsafe impl Send for UART5 {}
#[cfg(feature = "uart5")]
impl UART5 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const uart5::RegisterBlock {
        0x4000_5000 as *const _
    }
}
#[cfg(feature = "uart5")]
impl Deref for UART5 {
    type Target = uart5::RegisterBlock;
    fn deref(&self) -> &uart5::RegisterBlock {
        unsafe { &*UART5::ptr() }
    }
}
#[doc = "Universal asynchronous receiver transmitter"]
#[cfg(feature = "uart5")]
pub mod uart5 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Status register"]
        pub sr: SR,
        #[doc = "0x04 - Data register"]
        pub dr: DR,
        #[doc = "0x08 - Baud rate register"]
        pub brr: BRR,
        #[doc = "0x0c - Control register 1"]
        pub cr1: CR1,
        #[doc = "0x10 - Control register 2"]
        pub cr2: CR2,
        #[doc = "0x14 - Control register 3"]
        pub cr3: CR3,
    }
    #[doc = "Status register"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PER {
            bits: bool,
        }
        impl PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FER {
            bits: bool,
        }
        impl FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NER {
            bits: bool,
        }
        impl NER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ORER {
            bits: bool,
        }
        impl ORER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDLER {
            bits: bool,
        }
        impl IDLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXNER {
            bits: bool,
        }
        impl RXNER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCR {
            bits: bool,
        }
        impl TCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXER {
            bits: bool,
        }
        impl TXER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LBDR {
            bits: bool,
        }
        impl LBDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXNEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXNEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LBDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LBDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - PE"]
            #[inline]
            pub fn pe(&self) -> PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PER { bits }
            }
            #[doc = "Bit 1 - FE"]
            #[inline]
            pub fn fe(&self) -> FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FER { bits }
            }
            #[doc = "Bit 2 - NE"]
            #[inline]
            pub fn ne(&self) -> NER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NER { bits }
            }
            #[doc = "Bit 3 - ORE"]
            #[inline]
            pub fn ore(&self) -> ORER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ORER { bits }
            }
            #[doc = "Bit 4 - IDLE"]
            #[inline]
            pub fn idle(&self) -> IDLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IDLER { bits }
            }
            #[doc = "Bit 5 - RXNE"]
            #[inline]
            pub fn rxne(&self) -> RXNER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXNER { bits }
            }
            #[doc = "Bit 6 - TC"]
            #[inline]
            pub fn tc(&self) -> TCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TCR { bits }
            }
            #[doc = "Bit 7 - TXE"]
            #[inline]
            pub fn txe(&self) -> TXER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXER { bits }
            }
            #[doc = "Bit 8 - LBD"]
            #[inline]
            pub fn lbd(&self) -> LBDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LBDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 5 - RXNE"]
            #[inline]
            pub fn rxne(&mut self) -> _RXNEW {
                _RXNEW { w: self }
            }
            #[doc = "Bit 6 - TC"]
            #[inline]
            pub fn tc(&mut self) -> _TCW {
                _TCW { w: self }
            }
            #[doc = "Bit 8 - LBD"]
            #[inline]
            pub fn lbd(&mut self) -> _LBDW {
                _LBDW { w: self }
            }
        }
    }
    #[doc = "Data register"]
    pub struct DR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Data register"]
    pub mod dr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DRR {
            bits: u16,
        }
        impl DRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x01ff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:8 - DR"]
            #[inline]
            pub fn dr(&self) -> DRR {
                let bits = {
                    const MASK: u16 = 0x01ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:8 - DR"]
            #[inline]
            pub fn dr(&mut self) -> _DRW {
                _DRW { w: self }
            }
        }
    }
    #[doc = "Baud rate register"]
    pub struct BRR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Baud rate register"]
    pub mod brr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BRR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIV_FRACTIONR {
            bits: u8,
        }
        impl DIV_FRACTIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIV_MANTISSAR {
            bits: u16,
        }
        impl DIV_MANTISSAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIV_FRACTIONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIV_FRACTIONW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIV_MANTISSAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIV_MANTISSAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - DIV_Fraction"]
            #[inline]
            pub fn div_fraction(&self) -> DIV_FRACTIONR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIV_FRACTIONR { bits }
            }
            #[doc = "Bits 4:15 - DIV_Mantissa"]
            #[inline]
            pub fn div_mantissa(&self) -> DIV_MANTISSAR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DIV_MANTISSAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - DIV_Fraction"]
            #[inline]
            pub fn div_fraction(&mut self) -> _DIV_FRACTIONW {
                _DIV_FRACTIONW { w: self }
            }
            #[doc = "Bits 4:15 - DIV_Mantissa"]
            #[inline]
            pub fn div_mantissa(&mut self) -> _DIV_MANTISSAW {
                _DIV_MANTISSAW { w: self }
            }
        }
    }
    #[doc = "Control register 1"]
    pub struct CR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SBKR {
            bits: bool,
        }
        impl SBKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RWUR {
            bits: bool,
        }
        impl RWUR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RER {
            bits: bool,
        }
        impl RER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TER {
            bits: bool,
        }
        impl TER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDLEIER {
            bits: bool,
        }
        impl IDLEIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXNEIER {
            bits: bool,
        }
        impl RXNEIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCIER {
            bits: bool,
        }
        impl TCIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXEIER {
            bits: bool,
        }
        impl TXEIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PEIER {
            bits: bool,
        }
        impl PEIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PSR {
            bits: bool,
        }
        impl PSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PCER {
            bits: bool,
        }
        impl PCER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAKER {
            bits: bool,
        }
        impl WAKER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR {
            bits: bool,
        }
        impl MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct UER {
            bits: bool,
        }
        impl UER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SBKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SBKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RWUW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RWUW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _REW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDLEIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDLEIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXNEIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXNEIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXEIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXEIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PEIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PEIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PCEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PCEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - SBK"]
            #[inline]
            pub fn sbk(&self) -> SBKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SBKR { bits }
            }
            #[doc = "Bit 1 - RWU"]
            #[inline]
            pub fn rwu(&self) -> RWUR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RWUR { bits }
            }
            #[doc = "Bit 2 - RE"]
            #[inline]
            pub fn re(&self) -> RER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RER { bits }
            }
            #[doc = "Bit 3 - TE"]
            #[inline]
            pub fn te(&self) -> TER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TER { bits }
            }
            #[doc = "Bit 4 - IDLEIE"]
            #[inline]
            pub fn idleie(&self) -> IDLEIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IDLEIER { bits }
            }
            #[doc = "Bit 5 - RXNEIE"]
            #[inline]
            pub fn rxneie(&self) -> RXNEIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXNEIER { bits }
            }
            #[doc = "Bit 6 - TCIE"]
            #[inline]
            pub fn tcie(&self) -> TCIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TCIER { bits }
            }
            #[doc = "Bit 7 - TXEIE"]
            #[inline]
            pub fn txeie(&self) -> TXEIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXEIER { bits }
            }
            #[doc = "Bit 8 - PEIE"]
            #[inline]
            pub fn peie(&self) -> PEIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PEIER { bits }
            }
            #[doc = "Bit 9 - PS"]
            #[inline]
            pub fn ps(&self) -> PSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PSR { bits }
            }
            #[doc = "Bit 10 - PCE"]
            #[inline]
            pub fn pce(&self) -> PCER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PCER { bits }
            }
            #[doc = "Bit 11 - WAKE"]
            #[inline]
            pub fn wake(&self) -> WAKER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WAKER { bits }
            }
            #[doc = "Bit 12 - M"]
            #[inline]
            pub fn m(&self) -> MR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR { bits }
            }
            #[doc = "Bit 13 - UE"]
            #[inline]
            pub fn ue(&self) -> UER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                UER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - SBK"]
            #[inline]
            pub fn sbk(&mut self) -> _SBKW {
                _SBKW { w: self }
            }
            #[doc = "Bit 1 - RWU"]
            #[inline]
            pub fn rwu(&mut self) -> _RWUW {
                _RWUW { w: self }
            }
            #[doc = "Bit 2 - RE"]
            #[inline]
            pub fn re(&mut self) -> _REW {
                _REW { w: self }
            }
            #[doc = "Bit 3 - TE"]
            #[inline]
            pub fn te(&mut self) -> _TEW {
                _TEW { w: self }
            }
            #[doc = "Bit 4 - IDLEIE"]
            #[inline]
            pub fn idleie(&mut self) -> _IDLEIEW {
                _IDLEIEW { w: self }
            }
            #[doc = "Bit 5 - RXNEIE"]
            #[inline]
            pub fn rxneie(&mut self) -> _RXNEIEW {
                _RXNEIEW { w: self }
            }
            #[doc = "Bit 6 - TCIE"]
            #[inline]
            pub fn tcie(&mut self) -> _TCIEW {
                _TCIEW { w: self }
            }
            #[doc = "Bit 7 - TXEIE"]
            #[inline]
            pub fn txeie(&mut self) -> _TXEIEW {
                _TXEIEW { w: self }
            }
            #[doc = "Bit 8 - PEIE"]
            #[inline]
            pub fn peie(&mut self) -> _PEIEW {
                _PEIEW { w: self }
            }
            #[doc = "Bit 9 - PS"]
            #[inline]
            pub fn ps(&mut self) -> _PSW {
                _PSW { w: self }
            }
            #[doc = "Bit 10 - PCE"]
            #[inline]
            pub fn pce(&mut self) -> _PCEW {
                _PCEW { w: self }
            }
            #[doc = "Bit 11 - WAKE"]
            #[inline]
            pub fn wake(&mut self) -> _WAKEW {
                _WAKEW { w: self }
            }
            #[doc = "Bit 12 - M"]
            #[inline]
            pub fn m(&mut self) -> _MW {
                _MW { w: self }
            }
            #[doc = "Bit 13 - UE"]
            #[inline]
            pub fn ue(&mut self) -> _UEW {
                _UEW { w: self }
            }
        }
    }
    #[doc = "Control register 2"]
    pub struct CR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDR {
            bits: u8,
        }
        impl ADDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LBDLR {
            bits: bool,
        }
        impl LBDLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LBDIER {
            bits: bool,
        }
        impl LBDIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOPR {
            bits: u8,
        }
        impl STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LINENR {
            bits: bool,
        }
        impl LINENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LBDLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LBDLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LBDIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LBDIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LINENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LINENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - ADD"]
            #[inline]
            pub fn add(&self) -> ADDR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADDR { bits }
            }
            #[doc = "Bit 5 - LBDL"]
            #[inline]
            pub fn lbdl(&self) -> LBDLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LBDLR { bits }
            }
            #[doc = "Bit 6 - LBDIE"]
            #[inline]
            pub fn lbdie(&self) -> LBDIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LBDIER { bits }
            }
            #[doc = "Bits 12:13 - STOP"]
            #[inline]
            pub fn stop(&self) -> STOPR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STOPR { bits }
            }
            #[doc = "Bit 14 - LINEN"]
            #[inline]
            pub fn linen(&self) -> LINENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LINENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - ADD"]
            #[inline]
            pub fn add(&mut self) -> _ADDW {
                _ADDW { w: self }
            }
            #[doc = "Bit 5 - LBDL"]
            #[inline]
            pub fn lbdl(&mut self) -> _LBDLW {
                _LBDLW { w: self }
            }
            #[doc = "Bit 6 - LBDIE"]
            #[inline]
            pub fn lbdie(&mut self) -> _LBDIEW {
                _LBDIEW { w: self }
            }
            #[doc = "Bits 12:13 - STOP"]
            #[inline]
            pub fn stop(&mut self) -> _STOPW {
                _STOPW { w: self }
            }
            #[doc = "Bit 14 - LINEN"]
            #[inline]
            pub fn linen(&mut self) -> _LINENW {
                _LINENW { w: self }
            }
        }
    }
    #[doc = "Control register 3"]
    pub struct CR3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control register 3"]
    pub mod cr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EIER {
            bits: bool,
        }
        impl EIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IRENR {
            bits: bool,
        }
        impl IRENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IRLPR {
            bits: bool,
        }
        impl IRLPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HDSELR {
            bits: bool,
        }
        impl HDSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMATR {
            bits: bool,
        }
        impl DMATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRLPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRLPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HDSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HDSELW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMATW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Error interrupt enable"]
            #[inline]
            pub fn eie(&self) -> EIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EIER { bits }
            }
            #[doc = "Bit 1 - IrDA mode enable"]
            #[inline]
            pub fn iren(&self) -> IRENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IRENR { bits }
            }
            #[doc = "Bit 2 - IrDA low-power"]
            #[inline]
            pub fn irlp(&self) -> IRLPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IRLPR { bits }
            }
            #[doc = "Bit 3 - Half-duplex selection"]
            #[inline]
            pub fn hdsel(&self) -> HDSELR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HDSELR { bits }
            }
            #[doc = "Bit 7 - DMA enable transmitter"]
            #[inline]
            pub fn dmat(&self) -> DMATR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DMATR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Error interrupt enable"]
            #[inline]
            pub fn eie(&mut self) -> _EIEW {
                _EIEW { w: self }
            }
            #[doc = "Bit 1 - IrDA mode enable"]
            #[inline]
            pub fn iren(&mut self) -> _IRENW {
                _IRENW { w: self }
            }
            #[doc = "Bit 2 - IrDA low-power"]
            #[inline]
            pub fn irlp(&mut self) -> _IRLPW {
                _IRLPW { w: self }
            }
            #[doc = "Bit 3 - Half-duplex selection"]
            #[inline]
            pub fn hdsel(&mut self) -> _HDSELW {
                _HDSELW { w: self }
            }
            #[doc = "Bit 7 - DMA enable transmitter"]
            #[inline]
            pub fn dmat(&mut self) -> _DMATW {
                _DMATW { w: self }
            }
        }
    }
}
#[doc = "CRC calculation unit"]
#[cfg(feature = "crc")]
pub struct CRC {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "crc")]
unsafe impl Send for CRC {}
#[cfg(feature = "crc")]
impl CRC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const crc::RegisterBlock {
        0x4002_3000 as *const _
    }
}
#[cfg(feature = "crc")]
impl Deref for CRC {
    type Target = crc::RegisterBlock;
    fn deref(&self) -> &crc::RegisterBlock {
        unsafe { &*CRC::ptr() }
    }
}
#[doc = "CRC calculation unit"]
#[cfg(feature = "crc")]
pub mod crc {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Data register"]
        pub dr: DR,
        #[doc = "0x04 - Independent Data register"]
        pub idr: IDR,
        #[doc = "0x08 - Control register"]
        pub cr: CR,
    }
    #[doc = "Data register"]
    pub struct DR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Data register"]
    pub mod dr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DRR {
            bits: u32,
        }
        impl DRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Data Register"]
            #[inline]
            pub fn dr(&self) -> DRR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Data Register"]
            #[inline]
            pub fn dr(&mut self) -> _DRW {
                _DRW { w: self }
            }
        }
    }
    #[doc = "Independent Data register"]
    pub struct IDR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Independent Data register"]
    pub mod idr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDRR {
            bits: u8,
        }
        impl IDRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Independent Data register"]
            #[inline]
            pub fn idr(&self) -> IDRR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IDRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Independent Data register"]
            #[inline]
            pub fn idr(&mut self) -> _IDRW {
                _IDRW { w: self }
            }
        }
    }
    #[doc = "Control register"]
    pub struct CR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control register"]
    pub mod cr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Values that can be written to the field `RESET`"]
        pub enum RESETW {
            #[doc = "Resets the CRC calculation unit and sets the data register to 0xFFFF FFFF"]
            RESET,
        }
        impl RESETW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RESETW::RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESETW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RESETW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Resets the CRC calculation unit and sets the data register to 0xFFFF FFFF"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(RESETW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Reset bit"]
            #[inline]
            pub fn reset(&mut self) -> _RESETW {
                _RESETW { w: self }
            }
        }
    }
}
#[doc = "FLASH"]
#[cfg(feature = "flash")]
pub struct FLASH {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "flash")]
unsafe impl Send for FLASH {}
#[cfg(feature = "flash")]
impl FLASH {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const flash::RegisterBlock {
        0x4002_2000 as *const _
    }
}
#[cfg(feature = "flash")]
impl Deref for FLASH {
    type Target = flash::RegisterBlock;
    fn deref(&self) -> &flash::RegisterBlock {
        unsafe { &*FLASH::ptr() }
    }
}
#[doc = "FLASH"]
#[cfg(feature = "flash")]
pub mod flash {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Flash access control register"]
        pub acr: ACR,
        #[doc = "0x04 - Flash key register"]
        pub keyr: KEYR,
        #[doc = "0x08 - Flash option key register"]
        pub optkeyr: OPTKEYR,
        #[doc = "0x0c - Status register"]
        pub sr: SR,
        #[doc = "0x10 - Control register"]
        pub cr: CR,
        #[doc = "0x14 - Flash address register"]
        pub ar: AR,
        _reserved0: [u8; 4usize],
        #[doc = "0x1c - Option byte register"]
        pub obr: OBR,
        #[doc = "0x20 - Write protection register"]
        pub wrpr: WRPR,
    }
    #[doc = "Flash access control register"]
    pub struct ACR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Flash access control register"]
    pub mod acr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ACR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct HLFCYAR {
            bits: bool,
        }
        impl HLFCYAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _HLFCYAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HLFCYAW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 3 - Flash half cycle access enable"]
            #[inline]
            pub fn hlfcya(&self) -> HLFCYAR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HLFCYAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 3 - Flash half cycle access enable"]
            #[inline]
            pub fn hlfcya(&mut self) -> _HLFCYAW {
                _HLFCYAW { w: self }
            }
        }
    }
    #[doc = "Flash key register"]
    pub struct KEYR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Flash key register"]
    pub mod keyr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::KEYR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _KEYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _KEYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - FPEC key"]
            #[inline]
            pub fn key(&mut self) -> _KEYW {
                _KEYW { w: self }
            }
        }
    }
    #[doc = "Flash option key register"]
    pub struct OPTKEYR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Flash option key register"]
    pub mod optkeyr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OPTKEYR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _OPTKEYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OPTKEYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Option byte key"]
            #[inline]
            pub fn optkey(&mut self) -> _OPTKEYW {
                _OPTKEYW { w: self }
            }
        }
    }
    #[doc = "Status register"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EOPR {
            bits: bool,
        }
        impl EOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WRPRTERRR {
            bits: bool,
        }
        impl WRPRTERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGERRR {
            bits: bool,
        }
        impl PGERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BSYR {
            bits: bool,
        }
        impl BSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRPRTERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRPRTERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 5 - End of operation"]
            #[inline]
            pub fn eop(&self) -> EOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EOPR { bits }
            }
            #[doc = "Bit 4 - Write protection error"]
            #[inline]
            pub fn wrprterr(&self) -> WRPRTERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WRPRTERRR { bits }
            }
            #[doc = "Bit 2 - Programming error"]
            #[inline]
            pub fn pgerr(&self) -> PGERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PGERRR { bits }
            }
            #[doc = "Bit 0 - Busy"]
            #[inline]
            pub fn bsy(&self) -> BSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BSYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 5 - End of operation"]
            #[inline]
            pub fn eop(&mut self) -> _EOPW {
                _EOPW { w: self }
            }
            #[doc = "Bit 4 - Write protection error"]
            #[inline]
            pub fn wrprterr(&mut self) -> _WRPRTERRW {
                _WRPRTERRW { w: self }
            }
            #[doc = "Bit 2 - Programming error"]
            #[inline]
            pub fn pgerr(&mut self) -> _PGERRW {
                _PGERRW { w: self }
            }
        }
    }
    #[doc = "Control register"]
    pub struct CR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control register"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PGR {
            bits: bool,
        }
        impl PGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PERR {
            bits: bool,
        }
        impl PERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MERR {
            bits: bool,
        }
        impl MERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OPTPGR {
            bits: bool,
        }
        impl OPTPGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OPTERR {
            bits: bool,
        }
        impl OPTERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STRTR {
            bits: bool,
        }
        impl STRTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LOCKR {
            bits: bool,
        }
        impl LOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OPTWRER {
            bits: bool,
        }
        impl OPTWRER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERRIER {
            bits: bool,
        }
        impl ERRIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EOPIER {
            bits: bool,
        }
        impl EOPIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PERW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MERW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OPTPGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OPTPGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OPTERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OPTERW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STRTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STRTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOCKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OPTWREW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OPTWREW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EOPIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EOPIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Programming"]
            #[inline]
            pub fn pg(&self) -> PGR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PGR { bits }
            }
            #[doc = "Bit 1 - Page Erase"]
            #[inline]
            pub fn per(&self) -> PERR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PERR { bits }
            }
            #[doc = "Bit 2 - Mass Erase"]
            #[inline]
            pub fn mer(&self) -> MERR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MERR { bits }
            }
            #[doc = "Bit 4 - Option byte programming"]
            #[inline]
            pub fn optpg(&self) -> OPTPGR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OPTPGR { bits }
            }
            #[doc = "Bit 5 - Option byte erase"]
            #[inline]
            pub fn opter(&self) -> OPTERR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OPTERR { bits }
            }
            #[doc = "Bit 6 - Start"]
            #[inline]
            pub fn strt(&self) -> STRTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STRTR { bits }
            }
            #[doc = "Bit 7 - Lock"]
            #[inline]
            pub fn lock(&self) -> LOCKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LOCKR { bits }
            }
            #[doc = "Bit 9 - Option bytes write enable"]
            #[inline]
            pub fn optwre(&self) -> OPTWRER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OPTWRER { bits }
            }
            #[doc = "Bit 10 - Error interrupt enable"]
            #[inline]
            pub fn errie(&self) -> ERRIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERRIER { bits }
            }
            #[doc = "Bit 12 - End of operation interrupt enable"]
            #[inline]
            pub fn eopie(&self) -> EOPIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EOPIER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x80 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Programming"]
            #[inline]
            pub fn pg(&mut self) -> _PGW {
                _PGW { w: self }
            }
            #[doc = "Bit 1 - Page Erase"]
            #[inline]
            pub fn per(&mut self) -> _PERW {
                _PERW { w: self }
            }
            #[doc = "Bit 2 - Mass Erase"]
            #[inline]
            pub fn mer(&mut self) -> _MERW {
                _MERW { w: self }
            }
            #[doc = "Bit 4 - Option byte programming"]
            #[inline]
            pub fn optpg(&mut self) -> _OPTPGW {
                _OPTPGW { w: self }
            }
            #[doc = "Bit 5 - Option byte erase"]
            #[inline]
            pub fn opter(&mut self) -> _OPTERW {
                _OPTERW { w: self }
            }
            #[doc = "Bit 6 - Start"]
            #[inline]
            pub fn strt(&mut self) -> _STRTW {
                _STRTW { w: self }
            }
            #[doc = "Bit 7 - Lock"]
            #[inline]
            pub fn lock(&mut self) -> _LOCKW {
                _LOCKW { w: self }
            }
            #[doc = "Bit 9 - Option bytes write enable"]
            #[inline]
            pub fn optwre(&mut self) -> _OPTWREW {
                _OPTWREW { w: self }
            }
            #[doc = "Bit 10 - Error interrupt enable"]
            #[inline]
            pub fn errie(&mut self) -> _ERRIEW {
                _ERRIEW { w: self }
            }
            #[doc = "Bit 12 - End of operation interrupt enable"]
            #[inline]
            pub fn eopie(&mut self) -> _EOPIEW {
                _EOPIEW { w: self }
            }
        }
    }
    #[doc = "Flash address register"]
    pub struct AR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Flash address register"]
    pub mod ar {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::AR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _FARW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FARW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Flash Address"]
            #[inline]
            pub fn far(&mut self) -> _FARW {
                _FARW { w: self }
            }
        }
    }
    #[doc = "Option byte register"]
    pub struct OBR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Option byte register"]
    pub mod obr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::OBR {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct OPTERRR {
            bits: bool,
        }
        impl OPTERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RDPRTR {
            bits: bool,
        }
        impl RDPRTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDG_SWR {
            bits: bool,
        }
        impl WDG_SWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRST_STOPR {
            bits: bool,
        }
        impl NRST_STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRST_STDBYR {
            bits: bool,
        }
        impl NRST_STDBYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA0R {
            bits: u8,
        }
        impl DATA0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA1R {
            bits: u8,
        }
        impl DATA1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Option byte error"]
            #[inline]
            pub fn opterr(&self) -> OPTERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OPTERRR { bits }
            }
            #[doc = "Bit 1 - Read protection"]
            #[inline]
            pub fn rdprt(&self) -> RDPRTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RDPRTR { bits }
            }
            #[doc = "Bit 2 - WDG_SW"]
            #[inline]
            pub fn wdg_sw(&self) -> WDG_SWR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WDG_SWR { bits }
            }
            #[doc = "Bit 3 - nRST_STOP"]
            #[inline]
            pub fn n_rst_stop(&self) -> NRST_STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRST_STOPR { bits }
            }
            #[doc = "Bit 4 - nRST_STDBY"]
            #[inline]
            pub fn n_rst_stdby(&self) -> NRST_STDBYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NRST_STDBYR { bits }
            }
            #[doc = "Bits 10:17 - Data0"]
            #[inline]
            pub fn data0(&self) -> DATA0R {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATA0R { bits }
            }
            #[doc = "Bits 18:25 - Data1"]
            #[inline]
            pub fn data1(&self) -> DATA1R {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATA1R { bits }
            }
        }
    }
    #[doc = "Write protection register"]
    pub struct WRPR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Write protection register"]
    pub mod wrpr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::WRPR {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct WRPR {
            bits: u32,
        }
        impl WRPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Write protect"]
            #[inline]
            pub fn wrp(&self) -> WRPR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                WRPR { bits }
            }
        }
    }
}
#[doc = "General purpose timers"]
#[cfg(feature = "tim15")]
pub struct TIM15 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "tim15")]
unsafe impl Send for TIM15 {}
#[cfg(feature = "tim15")]
impl TIM15 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const tim15::RegisterBlock {
        0x4001_4000 as *const _
    }
}
#[cfg(feature = "tim15")]
impl Deref for TIM15 {
    type Target = tim15::RegisterBlock;
    fn deref(&self) -> &tim15::RegisterBlock {
        unsafe { &*TIM15::ptr() }
    }
}
#[doc = "General purpose timers"]
#[cfg(feature = "tim15")]
pub mod tim15 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        #[doc = "0x08 - slave mode control register"]
        pub smcr: SMCR,
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        pub ccmr1_output: CCMR1_OUTPUT,
        _reserved0: [u8; 4usize],
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: CCER,
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
        #[doc = "0x30 - repetition counter register"]
        pub rcr: RCR,
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: CCR1,
        #[doc = "0x38 - capture/compare register 2"]
        pub ccr2: CCR2,
        _reserved1: [u8; 8usize],
        #[doc = "0x44 - break and dead-time register"]
        pub bdtr: BDTR,
        #[doc = "0x48 - DMA control register"]
        pub dcr: DCR,
        #[doc = "0x4c - DMA address for full transfer"]
        pub dmar: DMAR,
    }
    #[doc = "control register 1"]
    pub struct CR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CKDR {
            bits: u8,
        }
        impl CKDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `ARPE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPER {
            #[doc = "TIMx_APRR register is not buffered"]
            DISABLED,
            #[doc = "TIMx_APRR register is buffered"]
            ENABLED,
        }
        impl ARPER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ARPER::DISABLED => false,
                    ARPER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ARPER {
                match value {
                    false => ARPER::DISABLED,
                    true => ARPER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ARPER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ARPER::ENABLED
            }
        }
        #[doc = r" Value of the field"]
        pub struct OPMR {
            bits: bool,
        }
        impl OPMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `URS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URSR {
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT,
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY,
        }
        impl URSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    URSR::ANYEVENT => false,
                    URSR::COUNTERONLY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> URSR {
                match value {
                    false => URSR::ANYEVENT,
                    true => URSR::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline]
            pub fn is_any_event(&self) -> bool {
                *self == URSR::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline]
            pub fn is_counter_only(&self) -> bool {
                *self == URSR::COUNTERONLY
            }
        }
        #[doc = "Possible values of the field `UDIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDISR {
            #[doc = "Update event enabled"]
            ENABLED,
            #[doc = "Update event disabled"]
            DISABLED,
        }
        impl UDISR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UDISR::ENABLED => false,
                    UDISR::DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UDISR {
                match value {
                    false => UDISR::ENABLED,
                    true => UDISR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UDISR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UDISR::DISABLED
            }
        }
        #[doc = "Possible values of the field `CEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CENR {
            #[doc = "Counter disabled"]
            DISABLED,
            #[doc = "Counter enabled"]
            ENABLED,
        }
        impl CENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CENR::DISABLED => false,
                    CENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CENR {
                match value {
                    false => CENR::DISABLED,
                    true => CENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CENR::ENABLED
            }
        }
        #[doc = r" Proxy"]
        pub struct _CKDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CKDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ARPE`"]
        pub enum ARPEW {
            #[doc = "TIMx_APRR register is not buffered"]
            DISABLED,
            #[doc = "TIMx_APRR register is buffered"]
            ENABLED,
        }
        impl ARPEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ARPEW::DISABLED => false,
                    ARPEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ARPEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ARPEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ARPEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPEW::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OPMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OPMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `URS`"]
        pub enum URSW {
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT,
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY,
        }
        impl URSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    URSW::ANYEVENT => false,
                    URSW::COUNTERONLY => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _URSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _URSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: URSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URSW::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URSW::COUNTERONLY)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UDIS`"]
        pub enum UDISW {
            #[doc = "Update event enabled"]
            ENABLED,
            #[doc = "Update event disabled"]
            DISABLED,
        }
        impl UDISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UDISW::ENABLED => false,
                    UDISW::DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UDISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UDISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UDISW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Update event enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDISW::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDISW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CEN`"]
        pub enum CENW {
            #[doc = "Counter disabled"]
            DISABLED,
            #[doc = "Counter enabled"]
            ENABLED,
        }
        impl CENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CENW::DISABLED => false,
                    CENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Counter disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CENW::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline]
            pub fn ckd(&self) -> CKDR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CKDR { bits }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline]
            pub fn arpe(&self) -> ARPER {
                ARPER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline]
            pub fn opm(&self) -> OPMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OPMR { bits }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline]
            pub fn urs(&self) -> URSR {
                URSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline]
            pub fn udis(&self) -> UDISR {
                UDISR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline]
            pub fn cen(&self) -> CENR {
                CENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline]
            pub fn ckd(&mut self) -> _CKDW {
                _CKDW { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline]
            pub fn arpe(&mut self) -> _ARPEW {
                _ARPEW { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline]
            pub fn opm(&mut self) -> _OPMW {
                _OPMW { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline]
            pub fn urs(&mut self) -> _URSW {
                _URSW { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline]
            pub fn udis(&mut self) -> _UDISW {
                _UDISW { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline]
            pub fn cen(&mut self) -> _CENW {
                _CENW { w: self }
            }
        }
    }
    #[doc = "control register 2"]
    pub struct CR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OIS2R {
            bits: bool,
        }
        impl OIS2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OIS1NR {
            bits: bool,
        }
        impl OIS1NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OIS1R {
            bits: bool,
        }
        impl OIS1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MMSR {
            bits: u8,
        }
        impl MMSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCDSR {
            bits: bool,
        }
        impl CCDSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCUSR {
            bits: bool,
        }
        impl CCUSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCPCR {
            bits: bool,
        }
        impl CCPCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _OIS2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OIS2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OIS1NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OIS1NW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OIS1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OIS1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MMSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MMSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCDSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCDSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCUSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCUSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCPCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCPCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 10 - Output Idle state 2"]
            #[inline]
            pub fn ois2(&self) -> OIS2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OIS2R { bits }
            }
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline]
            pub fn ois1n(&self) -> OIS1NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OIS1NR { bits }
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline]
            pub fn ois1(&self) -> OIS1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OIS1R { bits }
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline]
            pub fn mms(&self) -> MMSR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MMSR { bits }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline]
            pub fn ccds(&self) -> CCDSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CCDSR { bits }
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline]
            pub fn ccus(&self) -> CCUSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CCUSR { bits }
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline]
            pub fn ccpc(&self) -> CCPCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CCPCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 10 - Output Idle state 2"]
            #[inline]
            pub fn ois2(&mut self) -> _OIS2W {
                _OIS2W { w: self }
            }
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline]
            pub fn ois1n(&mut self) -> _OIS1NW {
                _OIS1NW { w: self }
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline]
            pub fn ois1(&mut self) -> _OIS1W {
                _OIS1W { w: self }
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline]
            pub fn mms(&mut self) -> _MMSW {
                _MMSW { w: self }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline]
            pub fn ccds(&mut self) -> _CCDSW {
                _CCDSW { w: self }
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline]
            pub fn ccus(&mut self) -> _CCUSW {
                _CCUSW { w: self }
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline]
            pub fn ccpc(&mut self) -> _CCPCW {
                _CCPCW { w: self }
            }
        }
    }
    #[doc = "slave mode control register"]
    pub struct SMCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "slave mode control register"]
    pub mod smcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SMCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSMR {
            bits: bool,
        }
        impl MSMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TSR {
            bits: u8,
        }
        impl TSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMSR {
            bits: u8,
        }
        impl SMSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline]
            pub fn msm(&self) -> MSMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MSMR { bits }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline]
            pub fn ts(&self) -> TSR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TSR { bits }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline]
            pub fn sms(&self) -> SMSR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline]
            pub fn msm(&mut self) -> _MSMW {
                _MSMW { w: self }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline]
            pub fn ts(&mut self) -> _TSW {
                _TSW { w: self }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline]
            pub fn sms(&mut self) -> _SMSW {
                _SMSW { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register"]
    pub struct DIER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TDER {
            bits: bool,
        }
        impl TDER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2DER {
            bits: bool,
        }
        impl CC2DER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1DER {
            bits: bool,
        }
        impl CC1DER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct UDER {
            bits: bool,
        }
        impl UDER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BIER {
            bits: bool,
        }
        impl BIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIER {
            bits: bool,
        }
        impl TIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMIER {
            bits: bool,
        }
        impl COMIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2IER {
            bits: bool,
        }
        impl CC2IER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1IER {
            bits: bool,
        }
        impl CC1IER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `UIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIER {
            #[doc = "Update interrupt disabled"]
            DISABLED,
            #[doc = "Update interrupt enabled"]
            ENABLED,
        }
        impl UIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UIER::DISABLED => false,
                    UIER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UIER {
                match value {
                    false => UIER::DISABLED,
                    true => UIER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UIER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UIER::ENABLED
            }
        }
        #[doc = r" Proxy"]
        pub struct _TDEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TDEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2DEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2DEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1DEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1DEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UDEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UDEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2IEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2IEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1IEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1IEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UIE`"]
        pub enum UIEW {
            #[doc = "Update interrupt disabled"]
            DISABLED,
            #[doc = "Update interrupt enabled"]
            ENABLED,
        }
        impl UIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UIEW::DISABLED => false,
                    UIEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIEW::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline]
            pub fn tde(&self) -> TDER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TDER { bits }
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline]
            pub fn cc2de(&self) -> CC2DER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2DER { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline]
            pub fn cc1de(&self) -> CC1DER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1DER { bits }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline]
            pub fn ude(&self) -> UDER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                UDER { bits }
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline]
            pub fn bie(&self) -> BIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BIER { bits }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline]
            pub fn tie(&self) -> TIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIER { bits }
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline]
            pub fn comie(&self) -> COMIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                COMIER { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline]
            pub fn cc2ie(&self) -> CC2IER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2IER { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline]
            pub fn cc1ie(&self) -> CC1IER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1IER { bits }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline]
            pub fn uie(&self) -> UIER {
                UIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline]
            pub fn tde(&mut self) -> _TDEW {
                _TDEW { w: self }
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline]
            pub fn cc2de(&mut self) -> _CC2DEW {
                _CC2DEW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline]
            pub fn cc1de(&mut self) -> _CC1DEW {
                _CC1DEW { w: self }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline]
            pub fn ude(&mut self) -> _UDEW {
                _UDEW { w: self }
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline]
            pub fn bie(&mut self) -> _BIEW {
                _BIEW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline]
            pub fn tie(&mut self) -> _TIEW {
                _TIEW { w: self }
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline]
            pub fn comie(&mut self) -> _COMIEW {
                _COMIEW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline]
            pub fn cc2ie(&mut self) -> _CC2IEW {
                _CC2IEW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline]
            pub fn cc1ie(&mut self) -> _CC1IEW {
                _CC1IEW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline]
            pub fn uie(&mut self) -> _UIEW {
                _UIEW { w: self }
            }
        }
    }
    #[doc = "status register"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2OFR {
            bits: bool,
        }
        impl CC2OFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1OFR {
            bits: bool,
        }
        impl CC1OFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BIFR {
            bits: bool,
        }
        impl BIFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIFR {
            bits: bool,
        }
        impl TIFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMIFR {
            bits: bool,
        }
        impl COMIFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2IFR {
            bits: bool,
        }
        impl CC2IFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1IFR {
            bits: bool,
        }
        impl CC1IFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `UIF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIFR {
            #[doc = "No update occurred"]
            CLEAR,
            #[doc = "Update interrupt pending."]
            UPDATEPENDING,
        }
        impl UIFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UIFR::CLEAR => false,
                    UIFR::UPDATEPENDING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UIFR {
                match value {
                    false => UIFR::CLEAR,
                    true => UIFR::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline]
            pub fn is_clear(&self) -> bool {
                *self == UIFR::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline]
            pub fn is_update_pending(&self) -> bool {
                *self == UIFR::UPDATEPENDING
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2OFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2OFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1OFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1OFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMIFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2IFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2IFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1IFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1IFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UIF`"]
        pub enum UIFW {
            #[doc = "No update occurred"]
            CLEAR,
            #[doc = "Update interrupt pending."]
            UPDATEPENDING,
        }
        impl UIFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UIFW::CLEAR => false,
                    UIFW::UPDATEPENDING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UIFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UIFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No update occurred"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIFW::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIFW::UPDATEPENDING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline]
            pub fn cc2of(&self) -> CC2OFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2OFR { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline]
            pub fn cc1of(&self) -> CC1OFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1OFR { bits }
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline]
            pub fn bif(&self) -> BIFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BIFR { bits }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline]
            pub fn tif(&self) -> TIFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIFR { bits }
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline]
            pub fn comif(&self) -> COMIFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                COMIFR { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline]
            pub fn cc2if(&self) -> CC2IFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2IFR { bits }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline]
            pub fn cc1if(&self) -> CC1IFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1IFR { bits }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline]
            pub fn uif(&self) -> UIFR {
                UIFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline]
            pub fn cc2of(&mut self) -> _CC2OFW {
                _CC2OFW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline]
            pub fn cc1of(&mut self) -> _CC1OFW {
                _CC1OFW { w: self }
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline]
            pub fn bif(&mut self) -> _BIFW {
                _BIFW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline]
            pub fn tif(&mut self) -> _TIFW {
                _TIFW { w: self }
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline]
            pub fn comif(&mut self) -> _COMIFW {
                _COMIFW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline]
            pub fn cc2if(&mut self) -> _CC2IFW {
                _CC2IFW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline]
            pub fn cc1if(&mut self) -> _CC1IFW {
                _CC1IFW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline]
            pub fn uif(&mut self) -> _UIFW {
                _UIFW { w: self }
            }
        }
    }
    #[doc = "event generation register"]
    pub struct EGR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EGR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _BGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2GW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2GW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1GW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1GW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UG`"]
        pub enum UGW {
            #[doc = "Re-initializes the timer counter and generates an update of the reigsters."]
            UPDATE,
        }
        impl UGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UGW::UPDATE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the reigsters."]
            #[inline]
            pub fn update(self) -> &'a mut W {
                self.variant(UGW::UPDATE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Break generation"]
            #[inline]
            pub fn bg(&mut self) -> _BGW {
                _BGW { w: self }
            }
            #[doc = "Bit 6 - Trigger generation"]
            #[inline]
            pub fn tg(&mut self) -> _TGW {
                _TGW { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare control update generation"]
            #[inline]
            pub fn comg(&mut self) -> _COMGW {
                _COMGW { w: self }
            }
            #[doc = "Bit 2 - Capture/compare 2 generation"]
            #[inline]
            pub fn cc2g(&mut self) -> _CC2GW {
                _CC2GW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline]
            pub fn cc1g(&mut self) -> _CC1GW {
                _CC1GW { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline]
            pub fn ug(&mut self) -> _UGW {
                _UGW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub struct CCMR1_OUTPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr1_output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCMR1_OUTPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC2MR {
            bits: u8,
        }
        impl OC2MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC2PER {
            bits: bool,
        }
        impl OC2PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC2FER {
            bits: bool,
        }
        impl OC2FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2SR {
            bits: u8,
        }
        impl CC2SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1MR {
            bits: u8,
        }
        impl OC1MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1PER {
            bits: bool,
        }
        impl OC1PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1FER {
            bits: bool,
        }
        impl OC1FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1SR {
            bits: u8,
        }
        impl CC1SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC2MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC2MW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC2PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC2PEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC2FEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC2FEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1MW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1PEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1FEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1FEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline]
            pub fn oc2m(&self) -> OC2MR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OC2MR { bits }
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline]
            pub fn oc2pe(&self) -> OC2PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC2PER { bits }
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline]
            pub fn oc2fe(&self) -> OC2FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC2FER { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline]
            pub fn cc2s(&self) -> CC2SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC2SR { bits }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline]
            pub fn oc1m(&self) -> OC1MR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OC1MR { bits }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline]
            pub fn oc1pe(&self) -> OC1PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC1PER { bits }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline]
            pub fn oc1fe(&self) -> OC1FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC1FER { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&self) -> CC1SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC1SR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline]
            pub fn oc2m(&mut self) -> _OC2MW {
                _OC2MW { w: self }
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline]
            pub fn oc2pe(&mut self) -> _OC2PEW {
                _OC2PEW { w: self }
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline]
            pub fn oc2fe(&mut self) -> _OC2FEW {
                _OC2FEW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline]
            pub fn cc2s(&mut self) -> _CC2SW {
                _CC2SW { w: self }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline]
            pub fn oc1m(&mut self) -> _OC1MW {
                _OC1MW { w: self }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline]
            pub fn oc1pe(&mut self) -> _OC1PEW {
                _OC1PEW { w: self }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline]
            pub fn oc1fe(&mut self) -> _OC1FEW {
                _OC1FEW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&mut self) -> _CC1SW {
                _CC1SW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub struct CCMR1_INPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCMR1_INPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC2FR {
            bits: u8,
        }
        impl IC2FR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC2PSCR {
            bits: u8,
        }
        impl IC2PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2SR {
            bits: u8,
        }
        impl CC2SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC1FR {
            bits: u8,
        }
        impl IC1FR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC1PSCR {
            bits: u8,
        }
        impl IC1PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1SR {
            bits: u8,
        }
        impl CC1SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC2FW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC2FW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC2PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC2PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC1FW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC1FW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC1PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC1PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline]
            pub fn ic2f(&self) -> IC2FR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC2FR { bits }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline]
            pub fn ic2psc(&self) -> IC2PSCR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC2PSCR { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline]
            pub fn cc2s(&self) -> CC2SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC2SR { bits }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline]
            pub fn ic1f(&self) -> IC1FR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC1FR { bits }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline]
            pub fn ic1psc(&self) -> IC1PSCR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC1PSCR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&self) -> CC1SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC1SR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline]
            pub fn ic2f(&mut self) -> _IC2FW {
                _IC2FW { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline]
            pub fn ic2psc(&mut self) -> _IC2PSCW {
                _IC2PSCW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline]
            pub fn cc2s(&mut self) -> _CC2SW {
                _CC2SW { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline]
            pub fn ic1f(&mut self) -> _IC1FW {
                _IC1FW { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline]
            pub fn ic1psc(&mut self) -> _IC1PSCW {
                _IC1PSCW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&mut self) -> _CC1SW {
                _CC1SW { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register"]
    pub struct CCER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2NPR {
            bits: bool,
        }
        impl CC2NPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2PR {
            bits: bool,
        }
        impl CC2PR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC2ER {
            bits: bool,
        }
        impl CC2ER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1NPR {
            bits: bool,
        }
        impl CC1NPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1NER {
            bits: bool,
        }
        impl CC1NER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1PR {
            bits: bool,
        }
        impl CC1PR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1ER {
            bits: bool,
        }
        impl CC1ER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2NPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2NPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2PW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2PW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC2EW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC2EW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1NPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1NPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1NEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1NEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1PW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1PW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1EW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1EW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline]
            pub fn cc2np(&self) -> CC2NPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2NPR { bits }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline]
            pub fn cc2p(&self) -> CC2PR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2PR { bits }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline]
            pub fn cc2e(&self) -> CC2ER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC2ER { bits }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1np(&self) -> CC1NPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1NPR { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline]
            pub fn cc1ne(&self) -> CC1NER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1NER { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1p(&self) -> CC1PR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1PR { bits }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline]
            pub fn cc1e(&self) -> CC1ER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1ER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline]
            pub fn cc2np(&mut self) -> _CC2NPW {
                _CC2NPW { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline]
            pub fn cc2p(&mut self) -> _CC2PW {
                _CC2PW { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline]
            pub fn cc2e(&mut self) -> _CC2EW {
                _CC2EW { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1np(&mut self) -> _CC1NPW {
                _CC1NPW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline]
            pub fn cc1ne(&mut self) -> _CC1NEW {
                _CC1NEW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1p(&mut self) -> _CC1PW {
                _CC1PW { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline]
            pub fn cc1e(&mut self) -> _CC1EW {
                _CC1EW { w: self }
            }
        }
    }
    #[doc = "counter"]
    pub struct CNT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "counter"]
    pub mod cnt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNTR {
            bits: u16,
        }
        impl CNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline]
            pub fn cnt(&self) -> CNTR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline]
            pub fn cnt(&mut self) -> _CNTW {
                _CNTW { w: self }
            }
        }
    }
    #[doc = "prescaler"]
    pub struct PSC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PSCR {
            bits: u16,
        }
        impl PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline]
            pub fn psc(&self) -> PSCR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PSCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline]
            pub fn psc(&mut self) -> _PSCW {
                _PSCW { w: self }
            }
        }
    }
    #[doc = "auto-reload register"]
    pub struct ARR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ARR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ARRR {
            bits: u16,
        }
        impl ARRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ARRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ARRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline]
            pub fn arr(&self) -> ARRR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ARRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline]
            pub fn arr(&mut self) -> _ARRW {
                _ARRW { w: self }
            }
        }
    }
    #[doc = "repetition counter register"]
    pub struct RCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "repetition counter register"]
    pub mod rcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct REPR {
            bits: u8,
        }
        impl REPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _REPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline]
            pub fn rep(&self) -> REPR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                REPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline]
            pub fn rep(&mut self) -> _REPW {
                _REPW { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1"]
    pub struct CCR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare register 1"]
    pub mod ccr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCR1R {
            bits: u16,
        }
        impl CCR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCR1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline]
            pub fn ccr1(&self) -> CCR1R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CCR1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline]
            pub fn ccr1(&mut self) -> _CCR1W {
                _CCR1W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 2"]
    pub struct CCR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare register 2"]
    pub mod ccr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCR2R {
            bits: u16,
        }
        impl CCR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCR2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 2 value"]
            #[inline]
            pub fn ccr2(&self) -> CCR2R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CCR2R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 2 value"]
            #[inline]
            pub fn ccr2(&mut self) -> _CCR2W {
                _CCR2W { w: self }
            }
        }
    }
    #[doc = "break and dead-time register"]
    pub struct BDTR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "break and dead-time register"]
    pub mod bdtr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BDTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MOER {
            bits: bool,
        }
        impl MOER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AOER {
            bits: bool,
        }
        impl AOER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BKPR {
            bits: bool,
        }
        impl BKPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BKER {
            bits: bool,
        }
        impl BKER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSSRR {
            bits: bool,
        }
        impl OSSRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSSIR {
            bits: bool,
        }
        impl OSSIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LOCKR {
            bits: u8,
        }
        impl LOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DTGR {
            bits: u8,
        }
        impl DTGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MOEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MOEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AOEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AOEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BKPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BKPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BKEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BKEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSSRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSSRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSSIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSSIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOCKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DTGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DTGW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Main output enable"]
            #[inline]
            pub fn moe(&self) -> MOER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MOER { bits }
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline]
            pub fn aoe(&self) -> AOER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AOER { bits }
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline]
            pub fn bkp(&self) -> BKPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BKPR { bits }
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline]
            pub fn bke(&self) -> BKER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BKER { bits }
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline]
            pub fn ossr(&self) -> OSSRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSSRR { bits }
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline]
            pub fn ossi(&self) -> OSSIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSSIR { bits }
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline]
            pub fn lock(&self) -> LOCKR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LOCKR { bits }
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline]
            pub fn dtg(&self) -> DTGR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DTGR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Main output enable"]
            #[inline]
            pub fn moe(&mut self) -> _MOEW {
                _MOEW { w: self }
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline]
            pub fn aoe(&mut self) -> _AOEW {
                _AOEW { w: self }
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline]
            pub fn bkp(&mut self) -> _BKPW {
                _BKPW { w: self }
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline]
            pub fn bke(&mut self) -> _BKEW {
                _BKEW { w: self }
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline]
            pub fn ossr(&mut self) -> _OSSRW {
                _OSSRW { w: self }
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline]
            pub fn ossi(&mut self) -> _OSSIW {
                _OSSIW { w: self }
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline]
            pub fn lock(&mut self) -> _LOCKW {
                _LOCKW { w: self }
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline]
            pub fn dtg(&mut self) -> _DTGW {
                _DTGW { w: self }
            }
        }
    }
    #[doc = "DMA control register"]
    pub struct DCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA control register"]
    pub mod dcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBLR {
            bits: u8,
        }
        impl DBLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBAR {
            bits: u8,
        }
        impl DBAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline]
            pub fn dbl(&self) -> DBLR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DBLR { bits }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline]
            pub fn dba(&self) -> DBAR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DBAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline]
            pub fn dbl(&mut self) -> _DBLW {
                _DBLW { w: self }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline]
            pub fn dba(&mut self) -> _DBAW {
                _DBAW { w: self }
            }
        }
    }
    #[doc = "DMA address for full transfer"]
    pub struct DMAR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA address for full transfer"]
    pub mod dmar {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMAR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMABR {
            bits: u16,
        }
        impl DMABR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMABW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMABW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline]
            pub fn dmab(&self) -> DMABR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DMABR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline]
            pub fn dmab(&mut self) -> _DMABW {
                _DMABW { w: self }
            }
        }
    }
}
#[doc = "General-purpose-timers"]
#[cfg(feature = "tim16")]
pub struct TIM16 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "tim16")]
unsafe impl Send for TIM16 {}
#[cfg(feature = "tim16")]
impl TIM16 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const tim16::RegisterBlock {
        0x4001_4400 as *const _
    }
}
#[cfg(feature = "tim16")]
impl Deref for TIM16 {
    type Target = tim16::RegisterBlock;
    fn deref(&self) -> &tim16::RegisterBlock {
        unsafe { &*TIM16::ptr() }
    }
}
#[doc = "General-purpose-timers"]
#[cfg(feature = "tim16")]
pub mod tim16 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: CR1,
        #[doc = "0x04 - control register 2"]
        pub cr2: CR2,
        _reserved0: [u8; 4usize],
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: DIER,
        #[doc = "0x10 - status register"]
        pub sr: SR,
        #[doc = "0x14 - event generation register"]
        pub egr: EGR,
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        pub ccmr1_output: CCMR1_OUTPUT,
        _reserved1: [u8; 4usize],
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: CCER,
        #[doc = "0x24 - counter"]
        pub cnt: CNT,
        #[doc = "0x28 - prescaler"]
        pub psc: PSC,
        #[doc = "0x2c - auto-reload register"]
        pub arr: ARR,
        #[doc = "0x30 - repetition counter register"]
        pub rcr: RCR,
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: CCR1,
        _reserved2: [u8; 12usize],
        #[doc = "0x44 - break and dead-time register"]
        pub bdtr: BDTR,
        #[doc = "0x48 - DMA control register"]
        pub dcr: DCR,
        #[doc = "0x4c - DMA address for full transfer"]
        pub dmar: DMAR,
    }
    #[doc = "control register 1"]
    pub struct CR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CKDR {
            bits: u8,
        }
        impl CKDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `ARPE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPER {
            #[doc = "TIMx_APRR register is not buffered"]
            DISABLED,
            #[doc = "TIMx_APRR register is buffered"]
            ENABLED,
        }
        impl ARPER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ARPER::DISABLED => false,
                    ARPER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ARPER {
                match value {
                    false => ARPER::DISABLED,
                    true => ARPER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ARPER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ARPER::ENABLED
            }
        }
        #[doc = "Possible values of the field `OPM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPMR {
            #[doc = "Not stopped at update event"]
            NOTSTOPPED,
            #[doc = "Counter stops counting at next update event"]
            STOPPED,
        }
        impl OPMR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OPMR::NOTSTOPPED => false,
                    OPMR::STOPPED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OPMR {
                match value {
                    false => OPMR::NOTSTOPPED,
                    true => OPMR::STOPPED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTSTOPPED`"]
            #[inline]
            pub fn is_not_stopped(&self) -> bool {
                *self == OPMR::NOTSTOPPED
            }
            #[doc = "Checks if the value of the field is `STOPPED`"]
            #[inline]
            pub fn is_stopped(&self) -> bool {
                *self == OPMR::STOPPED
            }
        }
        #[doc = "Possible values of the field `URS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URSR {
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT,
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY,
        }
        impl URSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    URSR::ANYEVENT => false,
                    URSR::COUNTERONLY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> URSR {
                match value {
                    false => URSR::ANYEVENT,
                    true => URSR::COUNTERONLY,
                }
            }
            #[doc = "Checks if the value of the field is `ANYEVENT`"]
            #[inline]
            pub fn is_any_event(&self) -> bool {
                *self == URSR::ANYEVENT
            }
            #[doc = "Checks if the value of the field is `COUNTERONLY`"]
            #[inline]
            pub fn is_counter_only(&self) -> bool {
                *self == URSR::COUNTERONLY
            }
        }
        #[doc = "Possible values of the field `UDIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDISR {
            #[doc = "Update event enabled"]
            ENABLED,
            #[doc = "Update event disabled"]
            DISABLED,
        }
        impl UDISR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UDISR::ENABLED => false,
                    UDISR::DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UDISR {
                match value {
                    false => UDISR::ENABLED,
                    true => UDISR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UDISR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UDISR::DISABLED
            }
        }
        #[doc = "Possible values of the field `CEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CENR {
            #[doc = "Counter disabled"]
            DISABLED,
            #[doc = "Counter enabled"]
            ENABLED,
        }
        impl CENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CENR::DISABLED => false,
                    CENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CENR {
                match value {
                    false => CENR::DISABLED,
                    true => CENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CENR::ENABLED
            }
        }
        #[doc = r" Proxy"]
        pub struct _CKDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CKDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ARPE`"]
        pub enum ARPEW {
            #[doc = "TIMx_APRR register is not buffered"]
            DISABLED,
            #[doc = "TIMx_APRR register is buffered"]
            ENABLED,
        }
        impl ARPEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ARPEW::DISABLED => false,
                    ARPEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ARPEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ARPEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ARPEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "TIMx_APRR register is not buffered"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPEW::DISABLED)
            }
            #[doc = "TIMx_APRR register is buffered"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OPM`"]
        pub enum OPMW {
            #[doc = "Not stopped at update event"]
            NOTSTOPPED,
            #[doc = "Counter stops counting at next update event"]
            STOPPED,
        }
        impl OPMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OPMW::NOTSTOPPED => false,
                    OPMW::STOPPED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OPMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OPMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OPMW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Not stopped at update event"]
            #[inline]
            pub fn not_stopped(self) -> &'a mut W {
                self.variant(OPMW::NOTSTOPPED)
            }
            #[doc = "Counter stops counting at next update event"]
            #[inline]
            pub fn stopped(self) -> &'a mut W {
                self.variant(OPMW::STOPPED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `URS`"]
        pub enum URSW {
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            ANYEVENT,
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            COUNTERONLY,
        }
        impl URSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    URSW::ANYEVENT => false,
                    URSW::COUNTERONLY => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _URSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _URSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: URSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request"]
            #[inline]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URSW::ANYEVENT)
            }
            #[doc = "Only counter overflow/underflow generates an update interrupt or DMA request"]
            #[inline]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URSW::COUNTERONLY)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UDIS`"]
        pub enum UDISW {
            #[doc = "Update event enabled"]
            ENABLED,
            #[doc = "Update event disabled"]
            DISABLED,
        }
        impl UDISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UDISW::ENABLED => false,
                    UDISW::DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UDISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UDISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UDISW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Update event enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDISW::ENABLED)
            }
            #[doc = "Update event disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDISW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CEN`"]
        pub enum CENW {
            #[doc = "Counter disabled"]
            DISABLED,
            #[doc = "Counter enabled"]
            ENABLED,
        }
        impl CENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CENW::DISABLED => false,
                    CENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Counter disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CENW::DISABLED)
            }
            #[doc = "Counter enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline]
            pub fn ckd(&self) -> CKDR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CKDR { bits }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline]
            pub fn arpe(&self) -> ARPER {
                ARPER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline]
            pub fn opm(&self) -> OPMR {
                OPMR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline]
            pub fn urs(&self) -> URSR {
                URSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline]
            pub fn udis(&self) -> UDISR {
                UDISR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline]
            pub fn cen(&self) -> CENR {
                CENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline]
            pub fn ckd(&mut self) -> _CKDW {
                _CKDW { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline]
            pub fn arpe(&mut self) -> _ARPEW {
                _ARPEW { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline]
            pub fn opm(&mut self) -> _OPMW {
                _OPMW { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline]
            pub fn urs(&mut self) -> _URSW {
                _URSW { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline]
            pub fn udis(&mut self) -> _UDISW {
                _UDISW { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline]
            pub fn cen(&mut self) -> _CENW {
                _CENW { w: self }
            }
        }
    }
    #[doc = "control register 2"]
    pub struct CR2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `OIS1N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OIS1NR {
            #[doc = "OC1N=0 after a dead-time when MOE=0"]
            LOW,
            #[doc = "OC1N=1 after a dead-time when MOE=0"]
            HIGH,
        }
        impl OIS1NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OIS1NR::LOW => false,
                    OIS1NR::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OIS1NR {
                match value {
                    false => OIS1NR::LOW,
                    true => OIS1NR::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == OIS1NR::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == OIS1NR::HIGH
            }
        }
        #[doc = "Possible values of the field `OIS1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OIS1R {
            #[doc = "OC1=0 (after a dead-time if OC1N is implemented) when MOE=0"]
            LOW,
            #[doc = "OC1=1 (after a dead-time if OC1N is implemented) when MOE=0"]
            HIGH,
        }
        impl OIS1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OIS1R::LOW => false,
                    OIS1R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OIS1R {
                match value {
                    false => OIS1R::LOW,
                    true => OIS1R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == OIS1R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == OIS1R::HIGH
            }
        }
        #[doc = "Possible values of the field `CCDS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCDSR {
            #[doc = "CCx DMA request sent when CCx event occurs"]
            ONCOMPARE,
            #[doc = "CCx DMA request sent when update event occurs"]
            ONUPDATE,
        }
        impl CCDSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CCDSR::ONCOMPARE => false,
                    CCDSR::ONUPDATE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CCDSR {
                match value {
                    false => CCDSR::ONCOMPARE,
                    true => CCDSR::ONUPDATE,
                }
            }
            #[doc = "Checks if the value of the field is `ONCOMPARE`"]
            #[inline]
            pub fn is_on_compare(&self) -> bool {
                *self == CCDSR::ONCOMPARE
            }
            #[doc = "Checks if the value of the field is `ONUPDATE`"]
            #[inline]
            pub fn is_on_update(&self) -> bool {
                *self == CCDSR::ONUPDATE
            }
        }
        #[doc = "Possible values of the field `CCUS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCUSR {
            #[doc = "Capture/compare are updated only by setting the COMG bit"]
            DEFAULT,
            #[doc = "Capture/compare are updated by setting the COMG bit or when an rising edge occurs on TRGI"]
            WITHRISINGEDGE,
        }
        impl CCUSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CCUSR::DEFAULT => false,
                    CCUSR::WITHRISINGEDGE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CCUSR {
                match value {
                    false => CCUSR::DEFAULT,
                    true => CCUSR::WITHRISINGEDGE,
                }
            }
            #[doc = "Checks if the value of the field is `DEFAULT`"]
            #[inline]
            pub fn is_default(&self) -> bool {
                *self == CCUSR::DEFAULT
            }
            #[doc = "Checks if the value of the field is `WITHRISINGEDGE`"]
            #[inline]
            pub fn is_with_rising_edge(&self) -> bool {
                *self == CCUSR::WITHRISINGEDGE
            }
        }
        #[doc = "Possible values of the field `CCPC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCPCR {
            #[doc = "CCxE, CCxNE and OCxM bits are not preloaded"]
            NOTPRELOADED,
            #[doc = "CCxE, CCxNE and OCxM bits are preloaded"]
            PRELOADED,
        }
        impl CCPCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CCPCR::NOTPRELOADED => false,
                    CCPCR::PRELOADED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CCPCR {
                match value {
                    false => CCPCR::NOTPRELOADED,
                    true => CCPCR::PRELOADED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTPRELOADED`"]
            #[inline]
            pub fn is_not_preloaded(&self) -> bool {
                *self == CCPCR::NOTPRELOADED
            }
            #[doc = "Checks if the value of the field is `PRELOADED`"]
            #[inline]
            pub fn is_preloaded(&self) -> bool {
                *self == CCPCR::PRELOADED
            }
        }
        #[doc = "Values that can be written to the field `OIS1N`"]
        pub enum OIS1NW {
            #[doc = "OC1N=0 after a dead-time when MOE=0"]
            LOW,
            #[doc = "OC1N=1 after a dead-time when MOE=0"]
            HIGH,
        }
        impl OIS1NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OIS1NW::LOW => false,
                    OIS1NW::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OIS1NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OIS1NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OIS1NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "OC1N=0 after a dead-time when MOE=0"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(OIS1NW::LOW)
            }
            #[doc = "OC1N=1 after a dead-time when MOE=0"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(OIS1NW::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OIS1`"]
        pub enum OIS1W {
            #[doc = "OC1=0 (after a dead-time if OC1N is implemented) when MOE=0"]
            LOW,
            #[doc = "OC1=1 (after a dead-time if OC1N is implemented) when MOE=0"]
            HIGH,
        }
        impl OIS1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OIS1W::LOW => false,
                    OIS1W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OIS1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OIS1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OIS1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "OC1=0 (after a dead-time if OC1N is implemented) when MOE=0"]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(OIS1W::LOW)
            }
            #[doc = "OC1=1 (after a dead-time if OC1N is implemented) when MOE=0"]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(OIS1W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCDS`"]
        pub enum CCDSW {
            #[doc = "CCx DMA request sent when CCx event occurs"]
            ONCOMPARE,
            #[doc = "CCx DMA request sent when update event occurs"]
            ONUPDATE,
        }
        impl CCDSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CCDSW::ONCOMPARE => false,
                    CCDSW::ONUPDATE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCDSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCDSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CCDSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CCx DMA request sent when CCx event occurs"]
            #[inline]
            pub fn on_compare(self) -> &'a mut W {
                self.variant(CCDSW::ONCOMPARE)
            }
            #[doc = "CCx DMA request sent when update event occurs"]
            #[inline]
            pub fn on_update(self) -> &'a mut W {
                self.variant(CCDSW::ONUPDATE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCUS`"]
        pub enum CCUSW {
            #[doc = "Capture/compare are updated only by setting the COMG bit"]
            DEFAULT,
            #[doc = "Capture/compare are updated by setting the COMG bit or when an rising edge occurs on TRGI"]
            WITHRISINGEDGE,
        }
        impl CCUSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CCUSW::DEFAULT => false,
                    CCUSW::WITHRISINGEDGE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCUSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCUSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CCUSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Capture/compare are updated only by setting the COMG bit"]
            #[inline]
            pub fn default(self) -> &'a mut W {
                self.variant(CCUSW::DEFAULT)
            }
            #[doc = "Capture/compare are updated by setting the COMG bit or when an rising edge occurs on TRGI"]
            #[inline]
            pub fn with_rising_edge(self) -> &'a mut W {
                self.variant(CCUSW::WITHRISINGEDGE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CCPC`"]
        pub enum CCPCW {
            #[doc = "CCxE, CCxNE and OCxM bits are not preloaded"]
            NOTPRELOADED,
            #[doc = "CCxE, CCxNE and OCxM bits are preloaded"]
            PRELOADED,
        }
        impl CCPCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CCPCW::NOTPRELOADED => false,
                    CCPCW::PRELOADED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCPCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCPCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CCPCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CCxE, CCxNE and OCxM bits are not preloaded"]
            #[inline]
            pub fn not_preloaded(self) -> &'a mut W {
                self.variant(CCPCW::NOTPRELOADED)
            }
            #[doc = "CCxE, CCxNE and OCxM bits are preloaded"]
            #[inline]
            pub fn preloaded(self) -> &'a mut W {
                self.variant(CCPCW::PRELOADED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline]
            pub fn ois1n(&self) -> OIS1NR {
                OIS1NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline]
            pub fn ois1(&self) -> OIS1R {
                OIS1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline]
            pub fn ccds(&self) -> CCDSR {
                CCDSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline]
            pub fn ccus(&self) -> CCUSR {
                CCUSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline]
            pub fn ccpc(&self) -> CCPCR {
                CCPCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline]
            pub fn ois1n(&mut self) -> _OIS1NW {
                _OIS1NW { w: self }
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline]
            pub fn ois1(&mut self) -> _OIS1W {
                _OIS1W { w: self }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline]
            pub fn ccds(&mut self) -> _CCDSW {
                _CCDSW { w: self }
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline]
            pub fn ccus(&mut self) -> _CCUSW {
                _CCUSW { w: self }
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline]
            pub fn ccpc(&mut self) -> _CCPCW {
                _CCPCW { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register"]
    pub struct DIER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TDER {
            bits: bool,
        }
        impl TDER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `CC1DE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC1DER {
            #[doc = "CC1 DMA request disabled"]
            DISABLED,
            #[doc = "CC1 DMA request enabled"]
            ENABLED,
        }
        impl CC1DER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CC1DER::DISABLED => false,
                    CC1DER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CC1DER {
                match value {
                    false => CC1DER::DISABLED,
                    true => CC1DER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CC1DER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CC1DER::ENABLED
            }
        }
        #[doc = r" Value of the field"]
        pub struct UDER {
            bits: bool,
        }
        impl UDER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `BIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BIER {
            #[doc = "Break interrupt disabled"]
            DISABLED,
            #[doc = "Break interrupt enabled"]
            ENABLED,
        }
        impl BIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BIER::DISABLED => false,
                    BIER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BIER {
                match value {
                    false => BIER::DISABLED,
                    true => BIER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == BIER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == BIER::ENABLED
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIER {
            bits: bool,
        }
        impl TIER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `COMIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMIER {
            #[doc = "COM interrupt disabled"]
            DISABLED,
            #[doc = "COM interrupt enabled"]
            ENABLED,
        }
        impl COMIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMIER::DISABLED => false,
                    COMIER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMIER {
                match value {
                    false => COMIER::DISABLED,
                    true => COMIER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMIER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMIER::ENABLED
            }
        }
        #[doc = "Possible values of the field `CC1IE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC1IER {
            #[doc = "CC1 interrupt disabled"]
            DISABLED,
            #[doc = "CC1 interrupt enabled"]
            ENABLED,
        }
        impl CC1IER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CC1IER::DISABLED => false,
                    CC1IER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CC1IER {
                match value {
                    false => CC1IER::DISABLED,
                    true => CC1IER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CC1IER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CC1IER::ENABLED
            }
        }
        #[doc = "Possible values of the field `UIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIER {
            #[doc = "Update interrupt disabled"]
            DISABLED,
            #[doc = "Update interrupt enabled"]
            ENABLED,
        }
        impl UIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UIER::DISABLED => false,
                    UIER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UIER {
                match value {
                    false => UIER::DISABLED,
                    true => UIER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UIER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UIER::ENABLED
            }
        }
        #[doc = r" Proxy"]
        pub struct _TDEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TDEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC1DE`"]
        pub enum CC1DEW {
            #[doc = "CC1 DMA request disabled"]
            DISABLED,
            #[doc = "CC1 DMA request enabled"]
            ENABLED,
        }
        impl CC1DEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CC1DEW::DISABLED => false,
                    CC1DEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1DEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1DEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC1DEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CC1 DMA request disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1DEW::DISABLED)
            }
            #[doc = "CC1 DMA request enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1DEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UDEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UDEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BIE`"]
        pub enum BIEW {
            #[doc = "Break interrupt disabled"]
            DISABLED,
            #[doc = "Break interrupt enabled"]
            ENABLED,
        }
        impl BIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BIEW::DISABLED => false,
                    BIEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Break interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BIEW::DISABLED)
            }
            #[doc = "Break interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BIEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMIE`"]
        pub enum COMIEW {
            #[doc = "COM interrupt disabled"]
            DISABLED,
            #[doc = "COM interrupt enabled"]
            ENABLED,
        }
        impl COMIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMIEW::DISABLED => false,
                    COMIEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "COM interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMIEW::DISABLED)
            }
            #[doc = "COM interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMIEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC1IE`"]
        pub enum CC1IEW {
            #[doc = "CC1 interrupt disabled"]
            DISABLED,
            #[doc = "CC1 interrupt enabled"]
            ENABLED,
        }
        impl CC1IEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CC1IEW::DISABLED => false,
                    CC1IEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1IEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1IEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CC1IEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CC1 interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1IEW::DISABLED)
            }
            #[doc = "CC1 interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1IEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UIE`"]
        pub enum UIEW {
            #[doc = "Update interrupt disabled"]
            DISABLED,
            #[doc = "Update interrupt enabled"]
            ENABLED,
        }
        impl UIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UIEW::DISABLED => false,
                    UIEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Update interrupt disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIEW::DISABLED)
            }
            #[doc = "Update interrupt enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline]
            pub fn tde(&self) -> TDER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TDER { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline]
            pub fn cc1de(&self) -> CC1DER {
                CC1DER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline]
            pub fn ude(&self) -> UDER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                UDER { bits }
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline]
            pub fn bie(&self) -> BIER {
                BIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline]
            pub fn tie(&self) -> TIER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIER { bits }
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline]
            pub fn comie(&self) -> COMIER {
                COMIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline]
            pub fn cc1ie(&self) -> CC1IER {
                CC1IER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline]
            pub fn uie(&self) -> UIER {
                UIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline]
            pub fn tde(&mut self) -> _TDEW {
                _TDEW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline]
            pub fn cc1de(&mut self) -> _CC1DEW {
                _CC1DEW { w: self }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline]
            pub fn ude(&mut self) -> _UDEW {
                _UDEW { w: self }
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline]
            pub fn bie(&mut self) -> _BIEW {
                _BIEW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline]
            pub fn tie(&mut self) -> _TIEW {
                _TIEW { w: self }
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline]
            pub fn comie(&mut self) -> _COMIEW {
                _COMIEW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline]
            pub fn cc1ie(&mut self) -> _CC1IEW {
                _CC1IEW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline]
            pub fn uie(&mut self) -> _UIEW {
                _UIEW { w: self }
            }
        }
    }
    #[doc = "status register"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1OFR {
            bits: bool,
        }
        impl CC1OFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BIFR {
            bits: bool,
        }
        impl BIFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIFR {
            bits: bool,
        }
        impl TIFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMIFR {
            bits: bool,
        }
        impl COMIFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1IFR {
            bits: bool,
        }
        impl CC1IFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `UIF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIFR {
            #[doc = "No update occurred"]
            CLEAR,
            #[doc = "Update interrupt pending."]
            UPDATEPENDING,
        }
        impl UIFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UIFR::CLEAR => false,
                    UIFR::UPDATEPENDING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UIFR {
                match value {
                    false => UIFR::CLEAR,
                    true => UIFR::UPDATEPENDING,
                }
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline]
            pub fn is_clear(&self) -> bool {
                *self == UIFR::CLEAR
            }
            #[doc = "Checks if the value of the field is `UPDATEPENDING`"]
            #[inline]
            pub fn is_update_pending(&self) -> bool {
                *self == UIFR::UPDATEPENDING
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1OFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1OFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMIFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1IFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1IFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UIF`"]
        pub enum UIFW {
            #[doc = "No update occurred"]
            CLEAR,
            #[doc = "Update interrupt pending."]
            UPDATEPENDING,
        }
        impl UIFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UIFW::CLEAR => false,
                    UIFW::UPDATEPENDING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UIFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UIFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No update occurred"]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIFW::CLEAR)
            }
            #[doc = "Update interrupt pending."]
            #[inline]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIFW::UPDATEPENDING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline]
            pub fn cc1of(&self) -> CC1OFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1OFR { bits }
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline]
            pub fn bif(&self) -> BIFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BIFR { bits }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline]
            pub fn tif(&self) -> TIFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIFR { bits }
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline]
            pub fn comif(&self) -> COMIFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                COMIFR { bits }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline]
            pub fn cc1if(&self) -> CC1IFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1IFR { bits }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline]
            pub fn uif(&self) -> UIFR {
                UIFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline]
            pub fn cc1of(&mut self) -> _CC1OFW {
                _CC1OFW { w: self }
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline]
            pub fn bif(&mut self) -> _BIFW {
                _BIFW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline]
            pub fn tif(&mut self) -> _TIFW {
                _TIFW { w: self }
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline]
            pub fn comif(&mut self) -> _COMIFW {
                _COMIFW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline]
            pub fn cc1if(&mut self) -> _CC1IFW {
                _CC1IFW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline]
            pub fn uif(&mut self) -> _UIFW {
                _UIFW { w: self }
            }
        }
    }
    #[doc = "event generation register"]
    pub struct EGR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EGR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _BGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1GW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1GW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UG`"]
        pub enum UGW {
            #[doc = "Re-initializes the timer counter and generates an update of the reigsters."]
            UPDATE,
        }
        impl UGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UGW::UPDATE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Re-initializes the timer counter and generates an update of the reigsters."]
            #[inline]
            pub fn update(self) -> &'a mut W {
                self.variant(UGW::UPDATE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Break generation"]
            #[inline]
            pub fn bg(&mut self) -> _BGW {
                _BGW { w: self }
            }
            #[doc = "Bit 6 - Trigger generation"]
            #[inline]
            pub fn tg(&mut self) -> _TGW {
                _TGW { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare control update generation"]
            #[inline]
            pub fn comg(&mut self) -> _COMGW {
                _COMGW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline]
            pub fn cc1g(&mut self) -> _CC1GW {
                _CC1GW { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline]
            pub fn ug(&mut self) -> _UGW {
                _UGW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub struct CCMR1_OUTPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr1_output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCMR1_OUTPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1MR {
            bits: u8,
        }
        impl OC1MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1PER {
            bits: bool,
        }
        impl OC1PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OC1FER {
            bits: bool,
        }
        impl OC1FER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1SR {
            bits: u8,
        }
        impl CC1SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1MW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1PEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OC1FEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OC1FEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline]
            pub fn oc1m(&self) -> OC1MR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OC1MR { bits }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline]
            pub fn oc1pe(&self) -> OC1PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC1PER { bits }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline]
            pub fn oc1fe(&self) -> OC1FER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OC1FER { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&self) -> CC1SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC1SR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline]
            pub fn oc1m(&mut self) -> _OC1MW {
                _OC1MW { w: self }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline]
            pub fn oc1pe(&mut self) -> _OC1PEW {
                _OC1PEW { w: self }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline]
            pub fn oc1fe(&mut self) -> _OC1FEW {
                _OC1FEW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&mut self) -> _CC1SW {
                _CC1SW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub struct CCMR1_INPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCMR1_INPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC1FR {
            bits: u8,
        }
        impl IC1FR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC1PSCR {
            bits: u8,
        }
        impl IC1PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1SR {
            bits: u8,
        }
        impl CC1SR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC1FW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC1FW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IC1PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IC1PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1SW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline]
            pub fn ic1f(&self) -> IC1FR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC1FR { bits }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline]
            pub fn ic1psc(&self) -> IC1PSCR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IC1PSCR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&self) -> CC1SR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CC1SR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline]
            pub fn ic1f(&mut self) -> _IC1FW {
                _IC1FW { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline]
            pub fn ic1psc(&mut self) -> _IC1PSCW {
                _IC1PSCW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline]
            pub fn cc1s(&mut self) -> _CC1SW {
                _CC1SW { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register"]
    pub struct CCER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1NPR {
            bits: bool,
        }
        impl CC1NPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1NER {
            bits: bool,
        }
        impl CC1NER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1PR {
            bits: bool,
        }
        impl CC1PR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC1ER {
            bits: bool,
        }
        impl CC1ER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1NPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1NPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1NEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1NEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1PW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1PW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC1EW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC1EW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1np(&self) -> CC1NPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1NPR { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline]
            pub fn cc1ne(&self) -> CC1NER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1NER { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1p(&self) -> CC1PR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1PR { bits }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline]
            pub fn cc1e(&self) -> CC1ER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC1ER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1np(&mut self) -> _CC1NPW {
                _CC1NPW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline]
            pub fn cc1ne(&mut self) -> _CC1NEW {
                _CC1NEW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline]
            pub fn cc1p(&mut self) -> _CC1PW {
                _CC1PW { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline]
            pub fn cc1e(&mut self) -> _CC1EW {
                _CC1EW { w: self }
            }
        }
    }
    #[doc = "counter"]
    pub struct CNT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "counter"]
    pub mod cnt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNTR {
            bits: u16,
        }
        impl CNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline]
            pub fn cnt(&self) -> CNTR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline]
            pub fn cnt(&mut self) -> _CNTW {
                _CNTW { w: self }
            }
        }
    }
    #[doc = "prescaler"]
    pub struct PSC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PSCR {
            bits: u16,
        }
        impl PSCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline]
            pub fn psc(&self) -> PSCR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PSCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline]
            pub fn psc(&mut self) -> _PSCW {
                _PSCW { w: self }
            }
        }
    }
    #[doc = "auto-reload register"]
    pub struct ARR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ARR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ARRR {
            bits: u16,
        }
        impl ARRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ARRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ARRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline]
            pub fn arr(&self) -> ARRR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ARRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline]
            pub fn arr(&mut self) -> _ARRW {
                _ARRW { w: self }
            }
        }
    }
    #[doc = "repetition counter register"]
    pub struct RCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "repetition counter register"]
    pub mod rcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct REPR {
            bits: u8,
        }
        impl REPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _REPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline]
            pub fn rep(&self) -> REPR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                REPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline]
            pub fn rep(&mut self) -> _REPW {
                _REPW { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1"]
    pub struct CCR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "capture/compare register 1"]
    pub mod ccr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CCR1R {
            bits: u16,
        }
        impl CCR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCR1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline]
            pub fn ccr1(&self) -> CCR1R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CCR1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline]
            pub fn ccr1(&mut self) -> _CCR1W {
                _CCR1W { w: self }
            }
        }
    }
    #[doc = "break and dead-time register"]
    pub struct BDTR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "break and dead-time register"]
    pub mod bdtr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BDTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MOER {
            bits: bool,
        }
        impl MOER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AOER {
            bits: bool,
        }
        impl AOER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BKPR {
            bits: bool,
        }
        impl BKPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BKER {
            bits: bool,
        }
        impl BKER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSSRR {
            bits: bool,
        }
        impl OSSRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OSSIR {
            bits: bool,
        }
        impl OSSIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LOCKR {
            bits: u8,
        }
        impl LOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DTGR {
            bits: u8,
        }
        impl DTGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MOEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MOEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AOEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AOEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BKPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BKPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BKEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BKEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSSRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSSRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OSSIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OSSIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOCKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DTGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DTGW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Main output enable"]
            #[inline]
            pub fn moe(&self) -> MOER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MOER { bits }
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline]
            pub fn aoe(&self) -> AOER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AOER { bits }
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline]
            pub fn bkp(&self) -> BKPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BKPR { bits }
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline]
            pub fn bke(&self) -> BKER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BKER { bits }
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline]
            pub fn ossr(&self) -> OSSRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSSRR { bits }
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline]
            pub fn ossi(&self) -> OSSIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OSSIR { bits }
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline]
            pub fn lock(&self) -> LOCKR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LOCKR { bits }
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline]
            pub fn dtg(&self) -> DTGR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DTGR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Main output enable"]
            #[inline]
            pub fn moe(&mut self) -> _MOEW {
                _MOEW { w: self }
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline]
            pub fn aoe(&mut self) -> _AOEW {
                _AOEW { w: self }
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline]
            pub fn bkp(&mut self) -> _BKPW {
                _BKPW { w: self }
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline]
            pub fn bke(&mut self) -> _BKEW {
                _BKEW { w: self }
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline]
            pub fn ossr(&mut self) -> _OSSRW {
                _OSSRW { w: self }
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline]
            pub fn ossi(&mut self) -> _OSSIW {
                _OSSIW { w: self }
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline]
            pub fn lock(&mut self) -> _LOCKW {
                _LOCKW { w: self }
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline]
            pub fn dtg(&mut self) -> _DTGW {
                _DTGW { w: self }
            }
        }
    }
    #[doc = "DMA control register"]
    pub struct DCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA control register"]
    pub mod dcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBLR {
            bits: u8,
        }
        impl DBLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DBAR {
            bits: u8,
        }
        impl DBAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline]
            pub fn dbl(&self) -> DBLR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DBLR { bits }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline]
            pub fn dba(&self) -> DBAR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DBAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline]
            pub fn dbl(&mut self) -> _DBLW {
                _DBLW { w: self }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline]
            pub fn dba(&mut self) -> _DBAW {
                _DBAW { w: self }
            }
        }
    }
    #[doc = "DMA address for full transfer"]
    pub struct DMAR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA address for full transfer"]
    pub mod dmar {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMAR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMABR {
            bits: u16,
        }
        impl DMABR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMABW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMABW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline]
            pub fn dmab(&self) -> DMABR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DMABR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline]
            pub fn dmab(&mut self) -> _DMABW {
                _DMABW { w: self }
            }
        }
    }
}
#[doc = "TIM17"]
#[cfg(feature = "tim17")]
pub struct TIM17 {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "tim17")]
unsafe impl Send for TIM17 {}
#[cfg(feature = "tim17")]
impl TIM17 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const tim16::RegisterBlock {
        0x4001_4800 as *const _
    }
}
#[cfg(feature = "tim17")]
impl Deref for TIM17 {
    type Target = tim16::RegisterBlock;
    fn deref(&self) -> &tim16::RegisterBlock {
        unsafe { &*TIM17::ptr() }
    }
}
#[doc = "HDMI-CEC controller"]
#[cfg(feature = "cec")]
pub struct CEC {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "cec")]
unsafe impl Send for CEC {}
#[cfg(feature = "cec")]
impl CEC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const cec::RegisterBlock {
        0x4000_7800 as *const _
    }
}
#[cfg(feature = "cec")]
impl Deref for CEC {
    type Target = cec::RegisterBlock;
    fn deref(&self) -> &cec::RegisterBlock {
        unsafe { &*CEC::ptr() }
    }
}
#[doc = "HDMI-CEC controller"]
#[cfg(feature = "cec")]
pub mod cec {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - configuration register"]
        pub cfgr: CFGR,
        #[doc = "0x04 - CEC own address register"]
        pub oar: OAR,
        #[doc = "0x08 - Rx Data Register"]
        pub pres: PRES,
        #[doc = "0x0c - CEC error status register"]
        pub esr: ESR,
        #[doc = "0x10 - CEC control and status register"]
        pub csr: CSR,
        #[doc = "0x14 - CEC Tx data register"]
        pub txd: TXD,
        #[doc = "0x18 - CEC Rx data register"]
        pub rxd: RXD,
    }
    #[doc = "configuration register"]
    pub struct CFGR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "configuration register"]
    pub mod cfgr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CFGR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PER {
            bits: bool,
        }
        impl PER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IER {
            bits: bool,
        }
        impl IER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BTEMR {
            bits: bool,
        }
        impl BTEMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BPEMR {
            bits: bool,
        }
        impl BPEMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BTEMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BTEMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BPEMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BPEMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral enable"]
            #[inline]
            pub fn pe(&self) -> PER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PER { bits }
            }
            #[doc = "Bit 1 - Interrupt enable"]
            #[inline]
            pub fn ie(&self) -> IER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IER { bits }
            }
            #[doc = "Bit 2 - Bit timing error mode"]
            #[inline]
            pub fn btem(&self) -> BTEMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BTEMR { bits }
            }
            #[doc = "Bit 3 - Bit period error mode"]
            #[inline]
            pub fn bpem(&self) -> BPEMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BPEMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral enable"]
            #[inline]
            pub fn pe(&mut self) -> _PEW {
                _PEW { w: self }
            }
            #[doc = "Bit 1 - Interrupt enable"]
            #[inline]
            pub fn ie(&mut self) -> _IEW {
                _IEW { w: self }
            }
            #[doc = "Bit 2 - Bit timing error mode"]
            #[inline]
            pub fn btem(&mut self) -> _BTEMW {
                _BTEMW { w: self }
            }
            #[doc = "Bit 3 - Bit period error mode"]
            #[inline]
            pub fn bpem(&mut self) -> _BPEMW {
                _BPEMW { w: self }
            }
        }
    }
    #[doc = "CEC own address register"]
    pub struct OAR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CEC own address register"]
    pub mod oar {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OAR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OAR {
            bits: u8,
        }
        impl OAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Own address"]
            #[inline]
            pub fn oa(&self) -> OAR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Own address"]
            #[inline]
            pub fn oa(&mut self) -> _OAW {
                _OAW { w: self }
            }
        }
    }
    #[doc = "Rx Data Register"]
    pub struct PRES {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Rx Data Register"]
    pub mod pres {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PRES {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PRESCR {
            bits: u16,
        }
        impl PRESCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRESCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRESCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x3fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:13 - CEC Rx Data Register"]
            #[inline]
            pub fn presc(&self) -> PRESCR {
                let bits = {
                    const MASK: u16 = 0x3fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PRESCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:13 - CEC Rx Data Register"]
            #[inline]
            pub fn presc(&mut self) -> _PRESCW {
                _PRESCW { w: self }
            }
        }
    }
    #[doc = "CEC error status register"]
    pub struct ESR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CEC error status register"]
    pub mod esr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::ESR {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct BTER {
            bits: bool,
        }
        impl BTER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BPER {
            bits: bool,
        }
        impl BPER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RBTFER {
            bits: bool,
        }
        impl RBTFER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SBER {
            bits: bool,
        }
        impl SBER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACKER {
            bits: bool,
        }
        impl ACKER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LINER {
            bits: bool,
        }
        impl LINER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TBTFER {
            bits: bool,
        }
        impl TBTFER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Bit timing error"]
            #[inline]
            pub fn bte(&self) -> BTER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BTER { bits }
            }
            #[doc = "Bit 1 - Bit period error"]
            #[inline]
            pub fn bpe(&self) -> BPER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BPER { bits }
            }
            #[doc = "Bit 2 - Rx block transfer finished error"]
            #[inline]
            pub fn rbtfe(&self) -> RBTFER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RBTFER { bits }
            }
            #[doc = "Bit 3 - Start bit error"]
            #[inline]
            pub fn sbe(&self) -> SBER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SBER { bits }
            }
            #[doc = "Bit 4 - Block acknowledge error"]
            #[inline]
            pub fn acke(&self) -> ACKER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ACKER { bits }
            }
            #[doc = "Bit 5 - Line error"]
            #[inline]
            pub fn line(&self) -> LINER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LINER { bits }
            }
            #[doc = "Bit 6 - Tx block transfer finished error"]
            #[inline]
            pub fn tbtfe(&self) -> TBTFER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TBTFER { bits }
            }
        }
    }
    #[doc = "CEC control and status register"]
    pub struct CSR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CEC control and status register"]
    pub mod csr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CSR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TSOMR {
            bits: bool,
        }
        impl TSOMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TEOMR {
            bits: bool,
        }
        impl TEOMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TERRR {
            bits: bool,
        }
        impl TERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TBTRFR {
            bits: bool,
        }
        impl TBTRFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RSOMR {
            bits: bool,
        }
        impl RSOMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct REOMR {
            bits: bool,
        }
        impl REOMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RERRR {
            bits: bool,
        }
        impl RERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RBTFR {
            bits: bool,
        }
        impl RBTFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _TSOMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TSOMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TEOMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TEOMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TBTRFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TBTRFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSOMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSOMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _REOMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REOMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RBTFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RBTFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Tx start of message"]
            #[inline]
            pub fn tsom(&self) -> TSOMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TSOMR { bits }
            }
            #[doc = "Bit 1 - Tx end of message"]
            #[inline]
            pub fn teom(&self) -> TEOMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TEOMR { bits }
            }
            #[doc = "Bit 2 - Tx error"]
            #[inline]
            pub fn terr(&self) -> TERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TERRR { bits }
            }
            #[doc = "Bit 3 - Tx byte transfer request or block transfer finished"]
            #[inline]
            pub fn tbtrf(&self) -> TBTRFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TBTRFR { bits }
            }
            #[doc = "Bit 4 - Rx start of message"]
            #[inline]
            pub fn rsom(&self) -> RSOMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RSOMR { bits }
            }
            #[doc = "Bit 5 - Rx end of message"]
            #[inline]
            pub fn reom(&self) -> REOMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                REOMR { bits }
            }
            #[doc = "Bit 6 - Rx error"]
            #[inline]
            pub fn rerr(&self) -> RERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RERRR { bits }
            }
            #[doc = "Bit 7 - Rx byte/block transfer finished"]
            #[inline]
            pub fn rbtf(&self) -> RBTFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RBTFR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Tx start of message"]
            #[inline]
            pub fn tsom(&mut self) -> _TSOMW {
                _TSOMW { w: self }
            }
            #[doc = "Bit 1 - Tx end of message"]
            #[inline]
            pub fn teom(&mut self) -> _TEOMW {
                _TEOMW { w: self }
            }
            #[doc = "Bit 2 - Tx error"]
            #[inline]
            pub fn terr(&mut self) -> _TERRW {
                _TERRW { w: self }
            }
            #[doc = "Bit 3 - Tx byte transfer request or block transfer finished"]
            #[inline]
            pub fn tbtrf(&mut self) -> _TBTRFW {
                _TBTRFW { w: self }
            }
            #[doc = "Bit 4 - Rx start of message"]
            #[inline]
            pub fn rsom(&mut self) -> _RSOMW {
                _RSOMW { w: self }
            }
            #[doc = "Bit 5 - Rx end of message"]
            #[inline]
            pub fn reom(&mut self) -> _REOMW {
                _REOMW { w: self }
            }
            #[doc = "Bit 6 - Rx error"]
            #[inline]
            pub fn rerr(&mut self) -> _RERRW {
                _RERRW { w: self }
            }
            #[doc = "Bit 7 - Rx byte/block transfer finished"]
            #[inline]
            pub fn rbtf(&mut self) -> _RBTFW {
                _RBTFW { w: self }
            }
        }
    }
    #[doc = "CEC Tx data register"]
    pub struct TXD {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CEC Tx data register"]
    pub mod txd {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXDR {
            bits: u8,
        }
        impl TXDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Tx Data register"]
            #[inline]
            pub fn txd(&self) -> TXDR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TXDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Tx Data register"]
            #[inline]
            pub fn txd(&mut self) -> _TXDW {
                _TXDW { w: self }
            }
        }
    }
    #[doc = "CEC Rx data register"]
    pub struct RXD {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CEC Rx data register"]
    pub mod rxd {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RXD {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXDR {
            bits: u8,
        }
        impl RXDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Rx data"]
            #[inline]
            pub fn rxd(&self) -> RXDR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RXDR { bits }
            }
        }
    }
}
#[doc = "System control block ACTLR"]
#[cfg(feature = "scb_actrl")]
pub struct SCB_ACTRL {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "scb_actrl")]
unsafe impl Send for SCB_ACTRL {}
#[cfg(feature = "scb_actrl")]
impl SCB_ACTRL {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const scb_actrl::RegisterBlock {
        0xe000_e008 as *const _
    }
}
#[cfg(feature = "scb_actrl")]
impl Deref for SCB_ACTRL {
    type Target = scb_actrl::RegisterBlock;
    fn deref(&self) -> &scb_actrl::RegisterBlock {
        unsafe { &*SCB_ACTRL::ptr() }
    }
}
#[doc = "System control block ACTLR"]
#[cfg(feature = "scb_actrl")]
pub mod scb_actrl {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Auxiliary control register"]
        pub actrl: ACTRL,
    }
    #[doc = "Auxiliary control register"]
    pub struct ACTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Auxiliary control register"]
    pub mod actrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ACTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DISFOLDR {
            bits: bool,
        }
        impl DISFOLDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FPEXCODISR {
            bits: bool,
        }
        impl FPEXCODISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DISRAMODER {
            bits: bool,
        }
        impl DISRAMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DISITMATBFLUSHR {
            bits: bool,
        }
        impl DISITMATBFLUSHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DISFOLDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DISFOLDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FPEXCODISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FPEXCODISW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DISRAMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DISRAMODEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DISITMATBFLUSHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DISITMATBFLUSHW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 2 - DISFOLD"]
            #[inline]
            pub fn disfold(&self) -> DISFOLDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DISFOLDR { bits }
            }
            #[doc = "Bit 10 - FPEXCODIS"]
            #[inline]
            pub fn fpexcodis(&self) -> FPEXCODISR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FPEXCODISR { bits }
            }
            #[doc = "Bit 11 - DISRAMODE"]
            #[inline]
            pub fn disramode(&self) -> DISRAMODER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DISRAMODER { bits }
            }
            #[doc = "Bit 12 - DISITMATBFLUSH"]
            #[inline]
            pub fn disitmatbflush(&self) -> DISITMATBFLUSHR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DISITMATBFLUSHR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 2 - DISFOLD"]
            #[inline]
            pub fn disfold(&mut self) -> _DISFOLDW {
                _DISFOLDW { w: self }
            }
            #[doc = "Bit 10 - FPEXCODIS"]
            #[inline]
            pub fn fpexcodis(&mut self) -> _FPEXCODISW {
                _FPEXCODISW { w: self }
            }
            #[doc = "Bit 11 - DISRAMODE"]
            #[inline]
            pub fn disramode(&mut self) -> _DISRAMODEW {
                _DISRAMODEW { w: self }
            }
            #[doc = "Bit 12 - DISITMATBFLUSH"]
            #[inline]
            pub fn disitmatbflush(&mut self) -> _DISITMATBFLUSHW {
                _DISITMATBFLUSHW { w: self }
            }
        }
    }
}
#[doc = "Nested vectored interrupt controller"]
#[cfg(feature = "nvic_stir")]
pub struct NVIC_STIR {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "nvic_stir")]
unsafe impl Send for NVIC_STIR {}
#[cfg(feature = "nvic_stir")]
impl NVIC_STIR {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const nvic_stir::RegisterBlock {
        0xe000_ef00 as *const _
    }
}
#[cfg(feature = "nvic_stir")]
impl Deref for NVIC_STIR {
    type Target = nvic_stir::RegisterBlock;
    fn deref(&self) -> &nvic_stir::RegisterBlock {
        unsafe { &*NVIC_STIR::ptr() }
    }
}
#[doc = "Nested vectored interrupt controller"]
#[cfg(feature = "nvic_stir")]
pub mod nvic_stir {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Software trigger interrupt register"]
        pub stir: STIR,
    }
    #[doc = "Software trigger interrupt register"]
    pub struct STIR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Software trigger interrupt register"]
    pub mod stir {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STIR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct INTIDR {
            bits: u16,
        }
        impl INTIDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _INTIDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INTIDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x01ff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:8 - Software generated interrupt ID"]
            #[inline]
            pub fn intid(&self) -> INTIDR {
                let bits = {
                    const MASK: u16 = 0x01ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                INTIDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:8 - Software generated interrupt ID"]
            #[inline]
            pub fn intid(&mut self) -> _INTIDW {
                _INTIDW { w: self }
            }
        }
    }
}
#[doc = "SysTick timer"]
#[cfg(feature = "stk")]
pub struct STK {
    _marker: PhantomData<*const ()>,
}
#[cfg(feature = "stk")]
unsafe impl Send for STK {}
#[cfg(feature = "stk")]
impl STK {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const stk::RegisterBlock {
        0xe000_e010 as *const _
    }
}
#[cfg(feature = "stk")]
impl Deref for STK {
    type Target = stk::RegisterBlock;
    fn deref(&self) -> &stk::RegisterBlock {
        unsafe { &*STK::ptr() }
    }
}
#[doc = "SysTick timer"]
#[cfg(feature = "stk")]
pub mod stk {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - SysTick control and status register"]
        pub ctrl: CTRL,
        #[doc = "0x04 - SysTick reload value register"]
        pub load_: LOAD_,
        #[doc = "0x08 - SysTick current value register"]
        pub val: VAL,
        #[doc = "0x0c - SysTick calibration value register"]
        pub calib: CALIB,
    }
    #[doc = "SysTick control and status register"]
    pub struct CTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SysTick control and status register"]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TICKINTR {
            bits: bool,
        }
        impl TICKINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKSOURCER {
            bits: bool,
        }
        impl CLKSOURCER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COUNTFLAGR {
            bits: bool,
        }
        impl COUNTFLAGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TICKINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TICKINTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKSOURCEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKSOURCEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COUNTFLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COUNTFLAGW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 1 - SysTick exception request enable"]
            #[inline]
            pub fn tickint(&self) -> TICKINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TICKINTR { bits }
            }
            #[doc = "Bit 2 - Clock source selection"]
            #[inline]
            pub fn clksource(&self) -> CLKSOURCER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLKSOURCER { bits }
            }
            #[doc = "Bit 16 - COUNTFLAG"]
            #[inline]
            pub fn countflag(&self) -> COUNTFLAGR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                COUNTFLAGR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 1 - SysTick exception request enable"]
            #[inline]
            pub fn tickint(&mut self) -> _TICKINTW {
                _TICKINTW { w: self }
            }
            #[doc = "Bit 2 - Clock source selection"]
            #[inline]
            pub fn clksource(&mut self) -> _CLKSOURCEW {
                _CLKSOURCEW { w: self }
            }
            #[doc = "Bit 16 - COUNTFLAG"]
            #[inline]
            pub fn countflag(&mut self) -> _COUNTFLAGW {
                _COUNTFLAGW { w: self }
            }
        }
    }
    #[doc = "SysTick reload value register"]
    pub struct LOAD_ {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SysTick reload value register"]
    pub mod load_ {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LOAD_ {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RELOADR {
            bits: u32,
        }
        impl RELOADR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _RELOADW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RELOADW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x00ff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - RELOAD value"]
            #[inline]
            pub fn reload(&self) -> RELOADR {
                let bits = {
                    const MASK: u32 = 0x00ff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                RELOADR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - RELOAD value"]
            #[inline]
            pub fn reload(&mut self) -> _RELOADW {
                _RELOADW { w: self }
            }
        }
    }
    #[doc = "SysTick current value register"]
    pub struct VAL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SysTick current value register"]
    pub mod val {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::VAL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CURRENTR {
            bits: u32,
        }
        impl CURRENTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CURRENTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CURRENTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x00ff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Current counter value"]
            #[inline]
            pub fn current(&self) -> CURRENTR {
                let bits = {
                    const MASK: u32 = 0x00ff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CURRENTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - Current counter value"]
            #[inline]
            pub fn current(&mut self) -> _CURRENTW {
                _CURRENTW { w: self }
            }
        }
    }
    #[doc = "SysTick calibration value register"]
    pub struct CALIB {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SysTick calibration value register"]
    pub mod calib {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CALIB {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TENMSR {
            bits: u32,
        }
        impl TENMSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TENMSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TENMSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x00ff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Calibration value"]
            #[inline]
            pub fn tenms(&self) -> TENMSR {
                let bits = {
                    const MASK: u32 = 0x00ff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                TENMSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - Calibration value"]
            #[inline]
            pub fn tenms(&mut self) -> _TENMSW {
                _TENMSW { w: self }
            }
        }
    }
}
#[allow(renamed_and_removed_lints)]
#[allow(private_no_mangle_statics)]
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "FSMC"]
    #[cfg(feature = "fsmc")]
    pub FSMC: FSMC,
    #[doc = "PWR"]
    #[cfg(feature = "pwr")]
    pub PWR: PWR,
    #[doc = "RCC"]
    #[cfg(feature = "rcc")]
    pub RCC: RCC,
    #[doc = "GPIOA"]
    #[cfg(feature = "gpioa")]
    pub GPIOA: GPIOA,
    #[doc = "GPIOB"]
    #[cfg(feature = "gpiob")]
    pub GPIOB: GPIOB,
    #[doc = "GPIOC"]
    #[cfg(feature = "gpioc")]
    pub GPIOC: GPIOC,
    #[doc = "GPIOD"]
    #[cfg(feature = "gpiod")]
    pub GPIOD: GPIOD,
    #[doc = "GPIOE"]
    #[cfg(feature = "gpioe")]
    pub GPIOE: GPIOE,
    #[doc = "GPIOF"]
    #[cfg(feature = "gpiof")]
    pub GPIOF: GPIOF,
    #[doc = "GPIOG"]
    #[cfg(feature = "gpiog")]
    pub GPIOG: GPIOG,
    #[doc = "AFIO"]
    #[cfg(feature = "afio")]
    pub AFIO: AFIO,
    #[doc = "EXTI"]
    #[cfg(feature = "exti")]
    pub EXTI: EXTI,
    #[doc = "DMA1"]
    #[cfg(feature = "dma1")]
    pub DMA1: DMA1,
    #[doc = "DMA2"]
    #[cfg(feature = "dma2")]
    pub DMA2: DMA2,
    #[doc = "RTC"]
    #[cfg(feature = "rtc")]
    pub RTC: RTC,
    #[doc = "BKP"]
    #[cfg(feature = "bkp")]
    pub BKP: BKP,
    #[doc = "IWDG"]
    #[cfg(feature = "iwdg")]
    pub IWDG: IWDG,
    #[doc = "WWDG"]
    #[cfg(feature = "wwdg")]
    pub WWDG: WWDG,
    #[doc = "TIM1"]
    #[cfg(feature = "tim1")]
    pub TIM1: TIM1,
    #[doc = "TIM2"]
    #[cfg(feature = "tim2")]
    pub TIM2: TIM2,
    #[doc = "TIM3"]
    #[cfg(feature = "tim3")]
    pub TIM3: TIM3,
    #[doc = "TIM4"]
    #[cfg(feature = "tim4")]
    pub TIM4: TIM4,
    #[doc = "TIM5"]
    #[cfg(feature = "tim5")]
    pub TIM5: TIM5,
    #[doc = "TIM12"]
    #[cfg(feature = "tim12")]
    pub TIM12: TIM12,
    #[doc = "TIM13"]
    #[cfg(feature = "tim13")]
    pub TIM13: TIM13,
    #[doc = "TIM14"]
    #[cfg(feature = "tim14")]
    pub TIM14: TIM14,
    #[doc = "TIM6"]
    #[cfg(feature = "tim6")]
    pub TIM6: TIM6,
    #[doc = "TIM7"]
    #[cfg(feature = "tim7")]
    pub TIM7: TIM7,
    #[doc = "I2C1"]
    #[cfg(feature = "i2c1")]
    pub I2C1: I2C1,
    #[doc = "I2C2"]
    #[cfg(feature = "i2c2")]
    pub I2C2: I2C2,
    #[doc = "SPI1"]
    #[cfg(feature = "spi1")]
    pub SPI1: SPI1,
    #[doc = "SPI2"]
    #[cfg(feature = "spi2")]
    pub SPI2: SPI2,
    #[doc = "SPI3"]
    #[cfg(feature = "spi3")]
    pub SPI3: SPI3,
    #[doc = "USART1"]
    #[cfg(feature = "usart1")]
    pub USART1: USART1,
    #[doc = "USART2"]
    #[cfg(feature = "usart2")]
    pub USART2: USART2,
    #[doc = "USART3"]
    #[cfg(feature = "usart3")]
    pub USART3: USART3,
    #[doc = "ADC1"]
    #[cfg(feature = "adc1")]
    pub ADC1: ADC1,
    #[doc = "DAC"]
    #[cfg(feature = "dac")]
    pub DAC: DAC,
    #[doc = "DBG"]
    #[cfg(feature = "dbg")]
    pub DBG: DBG,
    #[doc = "UART4"]
    #[cfg(feature = "uart4")]
    pub UART4: UART4,
    #[doc = "UART5"]
    #[cfg(feature = "uart5")]
    pub UART5: UART5,
    #[doc = "CRC"]
    #[cfg(feature = "crc")]
    pub CRC: CRC,
    #[doc = "FLASH"]
    #[cfg(feature = "flash")]
    pub FLASH: FLASH,
    #[doc = "TIM15"]
    #[cfg(feature = "tim15")]
    pub TIM15: TIM15,
    #[doc = "TIM16"]
    #[cfg(feature = "tim16")]
    pub TIM16: TIM16,
    #[doc = "TIM17"]
    #[cfg(feature = "tim17")]
    pub TIM17: TIM17,
    #[doc = "CEC"]
    #[cfg(feature = "cec")]
    pub CEC: CEC,
    #[doc = "SCB_ACTRL"]
    #[cfg(feature = "scb_actrl")]
    pub SCB_ACTRL: SCB_ACTRL,
    #[doc = "NVIC_STIR"]
    #[cfg(feature = "nvic_stir")]
    pub NVIC_STIR: NVIC_STIR,
    #[doc = "STK"]
    #[cfg(feature = "stk")]
    pub STK: STK,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*"]
    #[inline]
    pub fn take() -> Option<Self> {
        cortex_m::interrupt::free(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                None
            } else {
                Some(unsafe { Peripherals::steal() })
            }
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`"]
    pub unsafe fn steal() -> Self {
        debug_assert!(!DEVICE_PERIPHERALS);
        DEVICE_PERIPHERALS = true;
        Peripherals {
            #[cfg(feature = "fsmc")]
            FSMC: FSMC {
                _marker: PhantomData,
            },
            #[cfg(feature = "pwr")]
            PWR: PWR {
                _marker: PhantomData,
            },
            #[cfg(feature = "rcc")]
            RCC: RCC {
                _marker: PhantomData,
            },
            #[cfg(feature = "gpioa")]
            GPIOA: GPIOA {
                _marker: PhantomData,
            },
            #[cfg(feature = "gpiob")]
            GPIOB: GPIOB {
                _marker: PhantomData,
            },
            #[cfg(feature = "gpioc")]
            GPIOC: GPIOC {
                _marker: PhantomData,
            },
            #[cfg(feature = "gpiod")]
            GPIOD: GPIOD {
                _marker: PhantomData,
            },
            #[cfg(feature = "gpioe")]
            GPIOE: GPIOE {
                _marker: PhantomData,
            },
            #[cfg(feature = "gpiof")]
            GPIOF: GPIOF {
                _marker: PhantomData,
            },
            #[cfg(feature = "gpiog")]
            GPIOG: GPIOG {
                _marker: PhantomData,
            },
            #[cfg(feature = "afio")]
            AFIO: AFIO {
                _marker: PhantomData,
            },
            #[cfg(feature = "exti")]
            EXTI: EXTI {
                _marker: PhantomData,
            },
            #[cfg(feature = "dma1")]
            DMA1: DMA1 {
                _marker: PhantomData,
            },
            #[cfg(feature = "dma2")]
            DMA2: DMA2 {
                _marker: PhantomData,
            },
            #[cfg(feature = "rtc")]
            RTC: RTC {
                _marker: PhantomData,
            },
            #[cfg(feature = "bkp")]
            BKP: BKP {
                _marker: PhantomData,
            },
            #[cfg(feature = "iwdg")]
            IWDG: IWDG {
                _marker: PhantomData,
            },
            #[cfg(feature = "wwdg")]
            WWDG: WWDG {
                _marker: PhantomData,
            },
            #[cfg(feature = "tim1")]
            TIM1: TIM1 {
                _marker: PhantomData,
            },
            #[cfg(feature = "tim2")]
            TIM2: TIM2 {
                _marker: PhantomData,
            },
            #[cfg(feature = "tim3")]
            TIM3: TIM3 {
                _marker: PhantomData,
            },
            #[cfg(feature = "tim4")]
            TIM4: TIM4 {
                _marker: PhantomData,
            },
            #[cfg(feature = "tim5")]
            TIM5: TIM5 {
                _marker: PhantomData,
            },
            #[cfg(feature = "tim12")]
            TIM12: TIM12 {
                _marker: PhantomData,
            },
            #[cfg(feature = "tim13")]
            TIM13: TIM13 {
                _marker: PhantomData,
            },
            #[cfg(feature = "tim14")]
            TIM14: TIM14 {
                _marker: PhantomData,
            },
            #[cfg(feature = "tim6")]
            TIM6: TIM6 {
                _marker: PhantomData,
            },
            #[cfg(feature = "tim7")]
            TIM7: TIM7 {
                _marker: PhantomData,
            },
            #[cfg(feature = "i2c1")]
            I2C1: I2C1 {
                _marker: PhantomData,
            },
            #[cfg(feature = "i2c2")]
            I2C2: I2C2 {
                _marker: PhantomData,
            },
            #[cfg(feature = "spi1")]
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            #[cfg(feature = "spi2")]
            SPI2: SPI2 {
                _marker: PhantomData,
            },
            #[cfg(feature = "spi3")]
            SPI3: SPI3 {
                _marker: PhantomData,
            },
            #[cfg(feature = "usart1")]
            USART1: USART1 {
                _marker: PhantomData,
            },
            #[cfg(feature = "usart2")]
            USART2: USART2 {
                _marker: PhantomData,
            },
            #[cfg(feature = "usart3")]
            USART3: USART3 {
                _marker: PhantomData,
            },
            #[cfg(feature = "adc1")]
            ADC1: ADC1 {
                _marker: PhantomData,
            },
            #[cfg(feature = "dac")]
            DAC: DAC {
                _marker: PhantomData,
            },
            #[cfg(feature = "dbg")]
            DBG: DBG {
                _marker: PhantomData,
            },
            #[cfg(feature = "uart4")]
            UART4: UART4 {
                _marker: PhantomData,
            },
            #[cfg(feature = "uart5")]
            UART5: UART5 {
                _marker: PhantomData,
            },
            #[cfg(feature = "crc")]
            CRC: CRC {
                _marker: PhantomData,
            },
            #[cfg(feature = "flash")]
            FLASH: FLASH {
                _marker: PhantomData,
            },
            #[cfg(feature = "tim15")]
            TIM15: TIM15 {
                _marker: PhantomData,
            },
            #[cfg(feature = "tim16")]
            TIM16: TIM16 {
                _marker: PhantomData,
            },
            #[cfg(feature = "tim17")]
            TIM17: TIM17 {
                _marker: PhantomData,
            },
            #[cfg(feature = "cec")]
            CEC: CEC {
                _marker: PhantomData,
            },
            #[cfg(feature = "scb_actrl")]
            SCB_ACTRL: SCB_ACTRL {
                _marker: PhantomData,
            },
            #[cfg(feature = "nvic_stir")]
            NVIC_STIR: NVIC_STIR {
                _marker: PhantomData,
            },
            #[cfg(feature = "stk")]
            STK: STK {
                _marker: PhantomData,
            },
        }
    }
}
